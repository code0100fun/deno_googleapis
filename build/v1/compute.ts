// Copyright 2022 Luca Casonato. All rights reserved. MIT license.
/**
 * Compute Engine API Client for Deno
 * ==================================
 * 
 * Creates and runs virtual machines on Google Cloud Platform. 
 * 
 * Docs: https://cloud.google.com/compute/
 * Source: https://github.com/code0100fun/deno_googleapis
 */

import { auth, CredentialsClient, GoogleAuth, request } from "../../base/mod.ts";
export { auth, GoogleAuth };
export type { CredentialsClient };

/**
 * Creates and runs virtual machines on Google Cloud Platform.
 */
export class Compute {
  #client: CredentialsClient | undefined;
  #baseUrl: string;

  constructor(client?: CredentialsClient, baseUrl: string = "https://compute.googleapis.com/compute/v1/") {
    this.#client = client;
    this.#baseUrl = baseUrl;
  }

  /**
   * Retrieves an aggregated list of accelerator types.
   *
   * @param project Project ID for this request.
   */
  async acceleratorTypesAggregatedList(project: string, opts: AcceleratorTypesAggregatedListOptions = {}): Promise<AcceleratorTypeAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/acceleratorTypes`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeAcceleratorTypeAggregatedList(data);
  }

  /**
   * Returns the specified accelerator type.
   *
   * @param acceleratorType Name of the accelerator type to return.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async acceleratorTypesGet(acceleratorType: string, project: string, zone: string): Promise<AcceleratorType> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/acceleratorTypes/${ acceleratorType }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeAcceleratorType(data);
  }

  /**
   * Retrieves a list of accelerator types that are available to the specified
   * project.
   *
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async acceleratorTypesList(project: string, zone: string, opts: AcceleratorTypesListOptions = {}): Promise<AcceleratorTypeList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/acceleratorTypes`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeAcceleratorTypeList(data);
  }

  /**
   * Retrieves an aggregated list of addresses.
   *
   * @param project Project ID for this request.
   */
  async addressesAggregatedList(project: string, opts: AddressesAggregatedListOptions = {}): Promise<AddressAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/addresses`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeAddressAggregatedList(data);
  }

  /**
   * Deletes the specified address resource.
   *
   * @param address Name of the address resource to delete.
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async addressesDelete(address: string, project: string, region: string, opts: AddressesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/addresses/${ address }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified address resource.
   *
   * @param address Name of the address resource to return.
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async addressesGet(address: string, project: string, region: string): Promise<Address> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/addresses/${ address }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeAddress(data);
  }

  /**
   * Creates an address resource in the specified project by using the data
   * included in the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async addressesInsert(project: string, region: string, req: Address, opts: AddressesInsertOptions = {}): Promise<Operation> {
    req = serializeAddress(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/addresses`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of addresses contained within the specified region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async addressesList(project: string, region: string, opts: AddressesListOptions = {}): Promise<AddressList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/addresses`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeAddressList(data);
  }

  /**
   * Sets the labels on an Address. To learn more about labels, read the
   * Labeling Resources documentation.
   *
   * @param project Project ID for this request.
   * @param region The region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async addressesSetLabels(project: string, region: string, resource: string, req: RegionSetLabelsRequest, opts: AddressesSetLabelsOptions = {}): Promise<Operation> {
    req = serializeRegionSetLabelsRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/addresses/${ resource }/setLabels`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves an aggregated list of autoscalers.
   *
   * @param project Project ID for this request.
   */
  async autoscalersAggregatedList(project: string, opts: AutoscalersAggregatedListOptions = {}): Promise<AutoscalerAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/autoscalers`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeAutoscalerAggregatedList(data);
  }

  /**
   * Deletes the specified autoscaler.
   *
   * @param autoscaler Name of the autoscaler to delete.
   * @param project Project ID for this request.
   * @param zone Name of the zone for this request.
   */
  async autoscalersDelete(autoscaler: string, project: string, zone: string, opts: AutoscalersDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/autoscalers/${ autoscaler }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified autoscaler resource.
   *
   * @param autoscaler Name of the autoscaler to return.
   * @param project Project ID for this request.
   * @param zone Name of the zone for this request.
   */
  async autoscalersGet(autoscaler: string, project: string, zone: string): Promise<Autoscaler> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/autoscalers/${ autoscaler }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeAutoscaler(data);
  }

  /**
   * Creates an autoscaler in the specified project using the data included in
   * the request.
   *
   * @param project Project ID for this request.
   * @param zone Name of the zone for this request.
   */
  async autoscalersInsert(project: string, zone: string, req: Autoscaler, opts: AutoscalersInsertOptions = {}): Promise<Operation> {
    req = serializeAutoscaler(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/autoscalers`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of autoscalers contained within the specified zone.
   *
   * @param project Project ID for this request.
   * @param zone Name of the zone for this request.
   */
  async autoscalersList(project: string, zone: string, opts: AutoscalersListOptions = {}): Promise<AutoscalerList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/autoscalers`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeAutoscalerList(data);
  }

  /**
   * Updates an autoscaler in the specified project using the data included in
   * the request. This method supports PATCH semantics and uses the JSON merge
   * patch format and processing rules.
   *
   * @param project Project ID for this request.
   * @param zone Name of the zone for this request.
   */
  async autoscalersPatch(project: string, zone: string, req: Autoscaler, opts: AutoscalersPatchOptions = {}): Promise<Operation> {
    req = serializeAutoscaler(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/autoscalers`);
    if (opts.autoscaler !== undefined) {
      url.searchParams.append("autoscaler", String(opts.autoscaler));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Updates an autoscaler in the specified project using the data included in
   * the request.
   *
   * @param project Project ID for this request.
   * @param zone Name of the zone for this request.
   */
  async autoscalersUpdate(project: string, zone: string, req: Autoscaler, opts: AutoscalersUpdateOptions = {}): Promise<Operation> {
    req = serializeAutoscaler(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/autoscalers`);
    if (opts.autoscaler !== undefined) {
      url.searchParams.append("autoscaler", String(opts.autoscaler));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PUT",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Adds a key for validating requests with signed URLs for this backend
   * bucket.
   *
   * @param backendBucket Name of the BackendBucket resource to which the Signed URL Key should be added. The name should conform to RFC1035.
   * @param project Project ID for this request.
   */
  async backendBucketsAddSignedUrlKey(backendBucket: string, project: string, req: SignedUrlKey, opts: BackendBucketsAddSignedUrlKeyOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/backendBuckets/${ backendBucket }/addSignedUrlKey`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified BackendBucket resource.
   *
   * @param backendBucket Name of the BackendBucket resource to delete.
   * @param project Project ID for this request.
   */
  async backendBucketsDelete(backendBucket: string, project: string, opts: BackendBucketsDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/backendBuckets/${ backendBucket }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes a key for validating requests with signed URLs for this backend
   * bucket.
   *
   * @param backendBucket Name of the BackendBucket resource to which the Signed URL Key should be added. The name should conform to RFC1035.
   * @param project Project ID for this request.
   */
  async backendBucketsDeleteSignedUrlKey(backendBucket: string, project: string, opts: BackendBucketsDeleteSignedUrlKeyOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/backendBuckets/${ backendBucket }/deleteSignedUrlKey`);
    if (opts.keyName !== undefined) {
      url.searchParams.append("keyName", String(opts.keyName));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified BackendBucket resource.
   *
   * @param backendBucket Name of the BackendBucket resource to return.
   * @param project Project ID for this request.
   */
  async backendBucketsGet(backendBucket: string, project: string): Promise<BackendBucket> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/backendBuckets/${ backendBucket }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeBackendBucket(data);
  }

  /**
   * Creates a BackendBucket resource in the specified project using the data
   * included in the request.
   *
   * @param project Project ID for this request.
   */
  async backendBucketsInsert(project: string, req: BackendBucket, opts: BackendBucketsInsertOptions = {}): Promise<Operation> {
    req = serializeBackendBucket(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/backendBuckets`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of BackendBucket resources available to the specified
   * project.
   *
   * @param project Project ID for this request.
   */
  async backendBucketsList(project: string, opts: BackendBucketsListOptions = {}): Promise<BackendBucketList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/backendBuckets`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeBackendBucketList(data);
  }

  /**
   * Updates the specified BackendBucket resource with the data included in the
   * request. This method supports PATCH semantics and uses the JSON merge patch
   * format and processing rules.
   *
   * @param backendBucket Name of the BackendBucket resource to patch.
   * @param project Project ID for this request.
   */
  async backendBucketsPatch(backendBucket: string, project: string, req: BackendBucket, opts: BackendBucketsPatchOptions = {}): Promise<Operation> {
    req = serializeBackendBucket(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/backendBuckets/${ backendBucket }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the edge security policy for the specified backend bucket.
   *
   * @param backendBucket Name of the BackendService resource to which the security policy should be set. The name should conform to RFC1035.
   * @param project Project ID for this request.
   */
  async backendBucketsSetEdgeSecurityPolicy(backendBucket: string, project: string, req: SecurityPolicyReference, opts: BackendBucketsSetEdgeSecurityPolicyOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/backendBuckets/${ backendBucket }/setEdgeSecurityPolicy`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Updates the specified BackendBucket resource with the data included in the
   * request.
   *
   * @param backendBucket Name of the BackendBucket resource to update.
   * @param project Project ID for this request.
   */
  async backendBucketsUpdate(backendBucket: string, project: string, req: BackendBucket, opts: BackendBucketsUpdateOptions = {}): Promise<Operation> {
    req = serializeBackendBucket(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/backendBuckets/${ backendBucket }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PUT",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Adds a key for validating requests with signed URLs for this backend
   * service.
   *
   * @param backendService Name of the BackendService resource to which the Signed URL Key should be added. The name should conform to RFC1035.
   * @param project Project ID for this request.
   */
  async backendServicesAddSignedUrlKey(backendService: string, project: string, req: SignedUrlKey, opts: BackendServicesAddSignedUrlKeyOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/backendServices/${ backendService }/addSignedUrlKey`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of all BackendService resources, regional and global,
   * available to the specified project.
   *
   * @param project Name of the project scoping this request.
   */
  async backendServicesAggregatedList(project: string, opts: BackendServicesAggregatedListOptions = {}): Promise<BackendServiceAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/backendServices`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeBackendServiceAggregatedList(data);
  }

  /**
   * Deletes the specified BackendService resource.
   *
   * @param backendService Name of the BackendService resource to delete.
   * @param project Project ID for this request.
   */
  async backendServicesDelete(backendService: string, project: string, opts: BackendServicesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/backendServices/${ backendService }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes a key for validating requests with signed URLs for this backend
   * service.
   *
   * @param backendService Name of the BackendService resource to which the Signed URL Key should be added. The name should conform to RFC1035.
   * @param project Project ID for this request.
   */
  async backendServicesDeleteSignedUrlKey(backendService: string, project: string, opts: BackendServicesDeleteSignedUrlKeyOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/backendServices/${ backendService }/deleteSignedUrlKey`);
    if (opts.keyName !== undefined) {
      url.searchParams.append("keyName", String(opts.keyName));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified BackendService resource.
   *
   * @param backendService Name of the BackendService resource to return.
   * @param project Project ID for this request.
   */
  async backendServicesGet(backendService: string, project: string): Promise<BackendService> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/backendServices/${ backendService }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeBackendService(data);
  }

  /**
   * Gets the most recent health check results for this BackendService. Example
   * request body: { "group":
   * "/zones/us-east1-b/instanceGroups/lb-backend-example" }
   *
   * @param backendService Name of the BackendService resource to which the queried instance belongs.
   */
  async backendServicesGetHealth(backendService: string, project: string, req: ResourceGroupReference): Promise<BackendServiceGroupHealth> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/backendServices/${ backendService }/getHealth`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as BackendServiceGroupHealth;
  }

  /**
   * Gets the access control policy for a resource. May be empty if no such
   * policy or resource exists.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async backendServicesGetIamPolicy(project: string, resource: string, opts: BackendServicesGetIamPolicyOptions = {}): Promise<Policy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/backendServices/${ resource }/getIamPolicy`);
    if (opts.optionsRequestedPolicyVersion !== undefined) {
      url.searchParams.append("optionsRequestedPolicyVersion", String(opts.optionsRequestedPolicyVersion));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePolicy(data);
  }

  /**
   * Creates a BackendService resource in the specified project using the data
   * included in the request. For more information, see Backend services
   * overview .
   *
   * @param project Project ID for this request.
   */
  async backendServicesInsert(project: string, req: BackendService, opts: BackendServicesInsertOptions = {}): Promise<Operation> {
    req = serializeBackendService(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/backendServices`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of BackendService resources available to the specified
   * project.
   *
   * @param project Project ID for this request.
   */
  async backendServicesList(project: string, opts: BackendServicesListOptions = {}): Promise<BackendServiceList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/backendServices`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeBackendServiceList(data);
  }

  /**
   * Patches the specified BackendService resource with the data included in
   * the request. For more information, see Backend services overview. This
   * method supports PATCH semantics and uses the JSON merge patch format and
   * processing rules.
   *
   * @param backendService Name of the BackendService resource to patch.
   * @param project Project ID for this request.
   */
  async backendServicesPatch(backendService: string, project: string, req: BackendService, opts: BackendServicesPatchOptions = {}): Promise<Operation> {
    req = serializeBackendService(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/backendServices/${ backendService }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the edge security policy for the specified backend service.
   *
   * @param backendService Name of the BackendService resource to which the edge security policy should be set. The name should conform to RFC1035.
   * @param project Project ID for this request.
   */
  async backendServicesSetEdgeSecurityPolicy(backendService: string, project: string, req: SecurityPolicyReference, opts: BackendServicesSetEdgeSecurityPolicyOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/backendServices/${ backendService }/setEdgeSecurityPolicy`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async backendServicesSetIamPolicy(project: string, resource: string, req: GlobalSetPolicyRequest): Promise<Policy> {
    req = serializeGlobalSetPolicyRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/backendServices/${ resource }/setIamPolicy`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializePolicy(data);
  }

  /**
   * Sets the Google Cloud Armor security policy for the specified backend
   * service. For more information, see Google Cloud Armor Overview
   *
   * @param backendService Name of the BackendService resource to which the security policy should be set. The name should conform to RFC1035.
   * @param project Project ID for this request.
   */
  async backendServicesSetSecurityPolicy(backendService: string, project: string, req: SecurityPolicyReference, opts: BackendServicesSetSecurityPolicyOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/backendServices/${ backendService }/setSecurityPolicy`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Updates the specified BackendService resource with the data included in
   * the request. For more information, see Backend services overview.
   *
   * @param backendService Name of the BackendService resource to update.
   * @param project Project ID for this request.
   */
  async backendServicesUpdate(backendService: string, project: string, req: BackendService, opts: BackendServicesUpdateOptions = {}): Promise<Operation> {
    req = serializeBackendService(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/backendServices/${ backendService }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PUT",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Adds existing resource policies to a disk. You can only add one policy
   * which will be applied to this disk for scheduling snapshot creation.
   *
   * @param disk The disk name for this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async disksAddResourcePolicies(disk: string, project: string, zone: string, req: DisksAddResourcePoliciesRequest, opts: DisksAddResourcePoliciesOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/disks/${ disk }/addResourcePolicies`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves an aggregated list of persistent disks.
   *
   * @param project Project ID for this request.
   */
  async disksAggregatedList(project: string, opts: DisksAggregatedListOptions = {}): Promise<DiskAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/disks`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeDiskAggregatedList(data);
  }

  /**
   * Creates a snapshot of a specified persistent disk. For regular snapshot
   * creation, consider using snapshots.insert instead, as that method supports
   * more features, such as creating snapshots in a project different from the
   * source disk project.
   *
   * @param disk Name of the persistent disk to snapshot.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async disksCreateSnapshot(disk: string, project: string, zone: string, req: Snapshot, opts: DisksCreateSnapshotOptions = {}): Promise<Operation> {
    req = serializeSnapshot(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/disks/${ disk }/createSnapshot`);
    if (opts.guestFlush !== undefined) {
      url.searchParams.append("guestFlush", String(opts.guestFlush));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified persistent disk. Deleting a disk removes its data
   * permanently and is irreversible. However, deleting a disk does not delete
   * any snapshots previously made from the disk. You must separately delete
   * snapshots.
   *
   * @param disk Name of the persistent disk to delete.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async disksDelete(disk: string, project: string, zone: string, opts: DisksDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/disks/${ disk }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified persistent disk.
   *
   * @param disk Name of the persistent disk to return.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async disksGet(disk: string, project: string, zone: string): Promise<Disk> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/disks/${ disk }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeDisk(data);
  }

  /**
   * Gets the access control policy for a resource. May be empty if no such
   * policy or resource exists.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   * @param zone The name of the zone for this request.
   */
  async disksGetIamPolicy(project: string, resource: string, zone: string, opts: DisksGetIamPolicyOptions = {}): Promise<Policy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/disks/${ resource }/getIamPolicy`);
    if (opts.optionsRequestedPolicyVersion !== undefined) {
      url.searchParams.append("optionsRequestedPolicyVersion", String(opts.optionsRequestedPolicyVersion));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePolicy(data);
  }

  /**
   * Creates a persistent disk in the specified project using the data in the
   * request. You can create a disk from a source (sourceImage, sourceSnapshot,
   * or sourceDisk) or create an empty 500 GB data disk by omitting all
   * properties. You can also create a disk that is larger than the default size
   * by specifying the sizeGb property.
   *
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async disksInsert(project: string, zone: string, req: Disk, opts: DisksInsertOptions = {}): Promise<Operation> {
    req = serializeDisk(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/disks`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    if (opts.sourceImage !== undefined) {
      url.searchParams.append("sourceImage", String(opts.sourceImage));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of persistent disks contained within the specified zone.
   *
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async disksList(project: string, zone: string, opts: DisksListOptions = {}): Promise<DiskList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/disks`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeDiskList(data);
  }

  /**
   * Removes resource policies from a disk.
   *
   * @param disk The disk name for this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async disksRemoveResourcePolicies(disk: string, project: string, zone: string, req: DisksRemoveResourcePoliciesRequest, opts: DisksRemoveResourcePoliciesOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/disks/${ disk }/removeResourcePolicies`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Resizes the specified persistent disk. You can only increase the size of
   * the disk.
   *
   * @param disk The name of the persistent disk.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async disksResize(disk: string, project: string, zone: string, req: DisksResizeRequest, opts: DisksResizeOptions = {}): Promise<Operation> {
    req = serializeDisksResizeRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/disks/${ disk }/resize`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   * @param zone The name of the zone for this request.
   */
  async disksSetIamPolicy(project: string, resource: string, zone: string, req: ZoneSetPolicyRequest): Promise<Policy> {
    req = serializeZoneSetPolicyRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/disks/${ resource }/setIamPolicy`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializePolicy(data);
  }

  /**
   * Sets the labels on a disk. To learn more about labels, read the Labeling
   * Resources documentation.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   * @param zone The name of the zone for this request.
   */
  async disksSetLabels(project: string, resource: string, zone: string, req: ZoneSetLabelsRequest, opts: DisksSetLabelsOptions = {}): Promise<Operation> {
    req = serializeZoneSetLabelsRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/disks/${ resource }/setLabels`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Returns permissions that a caller has on the specified resource.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   * @param zone The name of the zone for this request.
   */
  async disksTestIamPermissions(project: string, resource: string, zone: string, req: TestPermissionsRequest): Promise<TestPermissionsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/disks/${ resource }/testIamPermissions`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as TestPermissionsResponse;
  }

  /**
   * Updates the specified disk with the data included in the request. The
   * update is performed only on selected fields included as part of
   * update-mask. Only the following fields can be modified: user_license.
   *
   * @param disk The disk name for this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async disksUpdate(disk: string, project: string, zone: string, req: Disk, opts: DisksUpdateOptions = {}): Promise<Operation> {
    req = serializeDisk(req);
    opts = serializeDisksUpdateOptions(opts);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/disks/${ disk }`);
    if (opts.paths !== undefined) {
      url.searchParams.append("paths", String(opts.paths));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    if (opts.updateMask !== undefined) {
      url.searchParams.append("updateMask", String(opts.updateMask));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves an aggregated list of disk types.
   *
   * @param project Project ID for this request.
   */
  async diskTypesAggregatedList(project: string, opts: DiskTypesAggregatedListOptions = {}): Promise<DiskTypeAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/diskTypes`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeDiskTypeAggregatedList(data);
  }

  /**
   * Returns the specified disk type.
   *
   * @param diskType Name of the disk type to return.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async diskTypesGet(diskType: string, project: string, zone: string): Promise<DiskType> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/diskTypes/${ diskType }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeDiskType(data);
  }

  /**
   * Retrieves a list of disk types available to the specified project.
   *
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async diskTypesList(project: string, zone: string, opts: DiskTypesListOptions = {}): Promise<DiskTypeList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/diskTypes`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeDiskTypeList(data);
  }

  /**
   * Deletes the specified externalVpnGateway.
   *
   * @param externalVpnGateway Name of the externalVpnGateways to delete.
   * @param project Project ID for this request.
   */
  async externalVpnGatewaysDelete(externalVpnGateway: string, project: string, opts: ExternalVpnGatewaysDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/externalVpnGateways/${ externalVpnGateway }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified externalVpnGateway. Get a list of available
   * externalVpnGateways by making a list() request.
   *
   * @param externalVpnGateway Name of the externalVpnGateway to return.
   * @param project Project ID for this request.
   */
  async externalVpnGatewaysGet(externalVpnGateway: string, project: string): Promise<ExternalVpnGateway> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/externalVpnGateways/${ externalVpnGateway }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeExternalVpnGateway(data);
  }

  /**
   * Creates a ExternalVpnGateway in the specified project using the data
   * included in the request.
   *
   * @param project Project ID for this request.
   */
  async externalVpnGatewaysInsert(project: string, req: ExternalVpnGateway, opts: ExternalVpnGatewaysInsertOptions = {}): Promise<Operation> {
    req = serializeExternalVpnGateway(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/externalVpnGateways`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of ExternalVpnGateway available to the specified
   * project.
   *
   * @param project Project ID for this request.
   */
  async externalVpnGatewaysList(project: string, opts: ExternalVpnGatewaysListOptions = {}): Promise<ExternalVpnGatewayList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/externalVpnGateways`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeExternalVpnGatewayList(data);
  }

  /**
   * Sets the labels on an ExternalVpnGateway. To learn more about labels, read
   * the Labeling Resources documentation.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async externalVpnGatewaysSetLabels(project: string, resource: string, req: GlobalSetLabelsRequest): Promise<Operation> {
    req = serializeGlobalSetLabelsRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/externalVpnGateways/${ resource }/setLabels`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Returns permissions that a caller has on the specified resource.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async externalVpnGatewaysTestIamPermissions(project: string, resource: string, req: TestPermissionsRequest): Promise<TestPermissionsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/externalVpnGateways/${ resource }/testIamPermissions`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as TestPermissionsResponse;
  }

  /**
   * Inserts an association for the specified firewall policy.
   *
   * @param firewallPolicy Name of the firewall policy to update.
   */
  async firewallPoliciesAddAssociation(firewallPolicy: string, req: FirewallPolicyAssociation, opts: FirewallPoliciesAddAssociationOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}locations/global/firewallPolicies/${ firewallPolicy }/addAssociation`);
    if (opts.replaceExistingAssociation !== undefined) {
      url.searchParams.append("replaceExistingAssociation", String(opts.replaceExistingAssociation));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Inserts a rule into a firewall policy.
   *
   * @param firewallPolicy Name of the firewall policy to update.
   */
  async firewallPoliciesAddRule(firewallPolicy: string, req: FirewallPolicyRule, opts: FirewallPoliciesAddRuleOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}locations/global/firewallPolicies/${ firewallPolicy }/addRule`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Copies rules to the specified firewall policy.
   *
   * @param firewallPolicy Name of the firewall policy to update.
   */
  async firewallPoliciesCloneRules(firewallPolicy: string, opts: FirewallPoliciesCloneRulesOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}locations/global/firewallPolicies/${ firewallPolicy }/cloneRules`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    if (opts.sourceFirewallPolicy !== undefined) {
      url.searchParams.append("sourceFirewallPolicy", String(opts.sourceFirewallPolicy));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified policy.
   *
   * @param firewallPolicy Name of the firewall policy to delete.
   */
  async firewallPoliciesDelete(firewallPolicy: string, opts: FirewallPoliciesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}locations/global/firewallPolicies/${ firewallPolicy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified firewall policy.
   *
   * @param firewallPolicy Name of the firewall policy to get.
   */
  async firewallPoliciesGet(firewallPolicy: string): Promise<FirewallPolicy> {
    const url = new URL(`${this.#baseUrl}locations/global/firewallPolicies/${ firewallPolicy }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeFirewallPolicy(data);
  }

  /**
   * Gets an association with the specified name.
   *
   * @param firewallPolicy Name of the firewall policy to which the queried rule belongs.
   */
  async firewallPoliciesGetAssociation(firewallPolicy: string, opts: FirewallPoliciesGetAssociationOptions = {}): Promise<FirewallPolicyAssociation> {
    const url = new URL(`${this.#baseUrl}locations/global/firewallPolicies/${ firewallPolicy }/getAssociation`);
    if (opts.name !== undefined) {
      url.searchParams.append("name", String(opts.name));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return data as FirewallPolicyAssociation;
  }

  /**
   * Gets the access control policy for a resource. May be empty if no such
   * policy or resource exists.
   *
   * @param resource Name or id of the resource for this request.
   */
  async firewallPoliciesGetIamPolicy(resource: string, opts: FirewallPoliciesGetIamPolicyOptions = {}): Promise<Policy> {
    const url = new URL(`${this.#baseUrl}locations/global/firewallPolicies/${ resource }/getIamPolicy`);
    if (opts.optionsRequestedPolicyVersion !== undefined) {
      url.searchParams.append("optionsRequestedPolicyVersion", String(opts.optionsRequestedPolicyVersion));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePolicy(data);
  }

  /**
   * Gets a rule of the specified priority.
   *
   * @param firewallPolicy Name of the firewall policy to which the queried rule belongs.
   */
  async firewallPoliciesGetRule(firewallPolicy: string, opts: FirewallPoliciesGetRuleOptions = {}): Promise<FirewallPolicyRule> {
    const url = new URL(`${this.#baseUrl}locations/global/firewallPolicies/${ firewallPolicy }/getRule`);
    if (opts.priority !== undefined) {
      url.searchParams.append("priority", String(opts.priority));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return data as FirewallPolicyRule;
  }

  /**
   * Creates a new policy in the specified project using the data included in
   * the request.
   *
   */
  async firewallPoliciesInsert(req: FirewallPolicy, opts: FirewallPoliciesInsertOptions = {}): Promise<Operation> {
    req = serializeFirewallPolicy(req);
    const url = new URL(`${this.#baseUrl}locations/global/firewallPolicies`);
    if (opts.parentId !== undefined) {
      url.searchParams.append("parentId", String(opts.parentId));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Lists all the policies that have been configured for the specified folder
   * or organization.
   *
   */
  async firewallPoliciesList(opts: FirewallPoliciesListOptions = {}): Promise<FirewallPolicyList> {
    const url = new URL(`${this.#baseUrl}locations/global/firewallPolicies`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.parentId !== undefined) {
      url.searchParams.append("parentId", String(opts.parentId));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeFirewallPolicyList(data);
  }

  /**
   * Lists associations of a specified target, i.e., organization or folder.
   *
   */
  async firewallPoliciesListAssociations(opts: FirewallPoliciesListAssociationsOptions = {}): Promise<FirewallPoliciesListAssociationsResponse> {
    const url = new URL(`${this.#baseUrl}locations/global/firewallPolicies/listAssociations`);
    if (opts.targetResource !== undefined) {
      url.searchParams.append("targetResource", String(opts.targetResource));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return data as FirewallPoliciesListAssociationsResponse;
  }

  /**
   * Moves the specified firewall policy.
   *
   * @param firewallPolicy Name of the firewall policy to update.
   */
  async firewallPoliciesMove(firewallPolicy: string, opts: FirewallPoliciesMoveOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}locations/global/firewallPolicies/${ firewallPolicy }/move`);
    if (opts.parentId !== undefined) {
      url.searchParams.append("parentId", String(opts.parentId));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Patches the specified policy with the data included in the request.
   *
   * @param firewallPolicy Name of the firewall policy to update.
   */
  async firewallPoliciesPatch(firewallPolicy: string, req: FirewallPolicy, opts: FirewallPoliciesPatchOptions = {}): Promise<Operation> {
    req = serializeFirewallPolicy(req);
    const url = new URL(`${this.#baseUrl}locations/global/firewallPolicies/${ firewallPolicy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Patches a rule of the specified priority.
   *
   * @param firewallPolicy Name of the firewall policy to update.
   */
  async firewallPoliciesPatchRule(firewallPolicy: string, req: FirewallPolicyRule, opts: FirewallPoliciesPatchRuleOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}locations/global/firewallPolicies/${ firewallPolicy }/patchRule`);
    if (opts.priority !== undefined) {
      url.searchParams.append("priority", String(opts.priority));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Removes an association for the specified firewall policy.
   *
   * @param firewallPolicy Name of the firewall policy to update.
   */
  async firewallPoliciesRemoveAssociation(firewallPolicy: string, opts: FirewallPoliciesRemoveAssociationOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}locations/global/firewallPolicies/${ firewallPolicy }/removeAssociation`);
    if (opts.name !== undefined) {
      url.searchParams.append("name", String(opts.name));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes a rule of the specified priority.
   *
   * @param firewallPolicy Name of the firewall policy to update.
   */
  async firewallPoliciesRemoveRule(firewallPolicy: string, opts: FirewallPoliciesRemoveRuleOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}locations/global/firewallPolicies/${ firewallPolicy }/removeRule`);
    if (opts.priority !== undefined) {
      url.searchParams.append("priority", String(opts.priority));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy.
   *
   * @param resource Name or id of the resource for this request.
   */
  async firewallPoliciesSetIamPolicy(resource: string, req: GlobalOrganizationSetPolicyRequest): Promise<Policy> {
    req = serializeGlobalOrganizationSetPolicyRequest(req);
    const url = new URL(`${this.#baseUrl}locations/global/firewallPolicies/${ resource }/setIamPolicy`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializePolicy(data);
  }

  /**
   * Returns permissions that a caller has on the specified resource.
   *
   * @param resource Name or id of the resource for this request.
   */
  async firewallPoliciesTestIamPermissions(resource: string, req: TestPermissionsRequest): Promise<TestPermissionsResponse> {
    const url = new URL(`${this.#baseUrl}locations/global/firewallPolicies/${ resource }/testIamPermissions`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as TestPermissionsResponse;
  }

  /**
   * Deletes the specified firewall.
   *
   * @param firewall Name of the firewall rule to delete.
   * @param project Project ID for this request.
   */
  async firewallsDelete(firewall: string, project: string, opts: FirewallsDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/firewalls/${ firewall }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified firewall.
   *
   * @param firewall Name of the firewall rule to return.
   * @param project Project ID for this request.
   */
  async firewallsGet(firewall: string, project: string): Promise<Firewall> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/firewalls/${ firewall }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeFirewall(data);
  }

  /**
   * Creates a firewall rule in the specified project using the data included
   * in the request.
   *
   * @param project Project ID for this request.
   */
  async firewallsInsert(project: string, req: Firewall, opts: FirewallsInsertOptions = {}): Promise<Operation> {
    req = serializeFirewall(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/firewalls`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of firewall rules available to the specified project.
   *
   * @param project Project ID for this request.
   */
  async firewallsList(project: string, opts: FirewallsListOptions = {}): Promise<FirewallList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/firewalls`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeFirewallList(data);
  }

  /**
   * Updates the specified firewall rule with the data included in the request.
   * This method supports PATCH semantics and uses the JSON merge patch format
   * and processing rules.
   *
   * @param firewall Name of the firewall rule to patch.
   * @param project Project ID for this request.
   */
  async firewallsPatch(firewall: string, project: string, req: Firewall, opts: FirewallsPatchOptions = {}): Promise<Operation> {
    req = serializeFirewall(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/firewalls/${ firewall }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Updates the specified firewall rule with the data included in the request.
   * Note that all fields will be updated if using PUT, even fields that are not
   * specified. To update individual fields, please use PATCH instead.
   *
   * @param firewall Name of the firewall rule to update.
   * @param project Project ID for this request.
   */
  async firewallsUpdate(firewall: string, project: string, req: Firewall, opts: FirewallsUpdateOptions = {}): Promise<Operation> {
    req = serializeFirewall(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/firewalls/${ firewall }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PUT",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves an aggregated list of forwarding rules.
   *
   * @param project Project ID for this request.
   */
  async forwardingRulesAggregatedList(project: string, opts: ForwardingRulesAggregatedListOptions = {}): Promise<ForwardingRuleAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/forwardingRules`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeForwardingRuleAggregatedList(data);
  }

  /**
   * Deletes the specified ForwardingRule resource.
   *
   * @param forwardingRule Name of the ForwardingRule resource to delete.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async forwardingRulesDelete(forwardingRule: string, project: string, region: string, opts: ForwardingRulesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/forwardingRules/${ forwardingRule }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified ForwardingRule resource.
   *
   * @param forwardingRule Name of the ForwardingRule resource to return.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async forwardingRulesGet(forwardingRule: string, project: string, region: string): Promise<ForwardingRule> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/forwardingRules/${ forwardingRule }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeForwardingRule(data);
  }

  /**
   * Creates a ForwardingRule resource in the specified project and region
   * using the data included in the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async forwardingRulesInsert(project: string, region: string, req: ForwardingRule, opts: ForwardingRulesInsertOptions = {}): Promise<Operation> {
    req = serializeForwardingRule(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/forwardingRules`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of ForwardingRule resources available to the specified
   * project and region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async forwardingRulesList(project: string, region: string, opts: ForwardingRulesListOptions = {}): Promise<ForwardingRuleList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/forwardingRules`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeForwardingRuleList(data);
  }

  /**
   * Updates the specified forwarding rule with the data included in the
   * request. This method supports PATCH semantics and uses the JSON merge patch
   * format and processing rules. Currently, you can only patch the network_tier
   * field.
   *
   * @param forwardingRule Name of the ForwardingRule resource to patch.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async forwardingRulesPatch(forwardingRule: string, project: string, region: string, req: ForwardingRule, opts: ForwardingRulesPatchOptions = {}): Promise<Operation> {
    req = serializeForwardingRule(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/forwardingRules/${ forwardingRule }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the labels on the specified resource. To learn more about labels,
   * read the Labeling Resources documentation.
   *
   * @param project Project ID for this request.
   * @param region The region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async forwardingRulesSetLabels(project: string, region: string, resource: string, req: RegionSetLabelsRequest, opts: ForwardingRulesSetLabelsOptions = {}): Promise<Operation> {
    req = serializeRegionSetLabelsRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/forwardingRules/${ resource }/setLabels`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Changes target URL for forwarding rule. The new target should be of the
   * same type as the old target.
   *
   * @param forwardingRule Name of the ForwardingRule resource in which target is to be set.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async forwardingRulesSetTarget(forwardingRule: string, project: string, region: string, req: TargetReference, opts: ForwardingRulesSetTargetOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/forwardingRules/${ forwardingRule }/setTarget`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified address resource.
   *
   * @param address Name of the address resource to delete.
   * @param project Project ID for this request.
   */
  async globalAddressesDelete(address: string, project: string, opts: GlobalAddressesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/addresses/${ address }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified address resource.
   *
   * @param address Name of the address resource to return.
   * @param project Project ID for this request.
   */
  async globalAddressesGet(address: string, project: string): Promise<Address> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/addresses/${ address }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeAddress(data);
  }

  /**
   * Creates an address resource in the specified project by using the data
   * included in the request.
   *
   * @param project Project ID for this request.
   */
  async globalAddressesInsert(project: string, req: Address, opts: GlobalAddressesInsertOptions = {}): Promise<Operation> {
    req = serializeAddress(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/addresses`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of global addresses.
   *
   * @param project Project ID for this request.
   */
  async globalAddressesList(project: string, opts: GlobalAddressesListOptions = {}): Promise<AddressList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/addresses`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeAddressList(data);
  }

  /**
   * Sets the labels on a GlobalAddress. To learn more about labels, read the
   * Labeling Resources documentation.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async globalAddressesSetLabels(project: string, resource: string, req: GlobalSetLabelsRequest): Promise<Operation> {
    req = serializeGlobalSetLabelsRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/addresses/${ resource }/setLabels`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified GlobalForwardingRule resource.
   *
   * @param forwardingRule Name of the ForwardingRule resource to delete.
   * @param project Project ID for this request.
   */
  async globalForwardingRulesDelete(forwardingRule: string, project: string, opts: GlobalForwardingRulesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/forwardingRules/${ forwardingRule }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified GlobalForwardingRule resource. Gets a list of
   * available forwarding rules by making a list() request.
   *
   * @param forwardingRule Name of the ForwardingRule resource to return.
   * @param project Project ID for this request.
   */
  async globalForwardingRulesGet(forwardingRule: string, project: string): Promise<ForwardingRule> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/forwardingRules/${ forwardingRule }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeForwardingRule(data);
  }

  /**
   * Creates a GlobalForwardingRule resource in the specified project using the
   * data included in the request.
   *
   * @param project Project ID for this request.
   */
  async globalForwardingRulesInsert(project: string, req: ForwardingRule, opts: GlobalForwardingRulesInsertOptions = {}): Promise<Operation> {
    req = serializeForwardingRule(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/forwardingRules`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of GlobalForwardingRule resources available to the
   * specified project.
   *
   * @param project Project ID for this request.
   */
  async globalForwardingRulesList(project: string, opts: GlobalForwardingRulesListOptions = {}): Promise<ForwardingRuleList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/forwardingRules`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeForwardingRuleList(data);
  }

  /**
   * Updates the specified forwarding rule with the data included in the
   * request. This method supports PATCH semantics and uses the JSON merge patch
   * format and processing rules. Currently, you can only patch the network_tier
   * field.
   *
   * @param forwardingRule Name of the ForwardingRule resource to patch.
   * @param project Project ID for this request.
   */
  async globalForwardingRulesPatch(forwardingRule: string, project: string, req: ForwardingRule, opts: GlobalForwardingRulesPatchOptions = {}): Promise<Operation> {
    req = serializeForwardingRule(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/forwardingRules/${ forwardingRule }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the labels on the specified resource. To learn more about labels,
   * read the Labeling resources documentation.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async globalForwardingRulesSetLabels(project: string, resource: string, req: GlobalSetLabelsRequest): Promise<Operation> {
    req = serializeGlobalSetLabelsRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/forwardingRules/${ resource }/setLabels`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Changes target URL for the GlobalForwardingRule resource. The new target
   * should be of the same type as the old target.
   *
   * @param forwardingRule Name of the ForwardingRule resource in which target is to be set.
   * @param project Project ID for this request.
   */
  async globalForwardingRulesSetTarget(forwardingRule: string, project: string, req: TargetReference, opts: GlobalForwardingRulesSetTargetOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/forwardingRules/${ forwardingRule }/setTarget`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Attach a network endpoint to the specified network endpoint group.
   *
   * @param networkEndpointGroup The name of the network endpoint group where you are attaching network endpoints to. It should comply with RFC1035.
   * @param project Project ID for this request.
   */
  async globalNetworkEndpointGroupsAttachNetworkEndpoints(networkEndpointGroup: string, project: string, req: GlobalNetworkEndpointGroupsAttachEndpointsRequest, opts: GlobalNetworkEndpointGroupsAttachNetworkEndpointsOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/networkEndpointGroups/${ networkEndpointGroup }/attachNetworkEndpoints`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified network endpoint group.Note that the NEG cannot be
   * deleted if there are backend services referencing it.
   *
   * @param networkEndpointGroup The name of the network endpoint group to delete. It should comply with RFC1035.
   * @param project Project ID for this request.
   */
  async globalNetworkEndpointGroupsDelete(networkEndpointGroup: string, project: string, opts: GlobalNetworkEndpointGroupsDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/networkEndpointGroups/${ networkEndpointGroup }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Detach the network endpoint from the specified network endpoint group.
   *
   * @param networkEndpointGroup The name of the network endpoint group where you are removing network endpoints. It should comply with RFC1035.
   * @param project Project ID for this request.
   */
  async globalNetworkEndpointGroupsDetachNetworkEndpoints(networkEndpointGroup: string, project: string, req: GlobalNetworkEndpointGroupsDetachEndpointsRequest, opts: GlobalNetworkEndpointGroupsDetachNetworkEndpointsOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/networkEndpointGroups/${ networkEndpointGroup }/detachNetworkEndpoints`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified network endpoint group.
   *
   * @param networkEndpointGroup The name of the network endpoint group. It should comply with RFC1035.
   * @param project Project ID for this request.
   */
  async globalNetworkEndpointGroupsGet(networkEndpointGroup: string, project: string): Promise<NetworkEndpointGroup> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/networkEndpointGroups/${ networkEndpointGroup }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNetworkEndpointGroup(data);
  }

  /**
   * Creates a network endpoint group in the specified project using the
   * parameters that are included in the request.
   *
   * @param project Project ID for this request.
   */
  async globalNetworkEndpointGroupsInsert(project: string, req: NetworkEndpointGroup, opts: GlobalNetworkEndpointGroupsInsertOptions = {}): Promise<Operation> {
    req = serializeNetworkEndpointGroup(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/networkEndpointGroups`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of network endpoint groups that are located in the
   * specified project.
   *
   * @param project Project ID for this request.
   */
  async globalNetworkEndpointGroupsList(project: string, opts: GlobalNetworkEndpointGroupsListOptions = {}): Promise<NetworkEndpointGroupList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/networkEndpointGroups`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNetworkEndpointGroupList(data);
  }

  /**
   * Lists the network endpoints in the specified network endpoint group.
   *
   * @param networkEndpointGroup The name of the network endpoint group from which you want to generate a list of included network endpoints. It should comply with RFC1035.
   * @param project Project ID for this request.
   */
  async globalNetworkEndpointGroupsListNetworkEndpoints(networkEndpointGroup: string, project: string, opts: GlobalNetworkEndpointGroupsListNetworkEndpointsOptions = {}): Promise<NetworkEndpointGroupsListNetworkEndpoints> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/networkEndpointGroups/${ networkEndpointGroup }/listNetworkEndpoints`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return data as NetworkEndpointGroupsListNetworkEndpoints;
  }

  /**
   * Retrieves an aggregated list of all operations.
   *
   * @param project Project ID for this request.
   */
  async globalOperationsAggregatedList(project: string, opts: GlobalOperationsAggregatedListOptions = {}): Promise<OperationAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/operations`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeOperationAggregatedList(data);
  }

  /**
   * Deletes the specified Operations resource.
   *
   * @param operation Name of the Operations resource to delete.
   * @param project Project ID for this request.
   */
  async globalOperationsDelete(operation: string, project: string): Promise<void> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/operations/${ operation }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
  }

  /**
   * Retrieves the specified Operations resource.
   *
   * @param operation Name of the Operations resource to return.
   * @param project Project ID for this request.
   */
  async globalOperationsGet(operation: string, project: string): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/operations/${ operation }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of Operation resources contained within the specified
   * project.
   *
   * @param project Project ID for this request.
   */
  async globalOperationsList(project: string, opts: GlobalOperationsListOptions = {}): Promise<OperationList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/operations`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeOperationList(data);
  }

  /**
   * Waits for the specified Operation resource to return as `DONE` or for the
   * request to approach the 2 minute deadline, and retrieves the specified
   * Operation resource. This method differs from the `GET` method in that it
   * waits for no more than the default deadline (2 minutes) and then returns
   * the current state of the operation, which might be `DONE` or still in
   * progress. This method is called on a best-effort basis. Specifically: - In
   * uncommon cases, when the server is overloaded, the request might return
   * before the default deadline is reached, or might return after zero seconds.
   * - If the default deadline is reached, there is no guarantee that the
   * operation is actually done when the method returns. Be prepared to retry if
   * the operation is not `DONE`.
   *
   * @param operation Name of the Operations resource to return.
   * @param project Project ID for this request.
   */
  async globalOperationsWait(operation: string, project: string): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/operations/${ operation }/wait`);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified Operations resource.
   *
   * @param operation Name of the Operations resource to delete.
   */
  async globalOrganizationOperationsDelete(operation: string, opts: GlobalOrganizationOperationsDeleteOptions = {}): Promise<void> {
    const url = new URL(`${this.#baseUrl}locations/global/operations/${ operation }`);
    if (opts.parentId !== undefined) {
      url.searchParams.append("parentId", String(opts.parentId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
  }

  /**
   * Retrieves the specified Operations resource. Gets a list of operations by
   * making a `list()` request.
   *
   * @param operation Name of the Operations resource to return.
   */
  async globalOrganizationOperationsGet(operation: string, opts: GlobalOrganizationOperationsGetOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}locations/global/operations/${ operation }`);
    if (opts.parentId !== undefined) {
      url.searchParams.append("parentId", String(opts.parentId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of Operation resources contained within the specified
   * organization.
   *
   */
  async globalOrganizationOperationsList(opts: GlobalOrganizationOperationsListOptions = {}): Promise<OperationList> {
    const url = new URL(`${this.#baseUrl}locations/global/operations`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.parentId !== undefined) {
      url.searchParams.append("parentId", String(opts.parentId));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeOperationList(data);
  }

  /**
   * Deletes the specified global PublicDelegatedPrefix.
   *
   * @param project Project ID for this request.
   * @param publicDelegatedPrefix Name of the PublicDelegatedPrefix resource to delete.
   */
  async globalPublicDelegatedPrefixesDelete(project: string, publicDelegatedPrefix: string, opts: GlobalPublicDelegatedPrefixesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/publicDelegatedPrefixes/${ publicDelegatedPrefix }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified global PublicDelegatedPrefix resource.
   *
   * @param project Project ID for this request.
   * @param publicDelegatedPrefix Name of the PublicDelegatedPrefix resource to return.
   */
  async globalPublicDelegatedPrefixesGet(project: string, publicDelegatedPrefix: string): Promise<PublicDelegatedPrefix> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/publicDelegatedPrefixes/${ publicDelegatedPrefix }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePublicDelegatedPrefix(data);
  }

  /**
   * Creates a global PublicDelegatedPrefix in the specified project using the
   * parameters that are included in the request.
   *
   * @param project Project ID for this request.
   */
  async globalPublicDelegatedPrefixesInsert(project: string, req: PublicDelegatedPrefix, opts: GlobalPublicDelegatedPrefixesInsertOptions = {}): Promise<Operation> {
    req = serializePublicDelegatedPrefix(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/publicDelegatedPrefixes`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Lists the global PublicDelegatedPrefixes for a project.
   *
   * @param project Project ID for this request.
   */
  async globalPublicDelegatedPrefixesList(project: string, opts: GlobalPublicDelegatedPrefixesListOptions = {}): Promise<PublicDelegatedPrefixList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/publicDelegatedPrefixes`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePublicDelegatedPrefixList(data);
  }

  /**
   * Patches the specified global PublicDelegatedPrefix resource with the data
   * included in the request. This method supports PATCH semantics and uses JSON
   * merge patch format and processing rules.
   *
   * @param project Project ID for this request.
   * @param publicDelegatedPrefix Name of the PublicDelegatedPrefix resource to patch.
   */
  async globalPublicDelegatedPrefixesPatch(project: string, publicDelegatedPrefix: string, req: PublicDelegatedPrefix, opts: GlobalPublicDelegatedPrefixesPatchOptions = {}): Promise<Operation> {
    req = serializePublicDelegatedPrefix(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/publicDelegatedPrefixes/${ publicDelegatedPrefix }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of all HealthCheck resources, regional and global,
   * available to the specified project.
   *
   * @param project Name of the project scoping this request.
   */
  async healthChecksAggregatedList(project: string, opts: HealthChecksAggregatedListOptions = {}): Promise<HealthChecksAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/healthChecks`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeHealthChecksAggregatedList(data);
  }

  /**
   * Deletes the specified HealthCheck resource.
   *
   * @param healthCheck Name of the HealthCheck resource to delete.
   * @param project Project ID for this request.
   */
  async healthChecksDelete(healthCheck: string, project: string, opts: HealthChecksDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/healthChecks/${ healthCheck }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified HealthCheck resource.
   *
   * @param healthCheck Name of the HealthCheck resource to return.
   * @param project Project ID for this request.
   */
  async healthChecksGet(healthCheck: string, project: string): Promise<HealthCheck> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/healthChecks/${ healthCheck }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeHealthCheck(data);
  }

  /**
   * Creates a HealthCheck resource in the specified project using the data
   * included in the request.
   *
   * @param project Project ID for this request.
   */
  async healthChecksInsert(project: string, req: HealthCheck, opts: HealthChecksInsertOptions = {}): Promise<Operation> {
    req = serializeHealthCheck(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/healthChecks`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of HealthCheck resources available to the specified
   * project.
   *
   * @param project Project ID for this request.
   */
  async healthChecksList(project: string, opts: HealthChecksListOptions = {}): Promise<HealthCheckList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/healthChecks`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeHealthCheckList(data);
  }

  /**
   * Updates a HealthCheck resource in the specified project using the data
   * included in the request. This method supports PATCH semantics and uses the
   * JSON merge patch format and processing rules.
   *
   * @param healthCheck Name of the HealthCheck resource to patch.
   * @param project Project ID for this request.
   */
  async healthChecksPatch(healthCheck: string, project: string, req: HealthCheck, opts: HealthChecksPatchOptions = {}): Promise<Operation> {
    req = serializeHealthCheck(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/healthChecks/${ healthCheck }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Updates a HealthCheck resource in the specified project using the data
   * included in the request.
   *
   * @param healthCheck Name of the HealthCheck resource to update.
   * @param project Project ID for this request.
   */
  async healthChecksUpdate(healthCheck: string, project: string, req: HealthCheck, opts: HealthChecksUpdateOptions = {}): Promise<Operation> {
    req = serializeHealthCheck(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/healthChecks/${ healthCheck }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PUT",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified HttpHealthCheck resource.
   *
   * @param httpHealthCheck Name of the HttpHealthCheck resource to delete.
   * @param project Project ID for this request.
   */
  async httpHealthChecksDelete(httpHealthCheck: string, project: string, opts: HttpHealthChecksDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/httpHealthChecks/${ httpHealthCheck }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified HttpHealthCheck resource.
   *
   * @param httpHealthCheck Name of the HttpHealthCheck resource to return.
   * @param project Project ID for this request.
   */
  async httpHealthChecksGet(httpHealthCheck: string, project: string): Promise<HttpHealthCheck> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/httpHealthChecks/${ httpHealthCheck }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeHttpHealthCheck(data);
  }

  /**
   * Creates a HttpHealthCheck resource in the specified project using the data
   * included in the request.
   *
   * @param project Project ID for this request.
   */
  async httpHealthChecksInsert(project: string, req: HttpHealthCheck, opts: HttpHealthChecksInsertOptions = {}): Promise<Operation> {
    req = serializeHttpHealthCheck(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/httpHealthChecks`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of HttpHealthCheck resources available to the specified
   * project.
   *
   * @param project Project ID for this request.
   */
  async httpHealthChecksList(project: string, opts: HttpHealthChecksListOptions = {}): Promise<HttpHealthCheckList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/httpHealthChecks`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeHttpHealthCheckList(data);
  }

  /**
   * Updates a HttpHealthCheck resource in the specified project using the data
   * included in the request. This method supports PATCH semantics and uses the
   * JSON merge patch format and processing rules.
   *
   * @param httpHealthCheck Name of the HttpHealthCheck resource to patch.
   * @param project Project ID for this request.
   */
  async httpHealthChecksPatch(httpHealthCheck: string, project: string, req: HttpHealthCheck, opts: HttpHealthChecksPatchOptions = {}): Promise<Operation> {
    req = serializeHttpHealthCheck(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/httpHealthChecks/${ httpHealthCheck }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Updates a HttpHealthCheck resource in the specified project using the data
   * included in the request.
   *
   * @param httpHealthCheck Name of the HttpHealthCheck resource to update.
   * @param project Project ID for this request.
   */
  async httpHealthChecksUpdate(httpHealthCheck: string, project: string, req: HttpHealthCheck, opts: HttpHealthChecksUpdateOptions = {}): Promise<Operation> {
    req = serializeHttpHealthCheck(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/httpHealthChecks/${ httpHealthCheck }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PUT",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified HttpsHealthCheck resource.
   *
   * @param httpsHealthCheck Name of the HttpsHealthCheck resource to delete.
   * @param project Project ID for this request.
   */
  async httpsHealthChecksDelete(httpsHealthCheck: string, project: string, opts: HttpsHealthChecksDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/httpsHealthChecks/${ httpsHealthCheck }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified HttpsHealthCheck resource.
   *
   * @param httpsHealthCheck Name of the HttpsHealthCheck resource to return.
   * @param project Project ID for this request.
   */
  async httpsHealthChecksGet(httpsHealthCheck: string, project: string): Promise<HttpsHealthCheck> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/httpsHealthChecks/${ httpsHealthCheck }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeHttpsHealthCheck(data);
  }

  /**
   * Creates a HttpsHealthCheck resource in the specified project using the
   * data included in the request.
   *
   * @param project Project ID for this request.
   */
  async httpsHealthChecksInsert(project: string, req: HttpsHealthCheck, opts: HttpsHealthChecksInsertOptions = {}): Promise<Operation> {
    req = serializeHttpsHealthCheck(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/httpsHealthChecks`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of HttpsHealthCheck resources available to the
   * specified project.
   *
   * @param project Project ID for this request.
   */
  async httpsHealthChecksList(project: string, opts: HttpsHealthChecksListOptions = {}): Promise<HttpsHealthCheckList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/httpsHealthChecks`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeHttpsHealthCheckList(data);
  }

  /**
   * Updates a HttpsHealthCheck resource in the specified project using the
   * data included in the request. This method supports PATCH semantics and uses
   * the JSON merge patch format and processing rules.
   *
   * @param httpsHealthCheck Name of the HttpsHealthCheck resource to patch.
   * @param project Project ID for this request.
   */
  async httpsHealthChecksPatch(httpsHealthCheck: string, project: string, req: HttpsHealthCheck, opts: HttpsHealthChecksPatchOptions = {}): Promise<Operation> {
    req = serializeHttpsHealthCheck(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/httpsHealthChecks/${ httpsHealthCheck }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Updates a HttpsHealthCheck resource in the specified project using the
   * data included in the request.
   *
   * @param httpsHealthCheck Name of the HttpsHealthCheck resource to update.
   * @param project Project ID for this request.
   */
  async httpsHealthChecksUpdate(httpsHealthCheck: string, project: string, req: HttpsHealthCheck, opts: HttpsHealthChecksUpdateOptions = {}): Promise<Operation> {
    req = serializeHttpsHealthCheck(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/httpsHealthChecks/${ httpsHealthCheck }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PUT",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the latest image that is part of an image family, is not
   * deprecated and is rolled out in the specified zone.
   *
   * @param family Name of the image family to search for.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async imageFamilyViewsGet(family: string, project: string, zone: string): Promise<ImageFamilyView> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/imageFamilyViews/${ family }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeImageFamilyView(data);
  }

  /**
   * Deletes the specified image.
   *
   * @param image Name of the image resource to delete.
   * @param project Project ID for this request.
   */
  async imagesDelete(image: string, project: string, opts: ImagesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/images/${ image }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the deprecation status of an image. If an empty request body is
   * given, clears the deprecation status instead.
   *
   * @param image Image name.
   * @param project Project ID for this request.
   */
  async imagesDeprecate(image: string, project: string, req: DeprecationStatus, opts: ImagesDeprecateOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/images/${ image }/deprecate`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified image.
   *
   * @param image Name of the image resource to return.
   * @param project Project ID for this request.
   */
  async imagesGet(image: string, project: string): Promise<Image> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/images/${ image }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeImage(data);
  }

  /**
   * Returns the latest image that is part of an image family and is not
   * deprecated. For more information on image families, see Public image
   * families documentation.
   *
   * @param family Name of the image family to search for.
   * @param project The image project that the image belongs to. For example, to get a CentOS image, specify centos-cloud as the image project.
   */
  async imagesGetFromFamily(family: string, project: string): Promise<Image> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/images/family/${ family }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeImage(data);
  }

  /**
   * Gets the access control policy for a resource. May be empty if no such
   * policy or resource exists.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async imagesGetIamPolicy(project: string, resource: string, opts: ImagesGetIamPolicyOptions = {}): Promise<Policy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/images/${ resource }/getIamPolicy`);
    if (opts.optionsRequestedPolicyVersion !== undefined) {
      url.searchParams.append("optionsRequestedPolicyVersion", String(opts.optionsRequestedPolicyVersion));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePolicy(data);
  }

  /**
   * Creates an image in the specified project using the data included in the
   * request.
   *
   * @param project Project ID for this request.
   */
  async imagesInsert(project: string, req: Image, opts: ImagesInsertOptions = {}): Promise<Operation> {
    req = serializeImage(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/images`);
    if (opts.forceCreate !== undefined) {
      url.searchParams.append("forceCreate", String(opts.forceCreate));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of custom images available to the specified project.
   * Custom images are images you create that belong to your project. This
   * method does not get any images that belong to other projects, including
   * publicly-available images, like Debian 8. If you want to get a list of
   * publicly-available images, use this method to make a request to the
   * respective image project, such as debian-cloud or windows-cloud.
   *
   * @param project Project ID for this request.
   */
  async imagesList(project: string, opts: ImagesListOptions = {}): Promise<ImageList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/images`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeImageList(data);
  }

  /**
   * Patches the specified image with the data included in the request. Only
   * the following fields can be modified: family, description, deprecation
   * status.
   *
   * @param image Name of the image resource to patch.
   * @param project Project ID for this request.
   */
  async imagesPatch(image: string, project: string, req: Image, opts: ImagesPatchOptions = {}): Promise<Operation> {
    req = serializeImage(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/images/${ image }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async imagesSetIamPolicy(project: string, resource: string, req: GlobalSetPolicyRequest): Promise<Policy> {
    req = serializeGlobalSetPolicyRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/images/${ resource }/setIamPolicy`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializePolicy(data);
  }

  /**
   * Sets the labels on an image. To learn more about labels, read the Labeling
   * Resources documentation.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async imagesSetLabels(project: string, resource: string, req: GlobalSetLabelsRequest): Promise<Operation> {
    req = serializeGlobalSetLabelsRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/images/${ resource }/setLabels`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Returns permissions that a caller has on the specified resource.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async imagesTestIamPermissions(project: string, resource: string, req: TestPermissionsRequest): Promise<TestPermissionsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/images/${ resource }/testIamPermissions`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as TestPermissionsResponse;
  }

  /**
   * Flags the specified instances to be removed from the managed instance
   * group. Abandoning an instance does not delete the instance, but it does
   * remove the instance from any target pools that are applied by the managed
   * instance group. This method reduces the targetSize of the managed instance
   * group by the number of instances that you abandon. This operation is marked
   * as DONE when the action is scheduled even if the instances have not yet
   * been removed from the group. You must separately verify the status of the
   * abandoning action with the listmanagedinstances method. If the group is
   * part of a backend service that has enabled connection draining, it can take
   * up to 60 seconds after the connection draining duration has elapsed before
   * the VM instance is removed or deleted. You can specify a maximum of 1000
   * instances with this method per request.
   *
   * @param instanceGroupManager The name of the managed instance group.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the managed instance group is located.
   */
  async instanceGroupManagersAbandonInstances(instanceGroupManager: string, project: string, zone: string, req: InstanceGroupManagersAbandonInstancesRequest, opts: InstanceGroupManagersAbandonInstancesOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroupManagers/${ instanceGroupManager }/abandonInstances`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of managed instance groups and groups them by zone.
   *
   * @param project Project ID for this request.
   */
  async instanceGroupManagersAggregatedList(project: string, opts: InstanceGroupManagersAggregatedListOptions = {}): Promise<InstanceGroupManagerAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/instanceGroupManagers`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeInstanceGroupManagerAggregatedList(data);
  }

  /**
   * Applies changes to selected instances on the managed instance group. This
   * method can be used to apply new overrides and/or new versions.
   *
   * @param instanceGroupManager The name of the managed instance group, should conform to RFC1035.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the managed instance group is located. Should conform to RFC1035.
   */
  async instanceGroupManagersApplyUpdatesToInstances(instanceGroupManager: string, project: string, zone: string, req: InstanceGroupManagersApplyUpdatesRequest): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroupManagers/${ instanceGroupManager }/applyUpdatesToInstances`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Creates instances with per-instance configurations in this managed
   * instance group. Instances are created using the current instance template.
   * The create instances operation is marked DONE if the createInstances
   * request is successful. The underlying actions take additional time. You
   * must separately verify the status of the creating or actions with the
   * listmanagedinstances method.
   *
   * @param instanceGroupManager The name of the managed instance group. It should conform to RFC1035.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the managed instance group is located. It should conform to RFC1035.
   */
  async instanceGroupManagersCreateInstances(instanceGroupManager: string, project: string, zone: string, req: InstanceGroupManagersCreateInstancesRequest, opts: InstanceGroupManagersCreateInstancesOptions = {}): Promise<Operation> {
    req = serializeInstanceGroupManagersCreateInstancesRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroupManagers/${ instanceGroupManager }/createInstances`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified managed instance group and all of the instances in
   * that group. Note that the instance group must not belong to a backend
   * service. Read Deleting an instance group for more information.
   *
   * @param instanceGroupManager The name of the managed instance group to delete.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the managed instance group is located.
   */
  async instanceGroupManagersDelete(instanceGroupManager: string, project: string, zone: string, opts: InstanceGroupManagersDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroupManagers/${ instanceGroupManager }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Flags the specified instances in the managed instance group for immediate
   * deletion. The instances are also removed from any target pools of which
   * they were a member. This method reduces the targetSize of the managed
   * instance group by the number of instances that you delete. This operation
   * is marked as DONE when the action is scheduled even if the instances are
   * still being deleted. You must separately verify the status of the deleting
   * action with the listmanagedinstances method. If the group is part of a
   * backend service that has enabled connection draining, it can take up to 60
   * seconds after the connection draining duration has elapsed before the VM
   * instance is removed or deleted. You can specify a maximum of 1000 instances
   * with this method per request.
   *
   * @param instanceGroupManager The name of the managed instance group.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the managed instance group is located.
   */
  async instanceGroupManagersDeleteInstances(instanceGroupManager: string, project: string, zone: string, req: InstanceGroupManagersDeleteInstancesRequest, opts: InstanceGroupManagersDeleteInstancesOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroupManagers/${ instanceGroupManager }/deleteInstances`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes selected per-instance configurations for the managed instance
   * group.
   *
   * @param instanceGroupManager The name of the managed instance group. It should conform to RFC1035.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the managed instance group is located. It should conform to RFC1035.
   */
  async instanceGroupManagersDeletePerInstanceConfigs(instanceGroupManager: string, project: string, zone: string, req: InstanceGroupManagersDeletePerInstanceConfigsReq): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroupManagers/${ instanceGroupManager }/deletePerInstanceConfigs`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Returns all of the details about the specified managed instance group.
   *
   * @param instanceGroupManager The name of the managed instance group.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the managed instance group is located.
   */
  async instanceGroupManagersGet(instanceGroupManager: string, project: string, zone: string): Promise<InstanceGroupManager> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroupManagers/${ instanceGroupManager }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeInstanceGroupManager(data);
  }

  /**
   * Creates a managed instance group using the information that you specify in
   * the request. After the group is created, instances in the group are created
   * using the specified instance template. This operation is marked as DONE
   * when the group is created even if the instances in the group have not yet
   * been created. You must separately verify the status of the individual
   * instances with the listmanagedinstances method. A managed instance group
   * can have up to 1000 VM instances per group. Please contact Cloud Support if
   * you need an increase in this limit.
   *
   * @param project Project ID for this request.
   * @param zone The name of the zone where you want to create the managed instance group.
   */
  async instanceGroupManagersInsert(project: string, zone: string, req: InstanceGroupManager, opts: InstanceGroupManagersInsertOptions = {}): Promise<Operation> {
    req = serializeInstanceGroupManager(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroupManagers`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of managed instance groups that are contained within the
   * specified project and zone.
   *
   * @param project Project ID for this request.
   * @param zone The name of the zone where the managed instance group is located.
   */
  async instanceGroupManagersList(project: string, zone: string, opts: InstanceGroupManagersListOptions = {}): Promise<InstanceGroupManagerList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroupManagers`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeInstanceGroupManagerList(data);
  }

  /**
   * Lists all errors thrown by actions on instances for a given managed
   * instance group. The filter and orderBy query parameters are not supported.
   *
   * @param instanceGroupManager The name of the managed instance group. It must be a string that meets the requirements in RFC1035, or an unsigned long integer: must match regexp pattern: (?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?)|1-9{0,19}.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the managed instance group is located. It should conform to RFC1035.
   */
  async instanceGroupManagersListErrors(instanceGroupManager: string, project: string, zone: string, opts: InstanceGroupManagersListErrorsOptions = {}): Promise<InstanceGroupManagersListErrorsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroupManagers/${ instanceGroupManager }/listErrors`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return data as InstanceGroupManagersListErrorsResponse;
  }

  /**
   * Lists all of the instances in the managed instance group. Each instance in
   * the list has a currentAction, which indicates the action that the managed
   * instance group is performing on the instance. For example, if the group is
   * still creating an instance, the currentAction is CREATING. If a previous
   * action failed, the list displays the errors for that failed action. The
   * orderBy query parameter is not supported. The `pageToken` query parameter
   * is supported only in the alpha and beta API and only if the group's
   * `listManagedInstancesResults` field is set to `PAGINATED`.
   *
   * @param instanceGroupManager The name of the managed instance group.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the managed instance group is located.
   */
  async instanceGroupManagersListManagedInstances(instanceGroupManager: string, project: string, zone: string, opts: InstanceGroupManagersListManagedInstancesOptions = {}): Promise<InstanceGroupManagersListManagedInstancesResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroupManagers/${ instanceGroupManager }/listManagedInstances`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeInstanceGroupManagersListManagedInstancesResponse(data);
  }

  /**
   * Lists all of the per-instance configurations defined for the managed
   * instance group. The orderBy query parameter is not supported.
   *
   * @param instanceGroupManager The name of the managed instance group. It should conform to RFC1035.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the managed instance group is located. It should conform to RFC1035.
   */
  async instanceGroupManagersListPerInstanceConfigs(instanceGroupManager: string, project: string, zone: string, opts: InstanceGroupManagersListPerInstanceConfigsOptions = {}): Promise<InstanceGroupManagersListPerInstanceConfigsResp> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroupManagers/${ instanceGroupManager }/listPerInstanceConfigs`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeInstanceGroupManagersListPerInstanceConfigsResp(data);
  }

  /**
   * Updates a managed instance group using the information that you specify in
   * the request. This operation is marked as DONE when the group is patched
   * even if the instances in the group are still in the process of being
   * patched. You must separately verify the status of the individual instances
   * with the listManagedInstances method. This method supports PATCH semantics
   * and uses the JSON merge patch format and processing rules. If you update
   * your group to specify a new template or instance configuration, it's
   * possible that your intended specification for each VM in the group is
   * different from the current state of that VM. To learn how to apply an
   * updated configuration to the VMs in a MIG, see Updating instances in a MIG.
   *
   * @param instanceGroupManager The name of the instance group manager.
   * @param project Project ID for this request.
   * @param zone The name of the zone where you want to create the managed instance group.
   */
  async instanceGroupManagersPatch(instanceGroupManager: string, project: string, zone: string, req: InstanceGroupManager, opts: InstanceGroupManagersPatchOptions = {}): Promise<Operation> {
    req = serializeInstanceGroupManager(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroupManagers/${ instanceGroupManager }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Inserts or patches per-instance configurations for the managed instance
   * group. perInstanceConfig.name serves as a key used to distinguish whether
   * to perform insert or patch.
   *
   * @param instanceGroupManager The name of the managed instance group. It should conform to RFC1035.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the managed instance group is located. It should conform to RFC1035.
   */
  async instanceGroupManagersPatchPerInstanceConfigs(instanceGroupManager: string, project: string, zone: string, req: InstanceGroupManagersPatchPerInstanceConfigsReq, opts: InstanceGroupManagersPatchPerInstanceConfigsOptions = {}): Promise<Operation> {
    req = serializeInstanceGroupManagersPatchPerInstanceConfigsReq(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroupManagers/${ instanceGroupManager }/patchPerInstanceConfigs`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Flags the specified VM instances in the managed instance group to be
   * immediately recreated. Each instance is recreated using the group's current
   * configuration. This operation is marked as DONE when the flag is set even
   * if the instances have not yet been recreated. You must separately verify
   * the status of each instance by checking its currentAction field; for more
   * information, see Checking the status of managed instances. If the group is
   * part of a backend service that has enabled connection draining, it can take
   * up to 60 seconds after the connection draining duration has elapsed before
   * the VM instance is removed or deleted. You can specify a maximum of 1000
   * instances with this method per request.
   *
   * @param instanceGroupManager The name of the managed instance group.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the managed instance group is located.
   */
  async instanceGroupManagersRecreateInstances(instanceGroupManager: string, project: string, zone: string, req: InstanceGroupManagersRecreateInstancesRequest, opts: InstanceGroupManagersRecreateInstancesOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroupManagers/${ instanceGroupManager }/recreateInstances`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Resizes the managed instance group. If you increase the size, the group
   * creates new instances using the current instance template. If you decrease
   * the size, the group deletes instances. The resize operation is marked DONE
   * when the resize actions are scheduled even if the group has not yet added
   * or deleted any instances. You must separately verify the status of the
   * creating or deleting actions with the listmanagedinstances method. When
   * resizing down, the instance group arbitrarily chooses the order in which
   * VMs are deleted. The group takes into account some VM attributes when
   * making the selection including: + The status of the VM instance. + The
   * health of the VM instance. + The instance template version the VM is based
   * on. + For regional managed instance groups, the location of the VM
   * instance. This list is subject to change. If the group is part of a backend
   * service that has enabled connection draining, it can take up to 60 seconds
   * after the connection draining duration has elapsed before the VM instance
   * is removed or deleted.
   *
   * @param instanceGroupManager The name of the managed instance group.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the managed instance group is located.
   */
  async instanceGroupManagersResize(instanceGroupManager: string, project: string, zone: string, opts: InstanceGroupManagersResizeOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroupManagers/${ instanceGroupManager }/resize`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    if (opts.size !== undefined) {
      url.searchParams.append("size", String(opts.size));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Specifies the instance template to use when creating new instances in this
   * group. The templates for existing instances in the group do not change
   * unless you run recreateInstances, run applyUpdatesToInstances, or set the
   * group's updatePolicy.type to PROACTIVE.
   *
   * @param instanceGroupManager The name of the managed instance group.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the managed instance group is located.
   */
  async instanceGroupManagersSetInstanceTemplate(instanceGroupManager: string, project: string, zone: string, req: InstanceGroupManagersSetInstanceTemplateRequest, opts: InstanceGroupManagersSetInstanceTemplateOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroupManagers/${ instanceGroupManager }/setInstanceTemplate`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Modifies the target pools to which all instances in this managed instance
   * group are assigned. The target pools automatically apply to all of the
   * instances in the managed instance group. This operation is marked DONE when
   * you make the request even if the instances have not yet been added to their
   * target pools. The change might take some time to apply to all of the
   * instances in the group depending on the size of the group.
   *
   * @param instanceGroupManager The name of the managed instance group.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the managed instance group is located.
   */
  async instanceGroupManagersSetTargetPools(instanceGroupManager: string, project: string, zone: string, req: InstanceGroupManagersSetTargetPoolsRequest, opts: InstanceGroupManagersSetTargetPoolsOptions = {}): Promise<Operation> {
    req = serializeInstanceGroupManagersSetTargetPoolsRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroupManagers/${ instanceGroupManager }/setTargetPools`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Inserts or updates per-instance configurations for the managed instance
   * group. perInstanceConfig.name serves as a key used to distinguish whether
   * to perform insert or patch.
   *
   * @param instanceGroupManager The name of the managed instance group. It should conform to RFC1035.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the managed instance group is located. It should conform to RFC1035.
   */
  async instanceGroupManagersUpdatePerInstanceConfigs(instanceGroupManager: string, project: string, zone: string, req: InstanceGroupManagersUpdatePerInstanceConfigsReq, opts: InstanceGroupManagersUpdatePerInstanceConfigsOptions = {}): Promise<Operation> {
    req = serializeInstanceGroupManagersUpdatePerInstanceConfigsReq(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroupManagers/${ instanceGroupManager }/updatePerInstanceConfigs`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Adds a list of instances to the specified instance group. All of the
   * instances in the instance group must be in the same network/subnetwork.
   * Read Adding instances for more information.
   *
   * @param instanceGroup The name of the instance group where you are adding instances.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the instance group is located.
   */
  async instanceGroupsAddInstances(instanceGroup: string, project: string, zone: string, req: InstanceGroupsAddInstancesRequest, opts: InstanceGroupsAddInstancesOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroups/${ instanceGroup }/addInstances`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of instance groups and sorts them by zone.
   *
   * @param project Project ID for this request.
   */
  async instanceGroupsAggregatedList(project: string, opts: InstanceGroupsAggregatedListOptions = {}): Promise<InstanceGroupAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/instanceGroups`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeInstanceGroupAggregatedList(data);
  }

  /**
   * Deletes the specified instance group. The instances in the group are not
   * deleted. Note that instance group must not belong to a backend service.
   * Read Deleting an instance group for more information.
   *
   * @param instanceGroup The name of the instance group to delete.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the instance group is located.
   */
  async instanceGroupsDelete(instanceGroup: string, project: string, zone: string, opts: InstanceGroupsDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroups/${ instanceGroup }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified zonal instance group. Get a list of available zonal
   * instance groups by making a list() request. For managed instance groups,
   * use the instanceGroupManagers or regionInstanceGroupManagers methods
   * instead.
   *
   * @param instanceGroup The name of the instance group.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the instance group is located.
   */
  async instanceGroupsGet(instanceGroup: string, project: string, zone: string): Promise<InstanceGroup> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroups/${ instanceGroup }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeInstanceGroup(data);
  }

  /**
   * Creates an instance group in the specified project using the parameters
   * that are included in the request.
   *
   * @param project Project ID for this request.
   * @param zone The name of the zone where you want to create the instance group.
   */
  async instanceGroupsInsert(project: string, zone: string, req: InstanceGroup, opts: InstanceGroupsInsertOptions = {}): Promise<Operation> {
    req = serializeInstanceGroup(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroups`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of zonal instance group resources contained within the
   * specified zone. For managed instance groups, use the instanceGroupManagers
   * or regionInstanceGroupManagers methods instead.
   *
   * @param project Project ID for this request.
   * @param zone The name of the zone where the instance group is located.
   */
  async instanceGroupsList(project: string, zone: string, opts: InstanceGroupsListOptions = {}): Promise<InstanceGroupList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroups`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeInstanceGroupList(data);
  }

  /**
   * Lists the instances in the specified instance group. The orderBy query
   * parameter is not supported. The filter query parameter is supported, but
   * only for expressions that use `eq` (equal) or `ne` (not equal) operators.
   *
   * @param instanceGroup The name of the instance group from which you want to generate a list of included instances.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the instance group is located.
   */
  async instanceGroupsListInstances(instanceGroup: string, project: string, zone: string, req: InstanceGroupsListInstancesRequest, opts: InstanceGroupsListInstancesOptions = {}): Promise<InstanceGroupsListInstances> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroups/${ instanceGroup }/listInstances`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as InstanceGroupsListInstances;
  }

  /**
   * Removes one or more instances from the specified instance group, but does
   * not delete those instances. If the group is part of a backend service that
   * has enabled connection draining, it can take up to 60 seconds after the
   * connection draining duration before the VM instance is removed or deleted.
   *
   * @param instanceGroup The name of the instance group where the specified instances will be removed.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the instance group is located.
   */
  async instanceGroupsRemoveInstances(instanceGroup: string, project: string, zone: string, req: InstanceGroupsRemoveInstancesRequest, opts: InstanceGroupsRemoveInstancesOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroups/${ instanceGroup }/removeInstances`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the named ports for the specified instance group.
   *
   * @param instanceGroup The name of the instance group where the named ports are updated.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the instance group is located.
   */
  async instanceGroupsSetNamedPorts(instanceGroup: string, project: string, zone: string, req: InstanceGroupsSetNamedPortsRequest, opts: InstanceGroupsSetNamedPortsOptions = {}): Promise<Operation> {
    req = serializeInstanceGroupsSetNamedPortsRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instanceGroups/${ instanceGroup }/setNamedPorts`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Adds an access config to an instance's network interface.
   *
   * @param instance The instance name for this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesAddAccessConfig(instance: string, project: string, zone: string, req: AccessConfig, opts: InstancesAddAccessConfigOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/addAccessConfig`);
    if (opts.networkInterface !== undefined) {
      url.searchParams.append("networkInterface", String(opts.networkInterface));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Adds existing resource policies to an instance. You can only add one
   * policy right now which will be applied to this instance for scheduling live
   * migrations.
   *
   * @param instance The instance name for this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesAddResourcePolicies(instance: string, project: string, zone: string, req: InstancesAddResourcePoliciesRequest, opts: InstancesAddResourcePoliciesOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/addResourcePolicies`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves an aggregated list of all of the instances in your project
   * across all regions and zones. The performance of this method degrades when
   * a filter is specified on a project that has a very large number of
   * instances.
   *
   * @param project Project ID for this request.
   */
  async instancesAggregatedList(project: string, opts: InstancesAggregatedListOptions = {}): Promise<InstanceAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/instances`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeInstanceAggregatedList(data);
  }

  /**
   * Attaches an existing Disk resource to an instance. You must first create
   * the disk before you can attach it. It is not possible to create and attach
   * a disk at the same time. For more information, read Adding a persistent
   * disk to your instance.
   *
   * @param instance The instance name for this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesAttachDisk(instance: string, project: string, zone: string, req: AttachedDisk, opts: InstancesAttachDiskOptions = {}): Promise<Operation> {
    req = serializeAttachedDisk(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/attachDisk`);
    if (opts.forceAttach !== undefined) {
      url.searchParams.append("forceAttach", String(opts.forceAttach));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Creates multiple instances. Count specifies the number of instances to
   * create. For more information, see About bulk creation of VMs.
   *
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesBulkInsert(project: string, zone: string, req: BulkInsertInstanceResource, opts: InstancesBulkInsertOptions = {}): Promise<Operation> {
    req = serializeBulkInsertInstanceResource(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/bulkInsert`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified Instance resource. For more information, see
   * Deleting an instance.
   *
   * @param instance Name of the instance resource to delete.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesDelete(instance: string, project: string, zone: string, opts: InstancesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes an access config from an instance's network interface.
   *
   * @param instance The instance name for this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesDeleteAccessConfig(instance: string, project: string, zone: string, opts: InstancesDeleteAccessConfigOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/deleteAccessConfig`);
    if (opts.accessConfig !== undefined) {
      url.searchParams.append("accessConfig", String(opts.accessConfig));
    }
    if (opts.networkInterface !== undefined) {
      url.searchParams.append("networkInterface", String(opts.networkInterface));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Detaches a disk from an instance.
   *
   * @param instance Instance name for this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesDetachDisk(instance: string, project: string, zone: string, opts: InstancesDetachDiskOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/detachDisk`);
    if (opts.deviceName !== undefined) {
      url.searchParams.append("deviceName", String(opts.deviceName));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified Instance resource.
   *
   * @param instance Name of the instance resource to return.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesGet(instance: string, project: string, zone: string): Promise<Instance> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeInstance(data);
  }

  /**
   * Returns effective firewalls applied to an interface of the instance.
   *
   * @param instance Name of the instance scoping this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesGetEffectiveFirewalls(instance: string, project: string, zone: string, opts: InstancesGetEffectiveFirewallsOptions = {}): Promise<InstancesGetEffectiveFirewallsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/getEffectiveFirewalls`);
    if (opts.networkInterface !== undefined) {
      url.searchParams.append("networkInterface", String(opts.networkInterface));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeInstancesGetEffectiveFirewallsResponse(data);
  }

  /**
   * Returns the specified guest attributes entry.
   *
   * @param instance Name of the instance scoping this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesGetGuestAttributes(instance: string, project: string, zone: string, opts: InstancesGetGuestAttributesOptions = {}): Promise<GuestAttributes> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/getGuestAttributes`);
    if (opts.queryPath !== undefined) {
      url.searchParams.append("queryPath", String(opts.queryPath));
    }
    if (opts.variableKey !== undefined) {
      url.searchParams.append("variableKey", String(opts.variableKey));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return data as GuestAttributes;
  }

  /**
   * Gets the access control policy for a resource. May be empty if no such
   * policy or resource exists.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesGetIamPolicy(project: string, resource: string, zone: string, opts: InstancesGetIamPolicyOptions = {}): Promise<Policy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ resource }/getIamPolicy`);
    if (opts.optionsRequestedPolicyVersion !== undefined) {
      url.searchParams.append("optionsRequestedPolicyVersion", String(opts.optionsRequestedPolicyVersion));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePolicy(data);
  }

  /**
   * Returns the screenshot from the specified instance.
   *
   * @param instance Name of the instance scoping this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesGetScreenshot(instance: string, project: string, zone: string): Promise<Screenshot> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/screenshot`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return data as Screenshot;
  }

  /**
   * Returns the last 1 MB of serial port output from the specified instance.
   *
   * @param instance Name of the instance for this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesGetSerialPortOutput(instance: string, project: string, zone: string, opts: InstancesGetSerialPortOutputOptions = {}): Promise<SerialPortOutput> {
    opts = serializeInstancesGetSerialPortOutputOptions(opts);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/serialPort`);
    if (opts.port !== undefined) {
      url.searchParams.append("port", String(opts.port));
    }
    if (opts.start !== undefined) {
      url.searchParams.append("start", String(opts.start));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeSerialPortOutput(data);
  }

  /**
   * Returns the Shielded Instance Identity of an instance
   *
   * @param instance Name or id of the instance scoping this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesGetShieldedInstanceIdentity(instance: string, project: string, zone: string): Promise<ShieldedInstanceIdentity> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/getShieldedInstanceIdentity`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return data as ShieldedInstanceIdentity;
  }

  /**
   * Creates an instance resource in the specified project using the data
   * included in the request.
   *
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesInsert(project: string, zone: string, req: Instance, opts: InstancesInsertOptions = {}): Promise<Operation> {
    req = serializeInstance(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    if (opts.sourceInstanceTemplate !== undefined) {
      url.searchParams.append("sourceInstanceTemplate", String(opts.sourceInstanceTemplate));
    }
    if (opts.sourceMachineImage !== undefined) {
      url.searchParams.append("sourceMachineImage", String(opts.sourceMachineImage));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of instances contained within the specified zone.
   *
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesList(project: string, zone: string, opts: InstancesListOptions = {}): Promise<InstanceList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeInstanceList(data);
  }

  /**
   * Retrieves a list of resources that refer to the VM instance specified in
   * the request. For example, if the VM instance is part of a managed or
   * unmanaged instance group, the referrers list includes the instance group.
   * For more information, read Viewing referrers to VM instances.
   *
   * @param instance Name of the target instance scoping this request, or '-' if the request should span over all instances in the container.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesListReferrers(instance: string, project: string, zone: string, opts: InstancesListReferrersOptions = {}): Promise<InstanceListReferrers> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/referrers`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return data as InstanceListReferrers;
  }

  /**
   * Removes resource policies from an instance.
   *
   * @param instance The instance name for this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesRemoveResourcePolicies(instance: string, project: string, zone: string, req: InstancesRemoveResourcePoliciesRequest, opts: InstancesRemoveResourcePoliciesOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/removeResourcePolicies`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Performs a reset on the instance. This is a hard reset. The VM does not do
   * a graceful shutdown. For more information, see Resetting an instance.
   *
   * @param instance Name of the instance scoping this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesReset(instance: string, project: string, zone: string, opts: InstancesResetOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/reset`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Resumes an instance that was suspended using the instances().suspend
   * method.
   *
   * @param instance Name of the instance resource to resume.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesResume(instance: string, project: string, zone: string, opts: InstancesResumeOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/resume`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Sends diagnostic interrupt to the instance.
   *
   * @param instance Name of the instance scoping this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesSendDiagnosticInterrupt(instance: string, project: string, zone: string): Promise<void> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/sendDiagnosticInterrupt`);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
  }

  /**
   * Sets deletion protection on the instance.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesSetDeletionProtection(project: string, resource: string, zone: string, opts: InstancesSetDeletionProtectionOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ resource }/setDeletionProtection`);
    if (opts.deletionProtection !== undefined) {
      url.searchParams.append("deletionProtection", String(opts.deletionProtection));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the auto-delete flag for a disk attached to an instance.
   *
   * @param instance The instance name for this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesSetDiskAutoDelete(instance: string, project: string, zone: string, opts: InstancesSetDiskAutoDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/setDiskAutoDelete`);
    if (opts.autoDelete !== undefined) {
      url.searchParams.append("autoDelete", String(opts.autoDelete));
    }
    if (opts.deviceName !== undefined) {
      url.searchParams.append("deviceName", String(opts.deviceName));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesSetIamPolicy(project: string, resource: string, zone: string, req: ZoneSetPolicyRequest): Promise<Policy> {
    req = serializeZoneSetPolicyRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ resource }/setIamPolicy`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializePolicy(data);
  }

  /**
   * Sets labels on an instance. To learn more about labels, read the Labeling
   * Resources documentation.
   *
   * @param instance Name of the instance scoping this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesSetLabels(instance: string, project: string, zone: string, req: InstancesSetLabelsRequest, opts: InstancesSetLabelsOptions = {}): Promise<Operation> {
    req = serializeInstancesSetLabelsRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/setLabels`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Changes the number and/or type of accelerator for a stopped instance to
   * the values specified in the request.
   *
   * @param instance Name of the instance scoping this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesSetMachineResources(instance: string, project: string, zone: string, req: InstancesSetMachineResourcesRequest, opts: InstancesSetMachineResourcesOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/setMachineResources`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Changes the machine type for a stopped instance to the machine type
   * specified in the request.
   *
   * @param instance Name of the instance scoping this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesSetMachineType(instance: string, project: string, zone: string, req: InstancesSetMachineTypeRequest, opts: InstancesSetMachineTypeOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/setMachineType`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets metadata for the specified instance to the data included in the
   * request.
   *
   * @param instance Name of the instance scoping this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesSetMetadata(instance: string, project: string, zone: string, req: Metadata, opts: InstancesSetMetadataOptions = {}): Promise<Operation> {
    req = serializeMetadata(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/setMetadata`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Changes the minimum CPU platform that this instance should use. This
   * method can only be called on a stopped instance. For more information, read
   * Specifying a Minimum CPU Platform.
   *
   * @param instance Name of the instance scoping this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesSetMinCpuPlatform(instance: string, project: string, zone: string, req: InstancesSetMinCpuPlatformRequest, opts: InstancesSetMinCpuPlatformOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/setMinCpuPlatform`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets name of an instance.
   *
   * @param instance The instance name for this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesSetName(instance: string, project: string, zone: string, req: InstancesSetNameRequest, opts: InstancesSetNameOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/setName`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets an instance's scheduling options. You can only call this method on a
   * stopped instance, that is, a VM instance that is in a `TERMINATED` state.
   * See Instance Life Cycle for more information on the possible instance
   * states. For more information about setting scheduling options for a VM, see
   * Set VM host maintenance policy.
   *
   * @param instance Instance name for this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesSetScheduling(instance: string, project: string, zone: string, req: Scheduling, opts: InstancesSetSchedulingOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/setScheduling`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the service account on the instance. For more information, read
   * Changing the service account and access scopes for an instance.
   *
   * @param instance Name of the instance resource to start.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesSetServiceAccount(instance: string, project: string, zone: string, req: InstancesSetServiceAccountRequest, opts: InstancesSetServiceAccountOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/setServiceAccount`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the Shielded Instance integrity policy for an instance. You can only
   * use this method on a running instance. This method supports PATCH semantics
   * and uses the JSON merge patch format and processing rules.
   *
   * @param instance Name or id of the instance scoping this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesSetShieldedInstanceIntegrityPolicy(instance: string, project: string, zone: string, req: ShieldedInstanceIntegrityPolicy, opts: InstancesSetShieldedInstanceIntegrityPolicyOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/setShieldedInstanceIntegrityPolicy`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets network tags for the specified instance to the data included in the
   * request.
   *
   * @param instance Name of the instance scoping this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesSetTags(instance: string, project: string, zone: string, req: Tags, opts: InstancesSetTagsOptions = {}): Promise<Operation> {
    req = serializeTags(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/setTags`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Simulates a host maintenance event on a VM. For more information, see
   * Simulate a host maintenance event.
   *
   * @param instance Name of the instance scoping this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesSimulateMaintenanceEvent(instance: string, project: string, zone: string): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/simulateMaintenanceEvent`);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Starts an instance that was stopped using the instances().stop method. For
   * more information, see Restart an instance.
   *
   * @param instance Name of the instance resource to start.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesStart(instance: string, project: string, zone: string, opts: InstancesStartOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/start`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Starts an instance that was stopped using the instances().stop method. For
   * more information, see Restart an instance.
   *
   * @param instance Name of the instance resource to start.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesStartWithEncryptionKey(instance: string, project: string, zone: string, req: InstancesStartWithEncryptionKeyRequest, opts: InstancesStartWithEncryptionKeyOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/startWithEncryptionKey`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Stops a running instance, shutting it down cleanly, and allows you to
   * restart the instance at a later time. Stopped instances do not incur VM
   * usage charges while they are stopped. However, resources that the VM is
   * using, such as persistent disks and static IP addresses, will continue to
   * be charged until they are deleted. For more information, see Stopping an
   * instance.
   *
   * @param instance Name of the instance resource to stop.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesStop(instance: string, project: string, zone: string, opts: InstancesStopOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/stop`);
    if (opts.discardLocalSsd !== undefined) {
      url.searchParams.append("discardLocalSsd", String(opts.discardLocalSsd));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * This method suspends a running instance, saving its state to persistent
   * storage, and allows you to resume the instance at a later time. Suspended
   * instances have no compute costs (cores or RAM), and incur only storage
   * charges for the saved VM memory and localSSD data. Any charged resources
   * the virtual machine was using, such as persistent disks and static IP
   * addresses, will continue to be charged while the instance is suspended. For
   * more information, see Suspending and resuming an instance.
   *
   * @param instance Name of the instance resource to suspend.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesSuspend(instance: string, project: string, zone: string, opts: InstancesSuspendOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/suspend`);
    if (opts.discardLocalSsd !== undefined) {
      url.searchParams.append("discardLocalSsd", String(opts.discardLocalSsd));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns permissions that a caller has on the specified resource.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesTestIamPermissions(project: string, resource: string, zone: string, req: TestPermissionsRequest): Promise<TestPermissionsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ resource }/testIamPermissions`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as TestPermissionsResponse;
  }

  /**
   * Updates an instance only if the necessary resources are available. This
   * method can update only a specific set of instance properties. See Updating
   * a running instance for a list of updatable instance properties.
   *
   * @param instance Name of the instance resource to update.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesUpdate(instance: string, project: string, zone: string, req: Instance, opts: InstancesUpdateOptions = {}): Promise<Operation> {
    req = serializeInstance(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }`);
    if (opts.minimalAction !== undefined) {
      url.searchParams.append("minimalAction", String(opts.minimalAction));
    }
    if (opts.mostDisruptiveAllowedAction !== undefined) {
      url.searchParams.append("mostDisruptiveAllowedAction", String(opts.mostDisruptiveAllowedAction));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PUT",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Updates the specified access config from an instance's network interface
   * with the data included in the request. This method supports PATCH semantics
   * and uses the JSON merge patch format and processing rules.
   *
   * @param instance The instance name for this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesUpdateAccessConfig(instance: string, project: string, zone: string, req: AccessConfig, opts: InstancesUpdateAccessConfigOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/updateAccessConfig`);
    if (opts.networkInterface !== undefined) {
      url.searchParams.append("networkInterface", String(opts.networkInterface));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Updates the Display config for a VM instance. You can only use this method
   * on a stopped VM instance. This method supports PATCH semantics and uses the
   * JSON merge patch format and processing rules.
   *
   * @param instance Name of the instance scoping this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesUpdateDisplayDevice(instance: string, project: string, zone: string, req: DisplayDevice, opts: InstancesUpdateDisplayDeviceOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/updateDisplayDevice`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Updates an instance's network interface. This method can only update an
   * interface's alias IP range and attached network. See Modifying alias IP
   * ranges for an existing instance for instructions on changing alias IP
   * ranges. See Migrating a VM between networks for instructions on migrating
   * an interface. This method follows PATCH semantics.
   *
   * @param instance The instance name for this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesUpdateNetworkInterface(instance: string, project: string, zone: string, req: NetworkInterface, opts: InstancesUpdateNetworkInterfaceOptions = {}): Promise<Operation> {
    req = serializeNetworkInterface(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/updateNetworkInterface`);
    if (opts.networkInterface !== undefined) {
      url.searchParams.append("networkInterface", String(opts.networkInterface));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Updates the Shielded Instance config for an instance. You can only use
   * this method on a stopped instance. This method supports PATCH semantics and
   * uses the JSON merge patch format and processing rules.
   *
   * @param instance Name or id of the instance scoping this request.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async instancesUpdateShieldedInstanceConfig(instance: string, project: string, zone: string, req: ShieldedInstanceConfig, opts: InstancesUpdateShieldedInstanceConfigOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/instances/${ instance }/updateShieldedInstanceConfig`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of all InstanceTemplates resources, regional and
   * global, available to the specified project.
   *
   * @param project Name of the project scoping this request.
   */
  async instanceTemplatesAggregatedList(project: string, opts: InstanceTemplatesAggregatedListOptions = {}): Promise<InstanceTemplateAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/instanceTemplates`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeInstanceTemplateAggregatedList(data);
  }

  /**
   * Deletes the specified instance template. Deleting an instance template is
   * permanent and cannot be undone. It is not possible to delete templates that
   * are already in use by a managed instance group.
   *
   * @param instanceTemplate The name of the instance template to delete.
   * @param project Project ID for this request.
   */
  async instanceTemplatesDelete(instanceTemplate: string, project: string, opts: InstanceTemplatesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/instanceTemplates/${ instanceTemplate }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified instance template.
   *
   * @param instanceTemplate The name of the instance template.
   * @param project Project ID for this request.
   */
  async instanceTemplatesGet(instanceTemplate: string, project: string): Promise<InstanceTemplate> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/instanceTemplates/${ instanceTemplate }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeInstanceTemplate(data);
  }

  /**
   * Gets the access control policy for a resource. May be empty if no such
   * policy or resource exists.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async instanceTemplatesGetIamPolicy(project: string, resource: string, opts: InstanceTemplatesGetIamPolicyOptions = {}): Promise<Policy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/instanceTemplates/${ resource }/getIamPolicy`);
    if (opts.optionsRequestedPolicyVersion !== undefined) {
      url.searchParams.append("optionsRequestedPolicyVersion", String(opts.optionsRequestedPolicyVersion));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePolicy(data);
  }

  /**
   * Creates an instance template in the specified project using the data that
   * is included in the request. If you are creating a new template to update an
   * existing instance group, your new instance template must use the same
   * network or, if applicable, the same subnetwork as the original template.
   *
   * @param project Project ID for this request.
   */
  async instanceTemplatesInsert(project: string, req: InstanceTemplate, opts: InstanceTemplatesInsertOptions = {}): Promise<Operation> {
    req = serializeInstanceTemplate(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/instanceTemplates`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of instance templates that are contained within the
   * specified project.
   *
   * @param project Project ID for this request.
   */
  async instanceTemplatesList(project: string, opts: InstanceTemplatesListOptions = {}): Promise<InstanceTemplateList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/instanceTemplates`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeInstanceTemplateList(data);
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async instanceTemplatesSetIamPolicy(project: string, resource: string, req: GlobalSetPolicyRequest): Promise<Policy> {
    req = serializeGlobalSetPolicyRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/instanceTemplates/${ resource }/setIamPolicy`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializePolicy(data);
  }

  /**
   * Returns permissions that a caller has on the specified resource.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async instanceTemplatesTestIamPermissions(project: string, resource: string, req: TestPermissionsRequest): Promise<TestPermissionsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/instanceTemplates/${ resource }/testIamPermissions`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as TestPermissionsResponse;
  }

  /**
   * Retrieves an aggregated list of interconnect attachments.
   *
   * @param project Project ID for this request.
   */
  async interconnectAttachmentsAggregatedList(project: string, opts: InterconnectAttachmentsAggregatedListOptions = {}): Promise<InterconnectAttachmentAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/interconnectAttachments`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeInterconnectAttachmentAggregatedList(data);
  }

  /**
   * Deletes the specified interconnect attachment.
   *
   * @param interconnectAttachment Name of the interconnect attachment to delete.
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async interconnectAttachmentsDelete(interconnectAttachment: string, project: string, region: string, opts: InterconnectAttachmentsDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/interconnectAttachments/${ interconnectAttachment }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified interconnect attachment.
   *
   * @param interconnectAttachment Name of the interconnect attachment to return.
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async interconnectAttachmentsGet(interconnectAttachment: string, project: string, region: string): Promise<InterconnectAttachment> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/interconnectAttachments/${ interconnectAttachment }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeInterconnectAttachment(data);
  }

  /**
   * Creates an InterconnectAttachment in the specified project using the data
   * included in the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async interconnectAttachmentsInsert(project: string, region: string, req: InterconnectAttachment, opts: InterconnectAttachmentsInsertOptions = {}): Promise<Operation> {
    req = serializeInterconnectAttachment(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/interconnectAttachments`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    if (opts.validateOnly !== undefined) {
      url.searchParams.append("validateOnly", String(opts.validateOnly));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of interconnect attachments contained within the
   * specified region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async interconnectAttachmentsList(project: string, region: string, opts: InterconnectAttachmentsListOptions = {}): Promise<InterconnectAttachmentList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/interconnectAttachments`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeInterconnectAttachmentList(data);
  }

  /**
   * Updates the specified interconnect attachment with the data included in
   * the request. This method supports PATCH semantics and uses the JSON merge
   * patch format and processing rules.
   *
   * @param interconnectAttachment Name of the interconnect attachment to patch.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async interconnectAttachmentsPatch(interconnectAttachment: string, project: string, region: string, req: InterconnectAttachment, opts: InterconnectAttachmentsPatchOptions = {}): Promise<Operation> {
    req = serializeInterconnectAttachment(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/interconnectAttachments/${ interconnectAttachment }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the labels on an InterconnectAttachment. To learn more about labels,
   * read the Labeling Resources documentation.
   *
   * @param project Project ID for this request.
   * @param region The region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async interconnectAttachmentsSetLabels(project: string, region: string, resource: string, req: RegionSetLabelsRequest, opts: InterconnectAttachmentsSetLabelsOptions = {}): Promise<Operation> {
    req = serializeRegionSetLabelsRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/interconnectAttachments/${ resource }/setLabels`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the details for the specified interconnect location. Gets a list
   * of available interconnect locations by making a list() request.
   *
   * @param interconnectLocation Name of the interconnect location to return.
   * @param project Project ID for this request.
   */
  async interconnectLocationsGet(interconnectLocation: string, project: string): Promise<InterconnectLocation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/interconnectLocations/${ interconnectLocation }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeInterconnectLocation(data);
  }

  /**
   * Retrieves the list of interconnect locations available to the specified
   * project.
   *
   * @param project Project ID for this request.
   */
  async interconnectLocationsList(project: string, opts: InterconnectLocationsListOptions = {}): Promise<InterconnectLocationList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/interconnectLocations`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeInterconnectLocationList(data);
  }

  /**
   * Deletes the specified Interconnect.
   *
   * @param interconnect Name of the interconnect to delete.
   * @param project Project ID for this request.
   */
  async interconnectsDelete(interconnect: string, project: string, opts: InterconnectsDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/interconnects/${ interconnect }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified Interconnect. Get a list of available Interconnects
   * by making a list() request.
   *
   * @param interconnect Name of the interconnect to return.
   * @param project Project ID for this request.
   */
  async interconnectsGet(interconnect: string, project: string): Promise<Interconnect> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/interconnects/${ interconnect }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeInterconnect(data);
  }

  /**
   * Returns the interconnectDiagnostics for the specified Interconnect.
   *
   * @param interconnect Name of the interconnect resource to query.
   * @param project Project ID for this request.
   */
  async interconnectsGetDiagnostics(interconnect: string, project: string): Promise<InterconnectsGetDiagnosticsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/interconnects/${ interconnect }/getDiagnostics`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return data as InterconnectsGetDiagnosticsResponse;
  }

  /**
   * Creates an Interconnect in the specified project using the data included
   * in the request.
   *
   * @param project Project ID for this request.
   */
  async interconnectsInsert(project: string, req: Interconnect, opts: InterconnectsInsertOptions = {}): Promise<Operation> {
    req = serializeInterconnect(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/interconnects`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of Interconnects available to the specified project.
   *
   * @param project Project ID for this request.
   */
  async interconnectsList(project: string, opts: InterconnectsListOptions = {}): Promise<InterconnectList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/interconnects`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeInterconnectList(data);
  }

  /**
   * Updates the specified Interconnect with the data included in the request.
   * This method supports PATCH semantics and uses the JSON merge patch format
   * and processing rules.
   *
   * @param interconnect Name of the interconnect to update.
   * @param project Project ID for this request.
   */
  async interconnectsPatch(interconnect: string, project: string, req: Interconnect, opts: InterconnectsPatchOptions = {}): Promise<Operation> {
    req = serializeInterconnect(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/interconnects/${ interconnect }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the labels on an Interconnect. To learn more about labels, read the
   * Labeling Resources documentation.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async interconnectsSetLabels(project: string, resource: string, req: GlobalSetLabelsRequest): Promise<Operation> {
    req = serializeGlobalSetLabelsRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/interconnects/${ resource }/setLabels`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Return a specified license code. License codes are mirrored across all
   * projects that have permissions to read the License Code. *Caution* This
   * resource is intended for use only by third-party partners who are creating
   * Cloud Marketplace images.
   *
   * @param licenseCode Number corresponding to the License code resource to return.
   * @param project Project ID for this request.
   */
  async licenseCodesGet(licenseCode: string, project: string): Promise<LicenseCode> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/licenseCodes/${ licenseCode }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeLicenseCode(data);
  }

  /**
   * Returns permissions that a caller has on the specified resource. *Caution*
   * This resource is intended for use only by third-party partners who are
   * creating Cloud Marketplace images.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async licenseCodesTestIamPermissions(project: string, resource: string, req: TestPermissionsRequest): Promise<TestPermissionsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/licenseCodes/${ resource }/testIamPermissions`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as TestPermissionsResponse;
  }

  /**
   * Deletes the specified license. *Caution* This resource is intended for use
   * only by third-party partners who are creating Cloud Marketplace images.
   *
   * @param license Name of the license resource to delete.
   * @param project Project ID for this request.
   */
  async licensesDelete(license: string, project: string, opts: LicensesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/licenses/${ license }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified License resource. *Caution* This resource is
   * intended for use only by third-party partners who are creating Cloud
   * Marketplace images.
   *
   * @param license Name of the License resource to return.
   * @param project Project ID for this request.
   */
  async licensesGet(license: string, project: string): Promise<License> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/licenses/${ license }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeLicense(data);
  }

  /**
   * Gets the access control policy for a resource. May be empty if no such
   * policy or resource exists. *Caution* This resource is intended for use only
   * by third-party partners who are creating Cloud Marketplace images.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async licensesGetIamPolicy(project: string, resource: string, opts: LicensesGetIamPolicyOptions = {}): Promise<Policy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/licenses/${ resource }/getIamPolicy`);
    if (opts.optionsRequestedPolicyVersion !== undefined) {
      url.searchParams.append("optionsRequestedPolicyVersion", String(opts.optionsRequestedPolicyVersion));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePolicy(data);
  }

  /**
   * Create a License resource in the specified project. *Caution* This
   * resource is intended for use only by third-party partners who are creating
   * Cloud Marketplace images.
   *
   * @param project Project ID for this request.
   */
  async licensesInsert(project: string, req: License, opts: LicensesInsertOptions = {}): Promise<Operation> {
    req = serializeLicense(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/licenses`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of licenses available in the specified project. This
   * method does not get any licenses that belong to other projects, including
   * licenses attached to publicly-available images, like Debian 9. If you want
   * to get a list of publicly-available licenses, use this method to make a
   * request to the respective image project, such as debian-cloud or
   * windows-cloud. *Caution* This resource is intended for use only by
   * third-party partners who are creating Cloud Marketplace images.
   *
   * @param project Project ID for this request.
   */
  async licensesList(project: string, opts: LicensesListOptions = {}): Promise<LicensesListResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/licenses`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeLicensesListResponse(data);
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy. *Caution* This resource is intended for use only by
   * third-party partners who are creating Cloud Marketplace images.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async licensesSetIamPolicy(project: string, resource: string, req: GlobalSetPolicyRequest): Promise<Policy> {
    req = serializeGlobalSetPolicyRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/licenses/${ resource }/setIamPolicy`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializePolicy(data);
  }

  /**
   * Returns permissions that a caller has on the specified resource. *Caution*
   * This resource is intended for use only by third-party partners who are
   * creating Cloud Marketplace images.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async licensesTestIamPermissions(project: string, resource: string, req: TestPermissionsRequest): Promise<TestPermissionsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/licenses/${ resource }/testIamPermissions`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as TestPermissionsResponse;
  }

  /**
   * Deletes the specified machine image. Deleting a machine image is permanent
   * and cannot be undone.
   *
   * @param machineImage The name of the machine image to delete.
   * @param project Project ID for this request.
   */
  async machineImagesDelete(machineImage: string, project: string, opts: MachineImagesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/machineImages/${ machineImage }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified machine image.
   *
   * @param machineImage The name of the machine image.
   * @param project Project ID for this request.
   */
  async machineImagesGet(machineImage: string, project: string): Promise<MachineImage> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/machineImages/${ machineImage }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeMachineImage(data);
  }

  /**
   * Gets the access control policy for a resource. May be empty if no such
   * policy or resource exists.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async machineImagesGetIamPolicy(project: string, resource: string, opts: MachineImagesGetIamPolicyOptions = {}): Promise<Policy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/machineImages/${ resource }/getIamPolicy`);
    if (opts.optionsRequestedPolicyVersion !== undefined) {
      url.searchParams.append("optionsRequestedPolicyVersion", String(opts.optionsRequestedPolicyVersion));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePolicy(data);
  }

  /**
   * Creates a machine image in the specified project using the data that is
   * included in the request. If you are creating a new machine image to update
   * an existing instance, your new machine image should use the same network
   * or, if applicable, the same subnetwork as the original instance.
   *
   * @param project Project ID for this request.
   */
  async machineImagesInsert(project: string, req: MachineImage, opts: MachineImagesInsertOptions = {}): Promise<Operation> {
    req = serializeMachineImage(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/machineImages`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    if (opts.sourceInstance !== undefined) {
      url.searchParams.append("sourceInstance", String(opts.sourceInstance));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of machine images that are contained within the specified
   * project.
   *
   * @param project Project ID for this request.
   */
  async machineImagesList(project: string, opts: MachineImagesListOptions = {}): Promise<MachineImageList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/machineImages`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeMachineImageList(data);
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async machineImagesSetIamPolicy(project: string, resource: string, req: GlobalSetPolicyRequest): Promise<Policy> {
    req = serializeGlobalSetPolicyRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/machineImages/${ resource }/setIamPolicy`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializePolicy(data);
  }

  /**
   * Returns permissions that a caller has on the specified resource.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async machineImagesTestIamPermissions(project: string, resource: string, req: TestPermissionsRequest): Promise<TestPermissionsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/machineImages/${ resource }/testIamPermissions`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as TestPermissionsResponse;
  }

  /**
   * Retrieves an aggregated list of machine types.
   *
   * @param project Project ID for this request.
   */
  async machineTypesAggregatedList(project: string, opts: MachineTypesAggregatedListOptions = {}): Promise<MachineTypeAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/machineTypes`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeMachineTypeAggregatedList(data);
  }

  /**
   * Returns the specified machine type.
   *
   * @param machineType Name of the machine type to return.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async machineTypesGet(machineType: string, project: string, zone: string): Promise<MachineType> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/machineTypes/${ machineType }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeMachineType(data);
  }

  /**
   * Retrieves a list of machine types available to the specified project.
   *
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async machineTypesList(project: string, zone: string, opts: MachineTypesListOptions = {}): Promise<MachineTypeList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/machineTypes`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeMachineTypeList(data);
  }

  /**
   * Retrieves the list of all NetworkAttachment resources, regional and
   * global, available to the specified project.
   *
   * @param project Project ID for this request.
   */
  async networkAttachmentsAggregatedList(project: string, opts: NetworkAttachmentsAggregatedListOptions = {}): Promise<NetworkAttachmentAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/networkAttachments`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNetworkAttachmentAggregatedList(data);
  }

  /**
   * Deletes the specified NetworkAttachment in the given scope
   *
   * @param networkAttachment Name of the NetworkAttachment resource to delete.
   * @param project Project ID for this request.
   * @param region Name of the region of this request.
   */
  async networkAttachmentsDelete(networkAttachment: string, project: string, region: string, opts: NetworkAttachmentsDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/networkAttachments/${ networkAttachment }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified NetworkAttachment resource in the given scope.
   *
   * @param networkAttachment Name of the NetworkAttachment resource to return.
   * @param project Project ID for this request.
   * @param region Name of the region of this request.
   */
  async networkAttachmentsGet(networkAttachment: string, project: string, region: string): Promise<NetworkAttachment> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/networkAttachments/${ networkAttachment }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNetworkAttachment(data);
  }

  /**
   * Gets the access control policy for a resource. May be empty if no such
   * policy or resource exists.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async networkAttachmentsGetIamPolicy(project: string, region: string, resource: string, opts: NetworkAttachmentsGetIamPolicyOptions = {}): Promise<Policy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/networkAttachments/${ resource }/getIamPolicy`);
    if (opts.optionsRequestedPolicyVersion !== undefined) {
      url.searchParams.append("optionsRequestedPolicyVersion", String(opts.optionsRequestedPolicyVersion));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePolicy(data);
  }

  /**
   * Creates a NetworkAttachment in the specified project in the given scope
   * using the parameters that are included in the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region of this request.
   */
  async networkAttachmentsInsert(project: string, region: string, req: NetworkAttachment, opts: NetworkAttachmentsInsertOptions = {}): Promise<Operation> {
    req = serializeNetworkAttachment(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/networkAttachments`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Lists the NetworkAttachments for a project in the given scope.
   *
   * @param project Project ID for this request.
   * @param region Name of the region of this request.
   */
  async networkAttachmentsList(project: string, region: string, opts: NetworkAttachmentsListOptions = {}): Promise<NetworkAttachmentList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/networkAttachments`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNetworkAttachmentList(data);
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async networkAttachmentsSetIamPolicy(project: string, region: string, resource: string, req: RegionSetPolicyRequest): Promise<Policy> {
    req = serializeRegionSetPolicyRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/networkAttachments/${ resource }/setIamPolicy`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializePolicy(data);
  }

  /**
   * Returns permissions that a caller has on the specified resource.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async networkAttachmentsTestIamPermissions(project: string, region: string, resource: string, req: TestPermissionsRequest): Promise<TestPermissionsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/networkAttachments/${ resource }/testIamPermissions`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as TestPermissionsResponse;
  }

  /**
   * Retrieves the list of all NetworkEdgeSecurityService resources available
   * to the specified project.
   *
   * @param project Name of the project scoping this request.
   */
  async networkEdgeSecurityServicesAggregatedList(project: string, opts: NetworkEdgeSecurityServicesAggregatedListOptions = {}): Promise<NetworkEdgeSecurityServiceAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/networkEdgeSecurityServices`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNetworkEdgeSecurityServiceAggregatedList(data);
  }

  /**
   * Deletes the specified service.
   *
   * @param networkEdgeSecurityService Name of the network edge security service to delete.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async networkEdgeSecurityServicesDelete(networkEdgeSecurityService: string, project: string, region: string, opts: NetworkEdgeSecurityServicesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/networkEdgeSecurityServices/${ networkEdgeSecurityService }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Gets a specified NetworkEdgeSecurityService.
   *
   * @param networkEdgeSecurityService Name of the network edge security service to get.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async networkEdgeSecurityServicesGet(networkEdgeSecurityService: string, project: string, region: string): Promise<NetworkEdgeSecurityService> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/networkEdgeSecurityServices/${ networkEdgeSecurityService }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNetworkEdgeSecurityService(data);
  }

  /**
   * Creates a new service in the specified project using the data included in
   * the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async networkEdgeSecurityServicesInsert(project: string, region: string, req: NetworkEdgeSecurityService, opts: NetworkEdgeSecurityServicesInsertOptions = {}): Promise<Operation> {
    req = serializeNetworkEdgeSecurityService(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/networkEdgeSecurityServices`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    if (opts.validateOnly !== undefined) {
      url.searchParams.append("validateOnly", String(opts.validateOnly));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Patches the specified policy with the data included in the request.
   *
   * @param networkEdgeSecurityService Name of the network edge security service to update.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async networkEdgeSecurityServicesPatch(networkEdgeSecurityService: string, project: string, region: string, req: NetworkEdgeSecurityService, opts: NetworkEdgeSecurityServicesPatchOptions = {}): Promise<Operation> {
    req = serializeNetworkEdgeSecurityService(req);
    opts = serializeNetworkEdgeSecurityServicesPatchOptions(opts);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/networkEdgeSecurityServices/${ networkEdgeSecurityService }`);
    if (opts.paths !== undefined) {
      url.searchParams.append("paths", String(opts.paths));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    if (opts.updateMask !== undefined) {
      url.searchParams.append("updateMask", String(opts.updateMask));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of network endpoint groups and sorts them by zone.
   *
   * @param project Project ID for this request.
   */
  async networkEndpointGroupsAggregatedList(project: string, opts: NetworkEndpointGroupsAggregatedListOptions = {}): Promise<NetworkEndpointGroupAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/networkEndpointGroups`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNetworkEndpointGroupAggregatedList(data);
  }

  /**
   * Attach a list of network endpoints to the specified network endpoint
   * group.
   *
   * @param networkEndpointGroup The name of the network endpoint group where you are attaching network endpoints to. It should comply with RFC1035.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the network endpoint group is located. It should comply with RFC1035.
   */
  async networkEndpointGroupsAttachNetworkEndpoints(networkEndpointGroup: string, project: string, zone: string, req: NetworkEndpointGroupsAttachEndpointsRequest, opts: NetworkEndpointGroupsAttachNetworkEndpointsOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/networkEndpointGroups/${ networkEndpointGroup }/attachNetworkEndpoints`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified network endpoint group. The network endpoints in the
   * NEG and the VM instances they belong to are not terminated when the NEG is
   * deleted. Note that the NEG cannot be deleted if there are backend services
   * referencing it.
   *
   * @param networkEndpointGroup The name of the network endpoint group to delete. It should comply with RFC1035.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the network endpoint group is located. It should comply with RFC1035.
   */
  async networkEndpointGroupsDelete(networkEndpointGroup: string, project: string, zone: string, opts: NetworkEndpointGroupsDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/networkEndpointGroups/${ networkEndpointGroup }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Detach a list of network endpoints from the specified network endpoint
   * group.
   *
   * @param networkEndpointGroup The name of the network endpoint group where you are removing network endpoints. It should comply with RFC1035.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the network endpoint group is located. It should comply with RFC1035.
   */
  async networkEndpointGroupsDetachNetworkEndpoints(networkEndpointGroup: string, project: string, zone: string, req: NetworkEndpointGroupsDetachEndpointsRequest, opts: NetworkEndpointGroupsDetachNetworkEndpointsOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/networkEndpointGroups/${ networkEndpointGroup }/detachNetworkEndpoints`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified network endpoint group.
   *
   * @param networkEndpointGroup The name of the network endpoint group. It should comply with RFC1035.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the network endpoint group is located. It should comply with RFC1035.
   */
  async networkEndpointGroupsGet(networkEndpointGroup: string, project: string, zone: string): Promise<NetworkEndpointGroup> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/networkEndpointGroups/${ networkEndpointGroup }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNetworkEndpointGroup(data);
  }

  /**
   * Creates a network endpoint group in the specified project using the
   * parameters that are included in the request.
   *
   * @param project Project ID for this request.
   * @param zone The name of the zone where you want to create the network endpoint group. It should comply with RFC1035.
   */
  async networkEndpointGroupsInsert(project: string, zone: string, req: NetworkEndpointGroup, opts: NetworkEndpointGroupsInsertOptions = {}): Promise<Operation> {
    req = serializeNetworkEndpointGroup(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/networkEndpointGroups`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of network endpoint groups that are located in the
   * specified project and zone.
   *
   * @param project Project ID for this request.
   * @param zone The name of the zone where the network endpoint group is located. It should comply with RFC1035.
   */
  async networkEndpointGroupsList(project: string, zone: string, opts: NetworkEndpointGroupsListOptions = {}): Promise<NetworkEndpointGroupList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/networkEndpointGroups`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNetworkEndpointGroupList(data);
  }

  /**
   * Lists the network endpoints in the specified network endpoint group.
   *
   * @param networkEndpointGroup The name of the network endpoint group from which you want to generate a list of included network endpoints. It should comply with RFC1035.
   * @param project Project ID for this request.
   * @param zone The name of the zone where the network endpoint group is located. It should comply with RFC1035.
   */
  async networkEndpointGroupsListNetworkEndpoints(networkEndpointGroup: string, project: string, zone: string, req: NetworkEndpointGroupsListEndpointsRequest, opts: NetworkEndpointGroupsListNetworkEndpointsOptions = {}): Promise<NetworkEndpointGroupsListNetworkEndpoints> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/networkEndpointGroups/${ networkEndpointGroup }/listNetworkEndpoints`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as NetworkEndpointGroupsListNetworkEndpoints;
  }

  /**
   * Returns permissions that a caller has on the specified resource.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   * @param zone The name of the zone for this request.
   */
  async networkEndpointGroupsTestIamPermissions(project: string, resource: string, zone: string, req: TestPermissionsRequest): Promise<TestPermissionsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/networkEndpointGroups/${ resource }/testIamPermissions`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as TestPermissionsResponse;
  }

  /**
   * Inserts an association for the specified firewall policy.
   *
   * @param firewallPolicy Name of the firewall policy to update.
   * @param project Project ID for this request.
   */
  async networkFirewallPoliciesAddAssociation(firewallPolicy: string, project: string, req: FirewallPolicyAssociation, opts: NetworkFirewallPoliciesAddAssociationOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/firewallPolicies/${ firewallPolicy }/addAssociation`);
    if (opts.replaceExistingAssociation !== undefined) {
      url.searchParams.append("replaceExistingAssociation", String(opts.replaceExistingAssociation));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Inserts a rule into a firewall policy.
   *
   * @param firewallPolicy Name of the firewall policy to update.
   * @param project Project ID for this request.
   */
  async networkFirewallPoliciesAddRule(firewallPolicy: string, project: string, req: FirewallPolicyRule, opts: NetworkFirewallPoliciesAddRuleOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/firewallPolicies/${ firewallPolicy }/addRule`);
    if (opts.maxPriority !== undefined) {
      url.searchParams.append("maxPriority", String(opts.maxPriority));
    }
    if (opts.minPriority !== undefined) {
      url.searchParams.append("minPriority", String(opts.minPriority));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Copies rules to the specified firewall policy.
   *
   * @param firewallPolicy Name of the firewall policy to update.
   * @param project Project ID for this request.
   */
  async networkFirewallPoliciesCloneRules(firewallPolicy: string, project: string, opts: NetworkFirewallPoliciesCloneRulesOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/firewallPolicies/${ firewallPolicy }/cloneRules`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    if (opts.sourceFirewallPolicy !== undefined) {
      url.searchParams.append("sourceFirewallPolicy", String(opts.sourceFirewallPolicy));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified policy.
   *
   * @param firewallPolicy Name of the firewall policy to delete.
   * @param project Project ID for this request.
   */
  async networkFirewallPoliciesDelete(firewallPolicy: string, project: string, opts: NetworkFirewallPoliciesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/firewallPolicies/${ firewallPolicy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified network firewall policy.
   *
   * @param firewallPolicy Name of the firewall policy to get.
   * @param project Project ID for this request.
   */
  async networkFirewallPoliciesGet(firewallPolicy: string, project: string): Promise<FirewallPolicy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/firewallPolicies/${ firewallPolicy }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeFirewallPolicy(data);
  }

  /**
   * Gets an association with the specified name.
   *
   * @param firewallPolicy Name of the firewall policy to which the queried association belongs.
   * @param project Project ID for this request.
   */
  async networkFirewallPoliciesGetAssociation(firewallPolicy: string, project: string, opts: NetworkFirewallPoliciesGetAssociationOptions = {}): Promise<FirewallPolicyAssociation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/firewallPolicies/${ firewallPolicy }/getAssociation`);
    if (opts.name !== undefined) {
      url.searchParams.append("name", String(opts.name));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return data as FirewallPolicyAssociation;
  }

  /**
   * Gets the access control policy for a resource. May be empty if no such
   * policy or resource exists.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async networkFirewallPoliciesGetIamPolicy(project: string, resource: string, opts: NetworkFirewallPoliciesGetIamPolicyOptions = {}): Promise<Policy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/firewallPolicies/${ resource }/getIamPolicy`);
    if (opts.optionsRequestedPolicyVersion !== undefined) {
      url.searchParams.append("optionsRequestedPolicyVersion", String(opts.optionsRequestedPolicyVersion));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePolicy(data);
  }

  /**
   * Gets a rule of the specified priority.
   *
   * @param firewallPolicy Name of the firewall policy to which the queried rule belongs.
   * @param project Project ID for this request.
   */
  async networkFirewallPoliciesGetRule(firewallPolicy: string, project: string, opts: NetworkFirewallPoliciesGetRuleOptions = {}): Promise<FirewallPolicyRule> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/firewallPolicies/${ firewallPolicy }/getRule`);
    if (opts.priority !== undefined) {
      url.searchParams.append("priority", String(opts.priority));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return data as FirewallPolicyRule;
  }

  /**
   * Creates a new policy in the specified project using the data included in
   * the request.
   *
   * @param project Project ID for this request.
   */
  async networkFirewallPoliciesInsert(project: string, req: FirewallPolicy, opts: NetworkFirewallPoliciesInsertOptions = {}): Promise<Operation> {
    req = serializeFirewallPolicy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/firewallPolicies`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Lists all the policies that have been configured for the specified
   * project.
   *
   * @param project Project ID for this request.
   */
  async networkFirewallPoliciesList(project: string, opts: NetworkFirewallPoliciesListOptions = {}): Promise<FirewallPolicyList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/firewallPolicies`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeFirewallPolicyList(data);
  }

  /**
   * Patches the specified policy with the data included in the request.
   *
   * @param firewallPolicy Name of the firewall policy to update.
   * @param project Project ID for this request.
   */
  async networkFirewallPoliciesPatch(firewallPolicy: string, project: string, req: FirewallPolicy, opts: NetworkFirewallPoliciesPatchOptions = {}): Promise<Operation> {
    req = serializeFirewallPolicy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/firewallPolicies/${ firewallPolicy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Patches a rule of the specified priority.
   *
   * @param firewallPolicy Name of the firewall policy to update.
   * @param project Project ID for this request.
   */
  async networkFirewallPoliciesPatchRule(firewallPolicy: string, project: string, req: FirewallPolicyRule, opts: NetworkFirewallPoliciesPatchRuleOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/firewallPolicies/${ firewallPolicy }/patchRule`);
    if (opts.priority !== undefined) {
      url.searchParams.append("priority", String(opts.priority));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Removes an association for the specified firewall policy.
   *
   * @param firewallPolicy Name of the firewall policy to update.
   * @param project Project ID for this request.
   */
  async networkFirewallPoliciesRemoveAssociation(firewallPolicy: string, project: string, opts: NetworkFirewallPoliciesRemoveAssociationOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/firewallPolicies/${ firewallPolicy }/removeAssociation`);
    if (opts.name !== undefined) {
      url.searchParams.append("name", String(opts.name));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes a rule of the specified priority.
   *
   * @param firewallPolicy Name of the firewall policy to update.
   * @param project Project ID for this request.
   */
  async networkFirewallPoliciesRemoveRule(firewallPolicy: string, project: string, opts: NetworkFirewallPoliciesRemoveRuleOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/firewallPolicies/${ firewallPolicy }/removeRule`);
    if (opts.priority !== undefined) {
      url.searchParams.append("priority", String(opts.priority));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async networkFirewallPoliciesSetIamPolicy(project: string, resource: string, req: GlobalSetPolicyRequest): Promise<Policy> {
    req = serializeGlobalSetPolicyRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/firewallPolicies/${ resource }/setIamPolicy`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializePolicy(data);
  }

  /**
   * Returns permissions that a caller has on the specified resource.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async networkFirewallPoliciesTestIamPermissions(project: string, resource: string, req: TestPermissionsRequest): Promise<TestPermissionsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/firewallPolicies/${ resource }/testIamPermissions`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as TestPermissionsResponse;
  }

  /**
   * Adds a peering to the specified network.
   *
   * @param network Name of the network resource to add peering to.
   * @param project Project ID for this request.
   */
  async networksAddPeering(network: string, project: string, req: NetworksAddPeeringRequest, opts: NetworksAddPeeringOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/networks/${ network }/addPeering`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified network.
   *
   * @param network Name of the network to delete.
   * @param project Project ID for this request.
   */
  async networksDelete(network: string, project: string, opts: NetworksDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/networks/${ network }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified network.
   *
   * @param network Name of the network to return.
   * @param project Project ID for this request.
   */
  async networksGet(network: string, project: string): Promise<Network> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/networks/${ network }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNetwork(data);
  }

  /**
   * Returns the effective firewalls on a given network.
   *
   * @param network Name of the network for this request.
   * @param project Project ID for this request.
   */
  async networksGetEffectiveFirewalls(network: string, project: string): Promise<NetworksGetEffectiveFirewallsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/networks/${ network }/getEffectiveFirewalls`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNetworksGetEffectiveFirewallsResponse(data);
  }

  /**
   * Creates a network in the specified project using the data included in the
   * request.
   *
   * @param project Project ID for this request.
   */
  async networksInsert(project: string, req: Network, opts: NetworksInsertOptions = {}): Promise<Operation> {
    req = serializeNetwork(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/networks`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of networks available to the specified project.
   *
   * @param project Project ID for this request.
   */
  async networksList(project: string, opts: NetworksListOptions = {}): Promise<NetworkList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/networks`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNetworkList(data);
  }

  /**
   * Lists the peering routes exchanged over peering connection.
   *
   * @param network Name of the network for this request.
   * @param project Project ID for this request.
   */
  async networksListPeeringRoutes(network: string, project: string, opts: NetworksListPeeringRoutesOptions = {}): Promise<ExchangedPeeringRoutesList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/networks/${ network }/listPeeringRoutes`);
    if (opts.direction !== undefined) {
      url.searchParams.append("direction", String(opts.direction));
    }
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.peeringName !== undefined) {
      url.searchParams.append("peeringName", String(opts.peeringName));
    }
    if (opts.region !== undefined) {
      url.searchParams.append("region", String(opts.region));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return data as ExchangedPeeringRoutesList;
  }

  /**
   * Patches the specified network with the data included in the request. Only
   * the following fields can be modified: routingConfig.routingMode.
   *
   * @param network Name of the network to update.
   * @param project Project ID for this request.
   */
  async networksPatch(network: string, project: string, req: Network, opts: NetworksPatchOptions = {}): Promise<Operation> {
    req = serializeNetwork(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/networks/${ network }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Removes a peering from the specified network.
   *
   * @param network Name of the network resource to remove peering from.
   * @param project Project ID for this request.
   */
  async networksRemovePeering(network: string, project: string, req: NetworksRemovePeeringRequest, opts: NetworksRemovePeeringOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/networks/${ network }/removePeering`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Switches the network mode from auto subnet mode to custom subnet mode.
   *
   * @param network Name of the network to be updated.
   * @param project Project ID for this request.
   */
  async networksSwitchToCustomMode(network: string, project: string, opts: NetworksSwitchToCustomModeOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/networks/${ network }/switchToCustomMode`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Updates the specified network peering with the data included in the
   * request. You can only modify the NetworkPeering.export_custom_routes field
   * and the NetworkPeering.import_custom_routes field.
   *
   * @param network Name of the network resource which the updated peering is belonging to.
   * @param project Project ID for this request.
   */
  async networksUpdatePeering(network: string, project: string, req: NetworksUpdatePeeringRequest, opts: NetworksUpdatePeeringOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/networks/${ network }/updatePeering`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Adds specified number of nodes to the node group.
   *
   * @param nodeGroup Name of the NodeGroup resource.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async nodeGroupsAddNodes(nodeGroup: string, project: string, zone: string, req: NodeGroupsAddNodesRequest, opts: NodeGroupsAddNodesOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/nodeGroups/${ nodeGroup }/addNodes`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves an aggregated list of node groups. Note: use
   * nodeGroups.listNodes for more details about each group.
   *
   * @param project Project ID for this request.
   */
  async nodeGroupsAggregatedList(project: string, opts: NodeGroupsAggregatedListOptions = {}): Promise<NodeGroupAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/nodeGroups`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNodeGroupAggregatedList(data);
  }

  /**
   * Deletes the specified NodeGroup resource.
   *
   * @param nodeGroup Name of the NodeGroup resource to delete.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async nodeGroupsDelete(nodeGroup: string, project: string, zone: string, opts: NodeGroupsDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/nodeGroups/${ nodeGroup }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes specified nodes from the node group.
   *
   * @param nodeGroup Name of the NodeGroup resource whose nodes will be deleted.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async nodeGroupsDeleteNodes(nodeGroup: string, project: string, zone: string, req: NodeGroupsDeleteNodesRequest, opts: NodeGroupsDeleteNodesOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/nodeGroups/${ nodeGroup }/deleteNodes`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified NodeGroup. Get a list of available NodeGroups by
   * making a list() request. Note: the "nodes" field should not be used. Use
   * nodeGroups.listNodes instead.
   *
   * @param nodeGroup Name of the node group to return.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async nodeGroupsGet(nodeGroup: string, project: string, zone: string): Promise<NodeGroup> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/nodeGroups/${ nodeGroup }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNodeGroup(data);
  }

  /**
   * Gets the access control policy for a resource. May be empty if no such
   * policy or resource exists.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   * @param zone The name of the zone for this request.
   */
  async nodeGroupsGetIamPolicy(project: string, resource: string, zone: string, opts: NodeGroupsGetIamPolicyOptions = {}): Promise<Policy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/nodeGroups/${ resource }/getIamPolicy`);
    if (opts.optionsRequestedPolicyVersion !== undefined) {
      url.searchParams.append("optionsRequestedPolicyVersion", String(opts.optionsRequestedPolicyVersion));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePolicy(data);
  }

  /**
   * Creates a NodeGroup resource in the specified project using the data
   * included in the request.
   *
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async nodeGroupsInsert(project: string, zone: string, req: NodeGroup, opts: NodeGroupsInsertOptions = {}): Promise<Operation> {
    req = serializeNodeGroup(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/nodeGroups`);
    if (opts.initialNodeCount !== undefined) {
      url.searchParams.append("initialNodeCount", String(opts.initialNodeCount));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of node groups available to the specified project. Note:
   * use nodeGroups.listNodes for more details about each group.
   *
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async nodeGroupsList(project: string, zone: string, opts: NodeGroupsListOptions = {}): Promise<NodeGroupList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/nodeGroups`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNodeGroupList(data);
  }

  /**
   * Lists nodes in the node group.
   *
   * @param nodeGroup Name of the NodeGroup resource whose nodes you want to list.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async nodeGroupsListNodes(nodeGroup: string, project: string, zone: string, opts: NodeGroupsListNodesOptions = {}): Promise<NodeGroupsListNodes> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/nodeGroups/${ nodeGroup }/listNodes`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return data as NodeGroupsListNodes;
  }

  /**
   * Updates the specified node group.
   *
   * @param nodeGroup Name of the NodeGroup resource to update.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async nodeGroupsPatch(nodeGroup: string, project: string, zone: string, req: NodeGroup, opts: NodeGroupsPatchOptions = {}): Promise<Operation> {
    req = serializeNodeGroup(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/nodeGroups/${ nodeGroup }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   * @param zone The name of the zone for this request.
   */
  async nodeGroupsSetIamPolicy(project: string, resource: string, zone: string, req: ZoneSetPolicyRequest): Promise<Policy> {
    req = serializeZoneSetPolicyRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/nodeGroups/${ resource }/setIamPolicy`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializePolicy(data);
  }

  /**
   * Updates the node template of the node group.
   *
   * @param nodeGroup Name of the NodeGroup resource to update.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async nodeGroupsSetNodeTemplate(nodeGroup: string, project: string, zone: string, req: NodeGroupsSetNodeTemplateRequest, opts: NodeGroupsSetNodeTemplateOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/nodeGroups/${ nodeGroup }/setNodeTemplate`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Returns permissions that a caller has on the specified resource.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   * @param zone The name of the zone for this request.
   */
  async nodeGroupsTestIamPermissions(project: string, resource: string, zone: string, req: TestPermissionsRequest): Promise<TestPermissionsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/nodeGroups/${ resource }/testIamPermissions`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as TestPermissionsResponse;
  }

  /**
   * Retrieves an aggregated list of node templates.
   *
   * @param project Project ID for this request.
   */
  async nodeTemplatesAggregatedList(project: string, opts: NodeTemplatesAggregatedListOptions = {}): Promise<NodeTemplateAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/nodeTemplates`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNodeTemplateAggregatedList(data);
  }

  /**
   * Deletes the specified NodeTemplate resource.
   *
   * @param nodeTemplate Name of the NodeTemplate resource to delete.
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   */
  async nodeTemplatesDelete(nodeTemplate: string, project: string, region: string, opts: NodeTemplatesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/nodeTemplates/${ nodeTemplate }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified node template.
   *
   * @param nodeTemplate Name of the node template to return.
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   */
  async nodeTemplatesGet(nodeTemplate: string, project: string, region: string): Promise<NodeTemplate> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/nodeTemplates/${ nodeTemplate }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNodeTemplate(data);
  }

  /**
   * Gets the access control policy for a resource. May be empty if no such
   * policy or resource exists.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async nodeTemplatesGetIamPolicy(project: string, region: string, resource: string, opts: NodeTemplatesGetIamPolicyOptions = {}): Promise<Policy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/nodeTemplates/${ resource }/getIamPolicy`);
    if (opts.optionsRequestedPolicyVersion !== undefined) {
      url.searchParams.append("optionsRequestedPolicyVersion", String(opts.optionsRequestedPolicyVersion));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePolicy(data);
  }

  /**
   * Creates a NodeTemplate resource in the specified project using the data
   * included in the request.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   */
  async nodeTemplatesInsert(project: string, region: string, req: NodeTemplate, opts: NodeTemplatesInsertOptions = {}): Promise<Operation> {
    req = serializeNodeTemplate(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/nodeTemplates`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of node templates available to the specified project.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   */
  async nodeTemplatesList(project: string, region: string, opts: NodeTemplatesListOptions = {}): Promise<NodeTemplateList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/nodeTemplates`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNodeTemplateList(data);
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async nodeTemplatesSetIamPolicy(project: string, region: string, resource: string, req: RegionSetPolicyRequest): Promise<Policy> {
    req = serializeRegionSetPolicyRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/nodeTemplates/${ resource }/setIamPolicy`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializePolicy(data);
  }

  /**
   * Returns permissions that a caller has on the specified resource.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async nodeTemplatesTestIamPermissions(project: string, region: string, resource: string, req: TestPermissionsRequest): Promise<TestPermissionsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/nodeTemplates/${ resource }/testIamPermissions`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as TestPermissionsResponse;
  }

  /**
   * Retrieves an aggregated list of node types.
   *
   * @param project Project ID for this request.
   */
  async nodeTypesAggregatedList(project: string, opts: NodeTypesAggregatedListOptions = {}): Promise<NodeTypeAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/nodeTypes`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNodeTypeAggregatedList(data);
  }

  /**
   * Returns the specified node type.
   *
   * @param nodeType Name of the node type to return.
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async nodeTypesGet(nodeType: string, project: string, zone: string): Promise<NodeType> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/nodeTypes/${ nodeType }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNodeType(data);
  }

  /**
   * Retrieves a list of node types available to the specified project.
   *
   * @param project Project ID for this request.
   * @param zone The name of the zone for this request.
   */
  async nodeTypesList(project: string, zone: string, opts: NodeTypesListOptions = {}): Promise<NodeTypeList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/nodeTypes`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNodeTypeList(data);
  }

  /**
   * Retrieves an aggregated list of packetMirrorings.
   *
   * @param project Project ID for this request.
   */
  async packetMirroringsAggregatedList(project: string, opts: PacketMirroringsAggregatedListOptions = {}): Promise<PacketMirroringAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/packetMirrorings`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePacketMirroringAggregatedList(data);
  }

  /**
   * Deletes the specified PacketMirroring resource.
   *
   * @param packetMirroring Name of the PacketMirroring resource to delete.
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async packetMirroringsDelete(packetMirroring: string, project: string, region: string, opts: PacketMirroringsDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/packetMirrorings/${ packetMirroring }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified PacketMirroring resource.
   *
   * @param packetMirroring Name of the PacketMirroring resource to return.
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async packetMirroringsGet(packetMirroring: string, project: string, region: string): Promise<PacketMirroring> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/packetMirrorings/${ packetMirroring }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePacketMirroring(data);
  }

  /**
   * Creates a PacketMirroring resource in the specified project and region
   * using the data included in the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async packetMirroringsInsert(project: string, region: string, req: PacketMirroring, opts: PacketMirroringsInsertOptions = {}): Promise<Operation> {
    req = serializePacketMirroring(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/packetMirrorings`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of PacketMirroring resources available to the specified
   * project and region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async packetMirroringsList(project: string, region: string, opts: PacketMirroringsListOptions = {}): Promise<PacketMirroringList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/packetMirrorings`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePacketMirroringList(data);
  }

  /**
   * Patches the specified PacketMirroring resource with the data included in
   * the request. This method supports PATCH semantics and uses JSON merge patch
   * format and processing rules.
   *
   * @param packetMirroring Name of the PacketMirroring resource to patch.
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async packetMirroringsPatch(packetMirroring: string, project: string, region: string, req: PacketMirroring, opts: PacketMirroringsPatchOptions = {}): Promise<Operation> {
    req = serializePacketMirroring(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/packetMirrorings/${ packetMirroring }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Returns permissions that a caller has on the specified resource.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async packetMirroringsTestIamPermissions(project: string, region: string, resource: string, req: TestPermissionsRequest): Promise<TestPermissionsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/packetMirrorings/${ resource }/testIamPermissions`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as TestPermissionsResponse;
  }

  /**
   * Disable this project as a shared VPC host project.
   *
   * @param project Project ID for this request.
   */
  async projectsDisableXpnHost(project: string, opts: ProjectsDisableXpnHostOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/disableXpnHost`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Disable a service resource (also known as service project) associated with
   * this host project.
   *
   * @param project Project ID for this request.
   */
  async projectsDisableXpnResource(project: string, req: ProjectsDisableXpnResourceRequest, opts: ProjectsDisableXpnResourceOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/disableXpnResource`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Enable this project as a shared VPC host project.
   *
   * @param project Project ID for this request.
   */
  async projectsEnableXpnHost(project: string, opts: ProjectsEnableXpnHostOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/enableXpnHost`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Enable service resource (a.k.a service project) for a host project, so
   * that subnets in the host project can be used by instances in the service
   * project.
   *
   * @param project Project ID for this request.
   */
  async projectsEnableXpnResource(project: string, req: ProjectsEnableXpnResourceRequest, opts: ProjectsEnableXpnResourceOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/enableXpnResource`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified Project resource. To decrease latency for this
   * method, you can optionally omit any unneeded information from the response
   * by using a field mask. This practice is especially recommended for unused
   * quota information (the `quotas` field). To exclude one or more fields, set
   * your request's `fields` query parameter to only include the fields you
   * need. For example, to only include the `id` and `selfLink` fields, add the
   * query parameter `?fields=id,selfLink` to your request.
   *
   * @param project Project ID for this request.
   */
  async projectsGet(project: string): Promise<Project> {
    const url = new URL(`${this.#baseUrl}projects/${ project }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeProject(data);
  }

  /**
   * Gets the shared VPC host project that this project links to. May be empty
   * if no link exists.
   *
   * @param project Project ID for this request.
   */
  async projectsGetXpnHost(project: string): Promise<Project> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/getXpnHost`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeProject(data);
  }

  /**
   * Gets service resources (a.k.a service project) associated with this host
   * project.
   *
   * @param project Project ID for this request.
   */
  async projectsGetXpnResources(project: string, opts: ProjectsGetXpnResourcesOptions = {}): Promise<ProjectsGetXpnResources> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/getXpnResources`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return data as ProjectsGetXpnResources;
  }

  /**
   * Lists all shared VPC host projects visible to the user in an organization.
   *
   * @param project Project ID for this request.
   */
  async projectsListXpnHosts(project: string, req: ProjectsListXpnHostsRequest, opts: ProjectsListXpnHostsOptions = {}): Promise<XpnHostList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/listXpnHosts`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeXpnHostList(data);
  }

  /**
   * Moves a persistent disk from one zone to another.
   *
   * @param project Project ID for this request.
   */
  async projectsMoveDisk(project: string, req: DiskMoveRequest, opts: ProjectsMoveDiskOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/moveDisk`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Moves an instance and its attached persistent disks from one zone to
   * another. *Note*: Moving VMs or disks by using this method might cause
   * unexpected behavior. For more information, see the [known
   * issue](/compute/docs/troubleshooting/known-issues#moving_vms_or_disks_using_the_moveinstance_api_or_the_causes_unexpected_behavior).
   *
   * @param project Project ID for this request.
   */
  async projectsMoveInstance(project: string, req: InstanceMoveRequest, opts: ProjectsMoveInstanceOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/moveInstance`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets metadata common to all instances within the specified project using
   * the data included in the request.
   *
   * @param project Project ID for this request.
   */
  async projectsSetCommonInstanceMetadata(project: string, req: Metadata, opts: ProjectsSetCommonInstanceMetadataOptions = {}): Promise<Operation> {
    req = serializeMetadata(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/setCommonInstanceMetadata`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the default network tier of the project. The default network tier is
   * used when an address/forwardingRule/instance is created without specifying
   * the network tier field.
   *
   * @param project Project ID for this request.
   */
  async projectsSetDefaultNetworkTier(project: string, req: ProjectsSetDefaultNetworkTierRequest, opts: ProjectsSetDefaultNetworkTierOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/setDefaultNetworkTier`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Enables the usage export feature and sets the usage export bucket where
   * reports are stored. If you provide an empty request body using this method,
   * the usage export feature will be disabled.
   *
   * @param project Project ID for this request.
   */
  async projectsSetUsageExportBucket(project: string, req: UsageExportLocation, opts: ProjectsSetUsageExportBucketOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/setUsageExportBucket`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified PublicAdvertisedPrefix
   *
   * @param project Project ID for this request.
   * @param publicAdvertisedPrefix Name of the PublicAdvertisedPrefix resource to delete.
   */
  async publicAdvertisedPrefixesDelete(project: string, publicAdvertisedPrefix: string, opts: PublicAdvertisedPrefixesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/publicAdvertisedPrefixes/${ publicAdvertisedPrefix }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified PublicAdvertisedPrefix resource.
   *
   * @param project Project ID for this request.
   * @param publicAdvertisedPrefix Name of the PublicAdvertisedPrefix resource to return.
   */
  async publicAdvertisedPrefixesGet(project: string, publicAdvertisedPrefix: string): Promise<PublicAdvertisedPrefix> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/publicAdvertisedPrefixes/${ publicAdvertisedPrefix }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePublicAdvertisedPrefix(data);
  }

  /**
   * Creates a PublicAdvertisedPrefix in the specified project using the
   * parameters that are included in the request.
   *
   * @param project Project ID for this request.
   */
  async publicAdvertisedPrefixesInsert(project: string, req: PublicAdvertisedPrefix, opts: PublicAdvertisedPrefixesInsertOptions = {}): Promise<Operation> {
    req = serializePublicAdvertisedPrefix(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/publicAdvertisedPrefixes`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Lists the PublicAdvertisedPrefixes for a project.
   *
   * @param project Project ID for this request.
   */
  async publicAdvertisedPrefixesList(project: string, opts: PublicAdvertisedPrefixesListOptions = {}): Promise<PublicAdvertisedPrefixList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/publicAdvertisedPrefixes`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePublicAdvertisedPrefixList(data);
  }

  /**
   * Patches the specified Router resource with the data included in the
   * request. This method supports PATCH semantics and uses JSON merge patch
   * format and processing rules.
   *
   * @param project Project ID for this request.
   * @param publicAdvertisedPrefix Name of the PublicAdvertisedPrefix resource to patch.
   */
  async publicAdvertisedPrefixesPatch(project: string, publicAdvertisedPrefix: string, req: PublicAdvertisedPrefix, opts: PublicAdvertisedPrefixesPatchOptions = {}): Promise<Operation> {
    req = serializePublicAdvertisedPrefix(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/publicAdvertisedPrefixes/${ publicAdvertisedPrefix }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Lists all PublicDelegatedPrefix resources owned by the specific project
   * across all scopes.
   *
   * @param project Name of the project scoping this request.
   */
  async publicDelegatedPrefixesAggregatedList(project: string, opts: PublicDelegatedPrefixesAggregatedListOptions = {}): Promise<PublicDelegatedPrefixAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/publicDelegatedPrefixes`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePublicDelegatedPrefixAggregatedList(data);
  }

  /**
   * Deletes the specified PublicDelegatedPrefix in the given region.
   *
   * @param project Project ID for this request.
   * @param publicDelegatedPrefix Name of the PublicDelegatedPrefix resource to delete.
   * @param region Name of the region of this request.
   */
  async publicDelegatedPrefixesDelete(project: string, publicDelegatedPrefix: string, region: string, opts: PublicDelegatedPrefixesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/publicDelegatedPrefixes/${ publicDelegatedPrefix }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified PublicDelegatedPrefix resource in the given region.
   *
   * @param project Project ID for this request.
   * @param publicDelegatedPrefix Name of the PublicDelegatedPrefix resource to return.
   * @param region Name of the region of this request.
   */
  async publicDelegatedPrefixesGet(project: string, publicDelegatedPrefix: string, region: string): Promise<PublicDelegatedPrefix> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/publicDelegatedPrefixes/${ publicDelegatedPrefix }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePublicDelegatedPrefix(data);
  }

  /**
   * Creates a PublicDelegatedPrefix in the specified project in the given
   * region using the parameters that are included in the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region of this request.
   */
  async publicDelegatedPrefixesInsert(project: string, region: string, req: PublicDelegatedPrefix, opts: PublicDelegatedPrefixesInsertOptions = {}): Promise<Operation> {
    req = serializePublicDelegatedPrefix(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/publicDelegatedPrefixes`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Lists the PublicDelegatedPrefixes for a project in the given region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region of this request.
   */
  async publicDelegatedPrefixesList(project: string, region: string, opts: PublicDelegatedPrefixesListOptions = {}): Promise<PublicDelegatedPrefixList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/publicDelegatedPrefixes`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePublicDelegatedPrefixList(data);
  }

  /**
   * Patches the specified PublicDelegatedPrefix resource with the data
   * included in the request. This method supports PATCH semantics and uses JSON
   * merge patch format and processing rules.
   *
   * @param project Project ID for this request.
   * @param publicDelegatedPrefix Name of the PublicDelegatedPrefix resource to patch.
   * @param region Name of the region for this request.
   */
  async publicDelegatedPrefixesPatch(project: string, publicDelegatedPrefix: string, region: string, req: PublicDelegatedPrefix, opts: PublicDelegatedPrefixesPatchOptions = {}): Promise<Operation> {
    req = serializePublicDelegatedPrefix(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/publicDelegatedPrefixes/${ publicDelegatedPrefix }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified autoscaler.
   *
   * @param autoscaler Name of the autoscaler to delete.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionAutoscalersDelete(autoscaler: string, project: string, region: string, opts: RegionAutoscalersDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/autoscalers/${ autoscaler }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified autoscaler.
   *
   * @param autoscaler Name of the autoscaler to return.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionAutoscalersGet(autoscaler: string, project: string, region: string): Promise<Autoscaler> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/autoscalers/${ autoscaler }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeAutoscaler(data);
  }

  /**
   * Creates an autoscaler in the specified project using the data included in
   * the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionAutoscalersInsert(project: string, region: string, req: Autoscaler, opts: RegionAutoscalersInsertOptions = {}): Promise<Operation> {
    req = serializeAutoscaler(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/autoscalers`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of autoscalers contained within the specified region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionAutoscalersList(project: string, region: string, opts: RegionAutoscalersListOptions = {}): Promise<RegionAutoscalerList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/autoscalers`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeRegionAutoscalerList(data);
  }

  /**
   * Updates an autoscaler in the specified project using the data included in
   * the request. This method supports PATCH semantics and uses the JSON merge
   * patch format and processing rules.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionAutoscalersPatch(project: string, region: string, req: Autoscaler, opts: RegionAutoscalersPatchOptions = {}): Promise<Operation> {
    req = serializeAutoscaler(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/autoscalers`);
    if (opts.autoscaler !== undefined) {
      url.searchParams.append("autoscaler", String(opts.autoscaler));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Updates an autoscaler in the specified project using the data included in
   * the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionAutoscalersUpdate(project: string, region: string, req: Autoscaler, opts: RegionAutoscalersUpdateOptions = {}): Promise<Operation> {
    req = serializeAutoscaler(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/autoscalers`);
    if (opts.autoscaler !== undefined) {
      url.searchParams.append("autoscaler", String(opts.autoscaler));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PUT",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified regional BackendService resource.
   *
   * @param backendService Name of the BackendService resource to delete.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionBackendServicesDelete(backendService: string, project: string, region: string, opts: RegionBackendServicesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/backendServices/${ backendService }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified regional BackendService resource.
   *
   * @param backendService Name of the BackendService resource to return.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionBackendServicesGet(backendService: string, project: string, region: string): Promise<BackendService> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/backendServices/${ backendService }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeBackendService(data);
  }

  /**
   * Gets the most recent health check results for this regional
   * BackendService.
   *
   * @param backendService Name of the BackendService resource for which to get health.
   * @param region Name of the region scoping this request.
   */
  async regionBackendServicesGetHealth(backendService: string, project: string, region: string, req: ResourceGroupReference): Promise<BackendServiceGroupHealth> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/backendServices/${ backendService }/getHealth`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as BackendServiceGroupHealth;
  }

  /**
   * Gets the access control policy for a resource. May be empty if no such
   * policy or resource exists.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async regionBackendServicesGetIamPolicy(project: string, region: string, resource: string, opts: RegionBackendServicesGetIamPolicyOptions = {}): Promise<Policy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/backendServices/${ resource }/getIamPolicy`);
    if (opts.optionsRequestedPolicyVersion !== undefined) {
      url.searchParams.append("optionsRequestedPolicyVersion", String(opts.optionsRequestedPolicyVersion));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePolicy(data);
  }

  /**
   * Creates a regional BackendService resource in the specified project using
   * the data included in the request. For more information, see Backend
   * services overview.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionBackendServicesInsert(project: string, region: string, req: BackendService, opts: RegionBackendServicesInsertOptions = {}): Promise<Operation> {
    req = serializeBackendService(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/backendServices`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of regional BackendService resources available to the
   * specified project in the given region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionBackendServicesList(project: string, region: string, opts: RegionBackendServicesListOptions = {}): Promise<BackendServiceList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/backendServices`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeBackendServiceList(data);
  }

  /**
   * Updates the specified regional BackendService resource with the data
   * included in the request. For more information, see Understanding backend
   * services This method supports PATCH semantics and uses the JSON merge patch
   * format and processing rules.
   *
   * @param backendService Name of the BackendService resource to patch.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionBackendServicesPatch(backendService: string, project: string, region: string, req: BackendService, opts: RegionBackendServicesPatchOptions = {}): Promise<Operation> {
    req = serializeBackendService(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/backendServices/${ backendService }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async regionBackendServicesSetIamPolicy(project: string, region: string, resource: string, req: RegionSetPolicyRequest): Promise<Policy> {
    req = serializeRegionSetPolicyRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/backendServices/${ resource }/setIamPolicy`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializePolicy(data);
  }

  /**
   * Updates the specified regional BackendService resource with the data
   * included in the request. For more information, see Backend services
   * overview .
   *
   * @param backendService Name of the BackendService resource to update.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionBackendServicesUpdate(backendService: string, project: string, region: string, req: BackendService, opts: RegionBackendServicesUpdateOptions = {}): Promise<Operation> {
    req = serializeBackendService(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/backendServices/${ backendService }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PUT",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves an aggregated list of commitments by region.
   *
   * @param project Project ID for this request.
   */
  async regionCommitmentsAggregatedList(project: string, opts: RegionCommitmentsAggregatedListOptions = {}): Promise<CommitmentAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/commitments`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeCommitmentAggregatedList(data);
  }

  /**
   * Returns the specified commitment resource.
   *
   * @param commitment Name of the commitment to return.
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async regionCommitmentsGet(commitment: string, project: string, region: string): Promise<Commitment> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/commitments/${ commitment }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeCommitment(data);
  }

  /**
   * Creates a commitment in the specified project using the data included in
   * the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async regionCommitmentsInsert(project: string, region: string, req: Commitment, opts: RegionCommitmentsInsertOptions = {}): Promise<Operation> {
    req = serializeCommitment(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/commitments`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of commitments contained within the specified region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async regionCommitmentsList(project: string, region: string, opts: RegionCommitmentsListOptions = {}): Promise<CommitmentList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/commitments`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeCommitmentList(data);
  }

  /**
   * Updates the specified commitment with the data included in the request.
   * Update is performed only on selected fields included as part of
   * update-mask. Only the following fields can be modified: auto_renew.
   *
   * @param commitment Name of the commitment for which auto renew is being updated.
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async regionCommitmentsUpdate(commitment: string, project: string, region: string, req: Commitment, opts: RegionCommitmentsUpdateOptions = {}): Promise<Operation> {
    req = serializeCommitment(req);
    opts = serializeRegionCommitmentsUpdateOptions(opts);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/commitments/${ commitment }`);
    if (opts.paths !== undefined) {
      url.searchParams.append("paths", String(opts.paths));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    if (opts.updateMask !== undefined) {
      url.searchParams.append("updateMask", String(opts.updateMask));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Adds existing resource policies to a regional disk. You can only add one
   * policy which will be applied to this disk for scheduling snapshot creation.
   *
   * @param disk The disk name for this request.
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   */
  async regionDisksAddResourcePolicies(disk: string, project: string, region: string, req: RegionDisksAddResourcePoliciesRequest, opts: RegionDisksAddResourcePoliciesOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/disks/${ disk }/addResourcePolicies`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Creates a snapshot of a specified persistent disk. For regular snapshot
   * creation, consider using snapshots.insert instead, as that method supports
   * more features, such as creating snapshots in a project different from the
   * source disk project.
   *
   * @param disk Name of the regional persistent disk to snapshot.
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async regionDisksCreateSnapshot(disk: string, project: string, region: string, req: Snapshot, opts: RegionDisksCreateSnapshotOptions = {}): Promise<Operation> {
    req = serializeSnapshot(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/disks/${ disk }/createSnapshot`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified regional persistent disk. Deleting a regional disk
   * removes all the replicas of its data permanently and is irreversible.
   * However, deleting a disk does not delete any snapshots previously made from
   * the disk. You must separately delete snapshots.
   *
   * @param disk Name of the regional persistent disk to delete.
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async regionDisksDelete(disk: string, project: string, region: string, opts: RegionDisksDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/disks/${ disk }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns a specified regional persistent disk.
   *
   * @param disk Name of the regional persistent disk to return.
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async regionDisksGet(disk: string, project: string, region: string): Promise<Disk> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/disks/${ disk }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeDisk(data);
  }

  /**
   * Gets the access control policy for a resource. May be empty if no such
   * policy or resource exists.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async regionDisksGetIamPolicy(project: string, region: string, resource: string, opts: RegionDisksGetIamPolicyOptions = {}): Promise<Policy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/disks/${ resource }/getIamPolicy`);
    if (opts.optionsRequestedPolicyVersion !== undefined) {
      url.searchParams.append("optionsRequestedPolicyVersion", String(opts.optionsRequestedPolicyVersion));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePolicy(data);
  }

  /**
   * Creates a persistent regional disk in the specified project using the data
   * included in the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async regionDisksInsert(project: string, region: string, req: Disk, opts: RegionDisksInsertOptions = {}): Promise<Operation> {
    req = serializeDisk(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/disks`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    if (opts.sourceImage !== undefined) {
      url.searchParams.append("sourceImage", String(opts.sourceImage));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of persistent disks contained within the specified
   * region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async regionDisksList(project: string, region: string, opts: RegionDisksListOptions = {}): Promise<DiskList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/disks`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeDiskList(data);
  }

  /**
   * Removes resource policies from a regional disk.
   *
   * @param disk The disk name for this request.
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   */
  async regionDisksRemoveResourcePolicies(disk: string, project: string, region: string, req: RegionDisksRemoveResourcePoliciesRequest, opts: RegionDisksRemoveResourcePoliciesOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/disks/${ disk }/removeResourcePolicies`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Resizes the specified regional persistent disk.
   *
   * @param disk Name of the regional persistent disk.
   * @param project The project ID for this request.
   * @param region Name of the region for this request.
   */
  async regionDisksResize(disk: string, project: string, region: string, req: RegionDisksResizeRequest, opts: RegionDisksResizeOptions = {}): Promise<Operation> {
    req = serializeRegionDisksResizeRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/disks/${ disk }/resize`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async regionDisksSetIamPolicy(project: string, region: string, resource: string, req: RegionSetPolicyRequest): Promise<Policy> {
    req = serializeRegionSetPolicyRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/disks/${ resource }/setIamPolicy`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializePolicy(data);
  }

  /**
   * Sets the labels on the target regional disk.
   *
   * @param project Project ID for this request.
   * @param region The region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async regionDisksSetLabels(project: string, region: string, resource: string, req: RegionSetLabelsRequest, opts: RegionDisksSetLabelsOptions = {}): Promise<Operation> {
    req = serializeRegionSetLabelsRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/disks/${ resource }/setLabels`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Returns permissions that a caller has on the specified resource.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async regionDisksTestIamPermissions(project: string, region: string, resource: string, req: TestPermissionsRequest): Promise<TestPermissionsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/disks/${ resource }/testIamPermissions`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as TestPermissionsResponse;
  }

  /**
   * Update the specified disk with the data included in the request. Update is
   * performed only on selected fields included as part of update-mask. Only the
   * following fields can be modified: user_license.
   *
   * @param disk The disk name for this request.
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   */
  async regionDisksUpdate(disk: string, project: string, region: string, req: Disk, opts: RegionDisksUpdateOptions = {}): Promise<Operation> {
    req = serializeDisk(req);
    opts = serializeRegionDisksUpdateOptions(opts);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/disks/${ disk }`);
    if (opts.paths !== undefined) {
      url.searchParams.append("paths", String(opts.paths));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    if (opts.updateMask !== undefined) {
      url.searchParams.append("updateMask", String(opts.updateMask));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified regional disk type.
   *
   * @param diskType Name of the disk type to return.
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   */
  async regionDiskTypesGet(diskType: string, project: string, region: string): Promise<DiskType> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/diskTypes/${ diskType }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeDiskType(data);
  }

  /**
   * Retrieves a list of regional disk types available to the specified
   * project.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   */
  async regionDiskTypesList(project: string, region: string, opts: RegionDiskTypesListOptions = {}): Promise<RegionDiskTypeList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/diskTypes`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeRegionDiskTypeList(data);
  }

  /**
   * Deletes the specified HealthCheck resource.
   *
   * @param healthCheck Name of the HealthCheck resource to delete.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionHealthChecksDelete(healthCheck: string, project: string, region: string, opts: RegionHealthChecksDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/healthChecks/${ healthCheck }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified regional HealthCheckService.
   *
   * @param healthCheckService Name of the HealthCheckService to delete. The name must be 1-63 characters long, and comply with RFC1035.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionHealthCheckServicesDelete(healthCheckService: string, project: string, region: string, opts: RegionHealthCheckServicesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/healthCheckServices/${ healthCheckService }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified regional HealthCheckService resource.
   *
   * @param healthCheckService Name of the HealthCheckService to update. The name must be 1-63 characters long, and comply with RFC1035.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionHealthCheckServicesGet(healthCheckService: string, project: string, region: string): Promise<HealthCheckService> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/healthCheckServices/${ healthCheckService }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeHealthCheckService(data);
  }

  /**
   * Creates a regional HealthCheckService resource in the specified project
   * and region using the data included in the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionHealthCheckServicesInsert(project: string, region: string, req: HealthCheckService, opts: RegionHealthCheckServicesInsertOptions = {}): Promise<Operation> {
    req = serializeHealthCheckService(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/healthCheckServices`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Lists all the HealthCheckService resources that have been configured for
   * the specified project in the given region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionHealthCheckServicesList(project: string, region: string, opts: RegionHealthCheckServicesListOptions = {}): Promise<HealthCheckServicesList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/healthCheckServices`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeHealthCheckServicesList(data);
  }

  /**
   * Updates the specified regional HealthCheckService resource with the data
   * included in the request. This method supports PATCH semantics and uses the
   * JSON merge patch format and processing rules.
   *
   * @param healthCheckService Name of the HealthCheckService to update. The name must be 1-63 characters long, and comply with RFC1035.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionHealthCheckServicesPatch(healthCheckService: string, project: string, region: string, req: HealthCheckService, opts: RegionHealthCheckServicesPatchOptions = {}): Promise<Operation> {
    req = serializeHealthCheckService(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/healthCheckServices/${ healthCheckService }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified HealthCheck resource.
   *
   * @param healthCheck Name of the HealthCheck resource to return.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionHealthChecksGet(healthCheck: string, project: string, region: string): Promise<HealthCheck> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/healthChecks/${ healthCheck }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeHealthCheck(data);
  }

  /**
   * Creates a HealthCheck resource in the specified project using the data
   * included in the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionHealthChecksInsert(project: string, region: string, req: HealthCheck, opts: RegionHealthChecksInsertOptions = {}): Promise<Operation> {
    req = serializeHealthCheck(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/healthChecks`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of HealthCheck resources available to the specified
   * project.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionHealthChecksList(project: string, region: string, opts: RegionHealthChecksListOptions = {}): Promise<HealthCheckList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/healthChecks`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeHealthCheckList(data);
  }

  /**
   * Updates a HealthCheck resource in the specified project using the data
   * included in the request. This method supports PATCH semantics and uses the
   * JSON merge patch format and processing rules.
   *
   * @param healthCheck Name of the HealthCheck resource to patch.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionHealthChecksPatch(healthCheck: string, project: string, region: string, req: HealthCheck, opts: RegionHealthChecksPatchOptions = {}): Promise<Operation> {
    req = serializeHealthCheck(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/healthChecks/${ healthCheck }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Updates a HealthCheck resource in the specified project using the data
   * included in the request.
   *
   * @param healthCheck Name of the HealthCheck resource to update.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionHealthChecksUpdate(healthCheck: string, project: string, region: string, req: HealthCheck, opts: RegionHealthChecksUpdateOptions = {}): Promise<Operation> {
    req = serializeHealthCheck(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/healthChecks/${ healthCheck }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PUT",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Flags the specified instances to be immediately removed from the managed
   * instance group. Abandoning an instance does not delete the instance, but it
   * does remove the instance from any target pools that are applied by the
   * managed instance group. This method reduces the targetSize of the managed
   * instance group by the number of instances that you abandon. This operation
   * is marked as DONE when the action is scheduled even if the instances have
   * not yet been removed from the group. You must separately verify the status
   * of the abandoning action with the listmanagedinstances method. If the group
   * is part of a backend service that has enabled connection draining, it can
   * take up to 60 seconds after the connection draining duration has elapsed
   * before the VM instance is removed or deleted. You can specify a maximum of
   * 1000 instances with this method per request.
   *
   * @param instanceGroupManager Name of the managed instance group.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionInstanceGroupManagersAbandonInstances(instanceGroupManager: string, project: string, region: string, req: RegionInstanceGroupManagersAbandonInstancesRequest, opts: RegionInstanceGroupManagersAbandonInstancesOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceGroupManagers/${ instanceGroupManager }/abandonInstances`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Apply updates to selected instances the managed instance group.
   *
   * @param instanceGroupManager The name of the managed instance group, should conform to RFC1035.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request, should conform to RFC1035.
   */
  async regionInstanceGroupManagersApplyUpdatesToInstances(instanceGroupManager: string, project: string, region: string, req: RegionInstanceGroupManagersApplyUpdatesRequest): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceGroupManagers/${ instanceGroupManager }/applyUpdatesToInstances`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Creates instances with per-instance configurations in this regional
   * managed instance group. Instances are created using the current instance
   * template. The create instances operation is marked DONE if the
   * createInstances request is successful. The underlying actions take
   * additional time. You must separately verify the status of the creating or
   * actions with the listmanagedinstances method.
   *
   * @param instanceGroupManager The name of the managed instance group. It should conform to RFC1035.
   * @param project Project ID for this request.
   * @param region The name of the region where the managed instance group is located. It should conform to RFC1035.
   */
  async regionInstanceGroupManagersCreateInstances(instanceGroupManager: string, project: string, region: string, req: RegionInstanceGroupManagersCreateInstancesRequest, opts: RegionInstanceGroupManagersCreateInstancesOptions = {}): Promise<Operation> {
    req = serializeRegionInstanceGroupManagersCreateInstancesRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceGroupManagers/${ instanceGroupManager }/createInstances`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified managed instance group and all of the instances in
   * that group.
   *
   * @param instanceGroupManager Name of the managed instance group to delete.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionInstanceGroupManagersDelete(instanceGroupManager: string, project: string, region: string, opts: RegionInstanceGroupManagersDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceGroupManagers/${ instanceGroupManager }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Flags the specified instances in the managed instance group to be
   * immediately deleted. The instances are also removed from any target pools
   * of which they were a member. This method reduces the targetSize of the
   * managed instance group by the number of instances that you delete. The
   * deleteInstances operation is marked DONE if the deleteInstances request is
   * successful. The underlying actions take additional time. You must
   * separately verify the status of the deleting action with the
   * listmanagedinstances method. If the group is part of a backend service that
   * has enabled connection draining, it can take up to 60 seconds after the
   * connection draining duration has elapsed before the VM instance is removed
   * or deleted. You can specify a maximum of 1000 instances with this method
   * per request.
   *
   * @param instanceGroupManager Name of the managed instance group.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionInstanceGroupManagersDeleteInstances(instanceGroupManager: string, project: string, region: string, req: RegionInstanceGroupManagersDeleteInstancesRequest, opts: RegionInstanceGroupManagersDeleteInstancesOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceGroupManagers/${ instanceGroupManager }/deleteInstances`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes selected per-instance configurations for the managed instance
   * group.
   *
   * @param instanceGroupManager The name of the managed instance group. It should conform to RFC1035.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request, should conform to RFC1035.
   */
  async regionInstanceGroupManagersDeletePerInstanceConfigs(instanceGroupManager: string, project: string, region: string, req: RegionInstanceGroupManagerDeleteInstanceConfigReq): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceGroupManagers/${ instanceGroupManager }/deletePerInstanceConfigs`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Returns all of the details about the specified managed instance group.
   *
   * @param instanceGroupManager Name of the managed instance group to return.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionInstanceGroupManagersGet(instanceGroupManager: string, project: string, region: string): Promise<InstanceGroupManager> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceGroupManagers/${ instanceGroupManager }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeInstanceGroupManager(data);
  }

  /**
   * Creates a managed instance group using the information that you specify in
   * the request. After the group is created, instances in the group are created
   * using the specified instance template. This operation is marked as DONE
   * when the group is created even if the instances in the group have not yet
   * been created. You must separately verify the status of the individual
   * instances with the listmanagedinstances method. A regional managed instance
   * group can contain up to 2000 instances.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionInstanceGroupManagersInsert(project: string, region: string, req: InstanceGroupManager, opts: RegionInstanceGroupManagersInsertOptions = {}): Promise<Operation> {
    req = serializeInstanceGroupManager(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceGroupManagers`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of managed instance groups that are contained within
   * the specified region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionInstanceGroupManagersList(project: string, region: string, opts: RegionInstanceGroupManagersListOptions = {}): Promise<RegionInstanceGroupManagerList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceGroupManagers`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeRegionInstanceGroupManagerList(data);
  }

  /**
   * Lists all errors thrown by actions on instances for a given regional
   * managed instance group. The filter and orderBy query parameters are not
   * supported.
   *
   * @param instanceGroupManager The name of the managed instance group. It must be a string that meets the requirements in RFC1035, or an unsigned long integer: must match regexp pattern: (?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?)|1-9{0,19}.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request. This should conform to RFC1035.
   */
  async regionInstanceGroupManagersListErrors(instanceGroupManager: string, project: string, region: string, opts: RegionInstanceGroupManagersListErrorsOptions = {}): Promise<RegionInstanceGroupManagersListErrorsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceGroupManagers/${ instanceGroupManager }/listErrors`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return data as RegionInstanceGroupManagersListErrorsResponse;
  }

  /**
   * Lists the instances in the managed instance group and instances that are
   * scheduled to be created. The list includes any current actions that the
   * group has scheduled for its instances. The orderBy query parameter is not
   * supported. The `pageToken` query parameter is supported only in the alpha
   * and beta API and only if the group's `listManagedInstancesResults` field is
   * set to `PAGINATED`.
   *
   * @param instanceGroupManager The name of the managed instance group.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionInstanceGroupManagersListManagedInstances(instanceGroupManager: string, project: string, region: string, opts: RegionInstanceGroupManagersListManagedInstancesOptions = {}): Promise<RegionInstanceGroupManagersListInstancesResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceGroupManagers/${ instanceGroupManager }/listManagedInstances`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeRegionInstanceGroupManagersListInstancesResponse(data);
  }

  /**
   * Lists all of the per-instance configurations defined for the managed
   * instance group. The orderBy query parameter is not supported.
   *
   * @param instanceGroupManager The name of the managed instance group. It should conform to RFC1035.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request, should conform to RFC1035.
   */
  async regionInstanceGroupManagersListPerInstanceConfigs(instanceGroupManager: string, project: string, region: string, opts: RegionInstanceGroupManagersListPerInstanceConfigsOptions = {}): Promise<RegionInstanceGroupManagersListInstanceConfigsResp> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceGroupManagers/${ instanceGroupManager }/listPerInstanceConfigs`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeRegionInstanceGroupManagersListInstanceConfigsResp(data);
  }

  /**
   * Updates a managed instance group using the information that you specify in
   * the request. This operation is marked as DONE when the group is patched
   * even if the instances in the group are still in the process of being
   * patched. You must separately verify the status of the individual instances
   * with the listmanagedinstances method. This method supports PATCH semantics
   * and uses the JSON merge patch format and processing rules. If you update
   * your group to specify a new template or instance configuration, it's
   * possible that your intended specification for each VM in the group is
   * different from the current state of that VM. To learn how to apply an
   * updated configuration to the VMs in a MIG, see Updating instances in a MIG.
   *
   * @param instanceGroupManager The name of the instance group manager.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionInstanceGroupManagersPatch(instanceGroupManager: string, project: string, region: string, req: InstanceGroupManager, opts: RegionInstanceGroupManagersPatchOptions = {}): Promise<Operation> {
    req = serializeInstanceGroupManager(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceGroupManagers/${ instanceGroupManager }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Inserts or patches per-instance configurations for the managed instance
   * group. perInstanceConfig.name serves as a key used to distinguish whether
   * to perform insert or patch.
   *
   * @param instanceGroupManager The name of the managed instance group. It should conform to RFC1035.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request, should conform to RFC1035.
   */
  async regionInstanceGroupManagersPatchPerInstanceConfigs(instanceGroupManager: string, project: string, region: string, req: RegionInstanceGroupManagerPatchInstanceConfigReq, opts: RegionInstanceGroupManagersPatchPerInstanceConfigsOptions = {}): Promise<Operation> {
    req = serializeRegionInstanceGroupManagerPatchInstanceConfigReq(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceGroupManagers/${ instanceGroupManager }/patchPerInstanceConfigs`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Flags the specified VM instances in the managed instance group to be
   * immediately recreated. Each instance is recreated using the group's current
   * configuration. This operation is marked as DONE when the flag is set even
   * if the instances have not yet been recreated. You must separately verify
   * the status of each instance by checking its currentAction field; for more
   * information, see Checking the status of managed instances. If the group is
   * part of a backend service that has enabled connection draining, it can take
   * up to 60 seconds after the connection draining duration has elapsed before
   * the VM instance is removed or deleted. You can specify a maximum of 1000
   * instances with this method per request.
   *
   * @param instanceGroupManager Name of the managed instance group.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionInstanceGroupManagersRecreateInstances(instanceGroupManager: string, project: string, region: string, req: RegionInstanceGroupManagersRecreateRequest, opts: RegionInstanceGroupManagersRecreateInstancesOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceGroupManagers/${ instanceGroupManager }/recreateInstances`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Changes the intended size of the managed instance group. If you increase
   * the size, the group creates new instances using the current instance
   * template. If you decrease the size, the group deletes one or more
   * instances. The resize operation is marked DONE if the resize request is
   * successful. The underlying actions take additional time. You must
   * separately verify the status of the creating or deleting actions with the
   * listmanagedinstances method. If the group is part of a backend service that
   * has enabled connection draining, it can take up to 60 seconds after the
   * connection draining duration has elapsed before the VM instance is removed
   * or deleted.
   *
   * @param instanceGroupManager Name of the managed instance group.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionInstanceGroupManagersResize(instanceGroupManager: string, project: string, region: string, opts: RegionInstanceGroupManagersResizeOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceGroupManagers/${ instanceGroupManager }/resize`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    if (opts.size !== undefined) {
      url.searchParams.append("size", String(opts.size));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the instance template to use when creating new instances or
   * recreating instances in this group. Existing instances are not affected.
   *
   * @param instanceGroupManager The name of the managed instance group.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionInstanceGroupManagersSetInstanceTemplate(instanceGroupManager: string, project: string, region: string, req: RegionInstanceGroupManagersSetTemplateRequest, opts: RegionInstanceGroupManagersSetInstanceTemplateOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceGroupManagers/${ instanceGroupManager }/setInstanceTemplate`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Modifies the target pools to which all new instances in this group are
   * assigned. Existing instances in the group are not affected.
   *
   * @param instanceGroupManager Name of the managed instance group.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionInstanceGroupManagersSetTargetPools(instanceGroupManager: string, project: string, region: string, req: RegionInstanceGroupManagersSetTargetPoolsRequest, opts: RegionInstanceGroupManagersSetTargetPoolsOptions = {}): Promise<Operation> {
    req = serializeRegionInstanceGroupManagersSetTargetPoolsRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceGroupManagers/${ instanceGroupManager }/setTargetPools`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Inserts or updates per-instance configurations for the managed instance
   * group. perInstanceConfig.name serves as a key used to distinguish whether
   * to perform insert or patch.
   *
   * @param instanceGroupManager The name of the managed instance group. It should conform to RFC1035.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request, should conform to RFC1035.
   */
  async regionInstanceGroupManagersUpdatePerInstanceConfigs(instanceGroupManager: string, project: string, region: string, req: RegionInstanceGroupManagerUpdateInstanceConfigReq, opts: RegionInstanceGroupManagersUpdatePerInstanceConfigsOptions = {}): Promise<Operation> {
    req = serializeRegionInstanceGroupManagerUpdateInstanceConfigReq(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceGroupManagers/${ instanceGroupManager }/updatePerInstanceConfigs`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified instance group resource.
   *
   * @param instanceGroup Name of the instance group resource to return.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionInstanceGroupsGet(instanceGroup: string, project: string, region: string): Promise<InstanceGroup> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceGroups/${ instanceGroup }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeInstanceGroup(data);
  }

  /**
   * Retrieves the list of instance group resources contained within the
   * specified region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionInstanceGroupsList(project: string, region: string, opts: RegionInstanceGroupsListOptions = {}): Promise<RegionInstanceGroupList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceGroups`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeRegionInstanceGroupList(data);
  }

  /**
   * Lists the instances in the specified instance group and displays
   * information about the named ports. Depending on the specified options, this
   * method can list all instances or only the instances that are running. The
   * orderBy query parameter is not supported.
   *
   * @param instanceGroup Name of the regional instance group for which we want to list the instances.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionInstanceGroupsListInstances(instanceGroup: string, project: string, region: string, req: RegionInstanceGroupsListInstancesRequest, opts: RegionInstanceGroupsListInstancesOptions = {}): Promise<RegionInstanceGroupsListInstances> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceGroups/${ instanceGroup }/listInstances`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as RegionInstanceGroupsListInstances;
  }

  /**
   * Sets the named ports for the specified regional instance group.
   *
   * @param instanceGroup The name of the regional instance group where the named ports are updated.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionInstanceGroupsSetNamedPorts(instanceGroup: string, project: string, region: string, req: RegionInstanceGroupsSetNamedPortsRequest, opts: RegionInstanceGroupsSetNamedPortsOptions = {}): Promise<Operation> {
    req = serializeRegionInstanceGroupsSetNamedPortsRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceGroups/${ instanceGroup }/setNamedPorts`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Creates multiple instances in a given region. Count specifies the number
   * of instances to create.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   */
  async regionInstancesBulkInsert(project: string, region: string, req: BulkInsertInstanceResource, opts: RegionInstancesBulkInsertOptions = {}): Promise<Operation> {
    req = serializeBulkInsertInstanceResource(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instances/bulkInsert`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified instance template. Deleting an instance template is
   * permanent and cannot be undone.
   *
   * @param instanceTemplate The name of the instance template to delete.
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   */
  async regionInstanceTemplatesDelete(instanceTemplate: string, project: string, region: string, opts: RegionInstanceTemplatesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceTemplates/${ instanceTemplate }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified instance template.
   *
   * @param instanceTemplate The name of the instance template.
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   */
  async regionInstanceTemplatesGet(instanceTemplate: string, project: string, region: string): Promise<InstanceTemplate> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceTemplates/${ instanceTemplate }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeInstanceTemplate(data);
  }

  /**
   * Creates an instance template in the specified project and region using the
   * global instance template whose URL is included in the request.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   */
  async regionInstanceTemplatesInsert(project: string, region: string, req: InstanceTemplate, opts: RegionInstanceTemplatesInsertOptions = {}): Promise<Operation> {
    req = serializeInstanceTemplate(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceTemplates`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of instance templates that are contained within the
   * specified project and region.
   *
   * @param project Project ID for this request.
   * @param region The name of the regions for this request.
   */
  async regionInstanceTemplatesList(project: string, region: string, opts: RegionInstanceTemplatesListOptions = {}): Promise<InstanceTemplateList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/instanceTemplates`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeInstanceTemplateList(data);
  }

  /**
   * Deletes the specified network endpoint group. Note that the NEG cannot be
   * deleted if it is configured as a backend of a backend service.
   *
   * @param networkEndpointGroup The name of the network endpoint group to delete. It should comply with RFC1035.
   * @param project Project ID for this request.
   * @param region The name of the region where the network endpoint group is located. It should comply with RFC1035.
   */
  async regionNetworkEndpointGroupsDelete(networkEndpointGroup: string, project: string, region: string, opts: RegionNetworkEndpointGroupsDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/networkEndpointGroups/${ networkEndpointGroup }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified network endpoint group.
   *
   * @param networkEndpointGroup The name of the network endpoint group. It should comply with RFC1035.
   * @param project Project ID for this request.
   * @param region The name of the region where the network endpoint group is located. It should comply with RFC1035.
   */
  async regionNetworkEndpointGroupsGet(networkEndpointGroup: string, project: string, region: string): Promise<NetworkEndpointGroup> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/networkEndpointGroups/${ networkEndpointGroup }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNetworkEndpointGroup(data);
  }

  /**
   * Creates a network endpoint group in the specified project using the
   * parameters that are included in the request.
   *
   * @param project Project ID for this request.
   * @param region The name of the region where you want to create the network endpoint group. It should comply with RFC1035.
   */
  async regionNetworkEndpointGroupsInsert(project: string, region: string, req: NetworkEndpointGroup, opts: RegionNetworkEndpointGroupsInsertOptions = {}): Promise<Operation> {
    req = serializeNetworkEndpointGroup(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/networkEndpointGroups`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of regional network endpoint groups available to the
   * specified project in the given region.
   *
   * @param project Project ID for this request.
   * @param region The name of the region where the network endpoint group is located. It should comply with RFC1035.
   */
  async regionNetworkEndpointGroupsList(project: string, region: string, opts: RegionNetworkEndpointGroupsListOptions = {}): Promise<NetworkEndpointGroupList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/networkEndpointGroups`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNetworkEndpointGroupList(data);
  }

  /**
   * Inserts an association for the specified network firewall policy.
   *
   * @param firewallPolicy Name of the firewall policy to update.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionNetworkFirewallPoliciesAddAssociation(firewallPolicy: string, project: string, region: string, req: FirewallPolicyAssociation, opts: RegionNetworkFirewallPoliciesAddAssociationOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/firewallPolicies/${ firewallPolicy }/addAssociation`);
    if (opts.replaceExistingAssociation !== undefined) {
      url.searchParams.append("replaceExistingAssociation", String(opts.replaceExistingAssociation));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Inserts a rule into a network firewall policy.
   *
   * @param firewallPolicy Name of the firewall policy to update.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionNetworkFirewallPoliciesAddRule(firewallPolicy: string, project: string, region: string, req: FirewallPolicyRule, opts: RegionNetworkFirewallPoliciesAddRuleOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/firewallPolicies/${ firewallPolicy }/addRule`);
    if (opts.maxPriority !== undefined) {
      url.searchParams.append("maxPriority", String(opts.maxPriority));
    }
    if (opts.minPriority !== undefined) {
      url.searchParams.append("minPriority", String(opts.minPriority));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Copies rules to the specified network firewall policy.
   *
   * @param firewallPolicy Name of the firewall policy to update.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionNetworkFirewallPoliciesCloneRules(firewallPolicy: string, project: string, region: string, opts: RegionNetworkFirewallPoliciesCloneRulesOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/firewallPolicies/${ firewallPolicy }/cloneRules`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    if (opts.sourceFirewallPolicy !== undefined) {
      url.searchParams.append("sourceFirewallPolicy", String(opts.sourceFirewallPolicy));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified network firewall policy.
   *
   * @param firewallPolicy Name of the firewall policy to delete.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionNetworkFirewallPoliciesDelete(firewallPolicy: string, project: string, region: string, opts: RegionNetworkFirewallPoliciesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/firewallPolicies/${ firewallPolicy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified network firewall policy.
   *
   * @param firewallPolicy Name of the firewall policy to get.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionNetworkFirewallPoliciesGet(firewallPolicy: string, project: string, region: string): Promise<FirewallPolicy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/firewallPolicies/${ firewallPolicy }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeFirewallPolicy(data);
  }

  /**
   * Gets an association with the specified name.
   *
   * @param firewallPolicy Name of the firewall policy to which the queried association belongs.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionNetworkFirewallPoliciesGetAssociation(firewallPolicy: string, project: string, region: string, opts: RegionNetworkFirewallPoliciesGetAssociationOptions = {}): Promise<FirewallPolicyAssociation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/firewallPolicies/${ firewallPolicy }/getAssociation`);
    if (opts.name !== undefined) {
      url.searchParams.append("name", String(opts.name));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return data as FirewallPolicyAssociation;
  }

  /**
   * Returns the effective firewalls on a given network.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionNetworkFirewallPoliciesGetEffectiveFirewalls(project: string, region: string, opts: RegionNetworkFirewallPoliciesGetEffectiveFirewallsOptions = {}): Promise<RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/firewallPolicies/getEffectiveFirewalls`);
    if (opts.network !== undefined) {
      url.searchParams.append("network", String(opts.network));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeRegionNetworkFirewallPoliciesGetEffectiveFirewallsResponse(data);
  }

  /**
   * Gets the access control policy for a resource. May be empty if no such
   * policy or resource exists.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async regionNetworkFirewallPoliciesGetIamPolicy(project: string, region: string, resource: string, opts: RegionNetworkFirewallPoliciesGetIamPolicyOptions = {}): Promise<Policy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/firewallPolicies/${ resource }/getIamPolicy`);
    if (opts.optionsRequestedPolicyVersion !== undefined) {
      url.searchParams.append("optionsRequestedPolicyVersion", String(opts.optionsRequestedPolicyVersion));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePolicy(data);
  }

  /**
   * Gets a rule of the specified priority.
   *
   * @param firewallPolicy Name of the firewall policy to which the queried rule belongs.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionNetworkFirewallPoliciesGetRule(firewallPolicy: string, project: string, region: string, opts: RegionNetworkFirewallPoliciesGetRuleOptions = {}): Promise<FirewallPolicyRule> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/firewallPolicies/${ firewallPolicy }/getRule`);
    if (opts.priority !== undefined) {
      url.searchParams.append("priority", String(opts.priority));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return data as FirewallPolicyRule;
  }

  /**
   * Creates a new network firewall policy in the specified project and region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionNetworkFirewallPoliciesInsert(project: string, region: string, req: FirewallPolicy, opts: RegionNetworkFirewallPoliciesInsertOptions = {}): Promise<Operation> {
    req = serializeFirewallPolicy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/firewallPolicies`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Lists all the network firewall policies that have been configured for the
   * specified project in the given region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionNetworkFirewallPoliciesList(project: string, region: string, opts: RegionNetworkFirewallPoliciesListOptions = {}): Promise<FirewallPolicyList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/firewallPolicies`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeFirewallPolicyList(data);
  }

  /**
   * Patches the specified network firewall policy.
   *
   * @param firewallPolicy Name of the firewall policy to update.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionNetworkFirewallPoliciesPatch(firewallPolicy: string, project: string, region: string, req: FirewallPolicy, opts: RegionNetworkFirewallPoliciesPatchOptions = {}): Promise<Operation> {
    req = serializeFirewallPolicy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/firewallPolicies/${ firewallPolicy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Patches a rule of the specified priority.
   *
   * @param firewallPolicy Name of the firewall policy to update.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionNetworkFirewallPoliciesPatchRule(firewallPolicy: string, project: string, region: string, req: FirewallPolicyRule, opts: RegionNetworkFirewallPoliciesPatchRuleOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/firewallPolicies/${ firewallPolicy }/patchRule`);
    if (opts.priority !== undefined) {
      url.searchParams.append("priority", String(opts.priority));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Removes an association for the specified network firewall policy.
   *
   * @param firewallPolicy Name of the firewall policy to update.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionNetworkFirewallPoliciesRemoveAssociation(firewallPolicy: string, project: string, region: string, opts: RegionNetworkFirewallPoliciesRemoveAssociationOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/firewallPolicies/${ firewallPolicy }/removeAssociation`);
    if (opts.name !== undefined) {
      url.searchParams.append("name", String(opts.name));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes a rule of the specified priority.
   *
   * @param firewallPolicy Name of the firewall policy to update.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionNetworkFirewallPoliciesRemoveRule(firewallPolicy: string, project: string, region: string, opts: RegionNetworkFirewallPoliciesRemoveRuleOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/firewallPolicies/${ firewallPolicy }/removeRule`);
    if (opts.priority !== undefined) {
      url.searchParams.append("priority", String(opts.priority));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async regionNetworkFirewallPoliciesSetIamPolicy(project: string, region: string, resource: string, req: RegionSetPolicyRequest): Promise<Policy> {
    req = serializeRegionSetPolicyRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/firewallPolicies/${ resource }/setIamPolicy`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializePolicy(data);
  }

  /**
   * Returns permissions that a caller has on the specified resource.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async regionNetworkFirewallPoliciesTestIamPermissions(project: string, region: string, resource: string, req: TestPermissionsRequest): Promise<TestPermissionsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/firewallPolicies/${ resource }/testIamPermissions`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as TestPermissionsResponse;
  }

  /**
   * Deletes the specified NotificationEndpoint in the given region
   *
   * @param notificationEndpoint Name of the NotificationEndpoint resource to delete.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionNotificationEndpointsDelete(notificationEndpoint: string, project: string, region: string, opts: RegionNotificationEndpointsDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/notificationEndpoints/${ notificationEndpoint }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified NotificationEndpoint resource in the given region.
   *
   * @param notificationEndpoint Name of the NotificationEndpoint resource to return.
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionNotificationEndpointsGet(notificationEndpoint: string, project: string, region: string): Promise<NotificationEndpoint> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/notificationEndpoints/${ notificationEndpoint }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNotificationEndpoint(data);
  }

  /**
   * Create a NotificationEndpoint in the specified project in the given region
   * using the parameters that are included in the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionNotificationEndpointsInsert(project: string, region: string, req: NotificationEndpoint, opts: RegionNotificationEndpointsInsertOptions = {}): Promise<Operation> {
    req = serializeNotificationEndpoint(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/notificationEndpoints`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Lists the NotificationEndpoints for a project in the given region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionNotificationEndpointsList(project: string, region: string, opts: RegionNotificationEndpointsListOptions = {}): Promise<NotificationEndpointList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/notificationEndpoints`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeNotificationEndpointList(data);
  }

  /**
   * Deletes the specified region-specific Operations resource.
   *
   * @param operation Name of the Operations resource to delete.
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async regionOperationsDelete(operation: string, project: string, region: string): Promise<void> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/operations/${ operation }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
  }

  /**
   * Retrieves the specified region-specific Operations resource.
   *
   * @param operation Name of the Operations resource to return.
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async regionOperationsGet(operation: string, project: string, region: string): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/operations/${ operation }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of Operation resources contained within the specified
   * region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async regionOperationsList(project: string, region: string, opts: RegionOperationsListOptions = {}): Promise<OperationList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/operations`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeOperationList(data);
  }

  /**
   * Waits for the specified Operation resource to return as `DONE` or for the
   * request to approach the 2 minute deadline, and retrieves the specified
   * Operation resource. This method differs from the `GET` method in that it
   * waits for no more than the default deadline (2 minutes) and then returns
   * the current state of the operation, which might be `DONE` or still in
   * progress. This method is called on a best-effort basis. Specifically: - In
   * uncommon cases, when the server is overloaded, the request might return
   * before the default deadline is reached, or might return after zero seconds.
   * - If the default deadline is reached, there is no guarantee that the
   * operation is actually done when the method returns. Be prepared to retry if
   * the operation is not `DONE`.
   *
   * @param operation Name of the Operations resource to return.
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async regionOperationsWait(operation: string, project: string, region: string): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/operations/${ operation }/wait`);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified policy.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param securityPolicy Name of the security policy to delete.
   */
  async regionSecurityPoliciesDelete(project: string, region: string, securityPolicy: string, opts: RegionSecurityPoliciesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/securityPolicies/${ securityPolicy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * List all of the ordered rules present in a single specified policy.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param securityPolicy Name of the security policy to get.
   */
  async regionSecurityPoliciesGet(project: string, region: string, securityPolicy: string): Promise<SecurityPolicy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/securityPolicies/${ securityPolicy }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeSecurityPolicy(data);
  }

  /**
   * Creates a new policy in the specified project using the data included in
   * the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionSecurityPoliciesInsert(project: string, region: string, req: SecurityPolicy, opts: RegionSecurityPoliciesInsertOptions = {}): Promise<Operation> {
    req = serializeSecurityPolicy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/securityPolicies`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    if (opts.validateOnly !== undefined) {
      url.searchParams.append("validateOnly", String(opts.validateOnly));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * List all the policies that have been configured for the specified project
   * and region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionSecurityPoliciesList(project: string, region: string, opts: RegionSecurityPoliciesListOptions = {}): Promise<SecurityPolicyList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/securityPolicies`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeSecurityPolicyList(data);
  }

  /**
   * Patches the specified policy with the data included in the request. To
   * clear fields in the rule, leave the fields empty and specify them in the
   * updateMask. This cannot be used to be update the rules in the policy.
   * Please use the per rule methods like addRule, patchRule, and removeRule
   * instead.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param securityPolicy Name of the security policy to update.
   */
  async regionSecurityPoliciesPatch(project: string, region: string, securityPolicy: string, req: SecurityPolicy, opts: RegionSecurityPoliciesPatchOptions = {}): Promise<Operation> {
    req = serializeSecurityPolicy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/securityPolicies/${ securityPolicy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified Region resource. To decrease latency for this
   * method, you can optionally omit any unneeded information from the response
   * by using a field mask. This practice is especially recommended for unused
   * quota information (the `quotas` field). To exclude one or more fields, set
   * your request's `fields` query parameter to only include the fields you
   * need. For example, to only include the `id` and `selfLink` fields, add the
   * query parameter `?fields=id,selfLink` to your request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region resource to return.
   */
  async regionsGet(project: string, region: string): Promise<Region> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeRegion(data);
  }

  /**
   * Retrieves the list of region resources available to the specified project.
   * To decrease latency for this method, you can optionally omit any unneeded
   * information from the response by using a field mask. This practice is
   * especially recommended for unused quota information (the `items.quotas`
   * field). To exclude one or more fields, set your request's `fields` query
   * parameter to only include the fields you need. For example, to only include
   * the `id` and `selfLink` fields, add the query parameter
   * `?fields=id,selfLink` to your request.
   *
   * @param project Project ID for this request.
   */
  async regionsList(project: string, opts: RegionsListOptions = {}): Promise<RegionList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeRegionList(data);
  }

  /**
   * Deletes the specified SslCertificate resource in the region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param sslCertificate Name of the SslCertificate resource to delete.
   */
  async regionSslCertificatesDelete(project: string, region: string, sslCertificate: string, opts: RegionSslCertificatesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/sslCertificates/${ sslCertificate }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified SslCertificate resource in the specified region. Get
   * a list of available SSL certificates by making a list() request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param sslCertificate Name of the SslCertificate resource to return.
   */
  async regionSslCertificatesGet(project: string, region: string, sslCertificate: string): Promise<SslCertificate> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/sslCertificates/${ sslCertificate }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeSslCertificate(data);
  }

  /**
   * Creates a SslCertificate resource in the specified project and region
   * using the data included in the request
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionSslCertificatesInsert(project: string, region: string, req: SslCertificate, opts: RegionSslCertificatesInsertOptions = {}): Promise<Operation> {
    req = serializeSslCertificate(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/sslCertificates`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of SslCertificate resources available to the specified
   * project in the specified region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionSslCertificatesList(project: string, region: string, opts: RegionSslCertificatesListOptions = {}): Promise<SslCertificateList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/sslCertificates`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeSslCertificateList(data);
  }

  /**
   * Deletes the specified SSL policy. The SSL policy resource can be deleted
   * only if it is not in use by any TargetHttpsProxy or TargetSslProxy
   * resources.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param sslPolicy Name of the SSL policy to delete. The name must be 1-63 characters long, and comply with RFC1035.
   */
  async regionSslPoliciesDelete(project: string, region: string, sslPolicy: string, opts: RegionSslPoliciesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/sslPolicies/${ sslPolicy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Lists all of the ordered rules present in a single specified policy.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param sslPolicy Name of the SSL policy to update. The name must be 1-63 characters long, and comply with RFC1035.
   */
  async regionSslPoliciesGet(project: string, region: string, sslPolicy: string): Promise<SslPolicy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/sslPolicies/${ sslPolicy }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeSslPolicy(data);
  }

  /**
   * Creates a new policy in the specified project and region using the data
   * included in the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionSslPoliciesInsert(project: string, region: string, req: SslPolicy, opts: RegionSslPoliciesInsertOptions = {}): Promise<Operation> {
    req = serializeSslPolicy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/sslPolicies`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Lists all the SSL policies that have been configured for the specified
   * project and region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionSslPoliciesList(project: string, region: string, opts: RegionSslPoliciesListOptions = {}): Promise<SslPoliciesList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/sslPolicies`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeSslPoliciesList(data);
  }

  /**
   * Lists all features that can be specified in the SSL policy when using
   * custom profile.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionSslPoliciesListAvailableFeatures(project: string, region: string, opts: RegionSslPoliciesListAvailableFeaturesOptions = {}): Promise<SslPoliciesListAvailableFeaturesResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/sslPolicies/listAvailableFeatures`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return data as SslPoliciesListAvailableFeaturesResponse;
  }

  /**
   * Patches the specified SSL policy with the data included in the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param sslPolicy Name of the SSL policy to update. The name must be 1-63 characters long, and comply with RFC1035.
   */
  async regionSslPoliciesPatch(project: string, region: string, sslPolicy: string, req: SslPolicy, opts: RegionSslPoliciesPatchOptions = {}): Promise<Operation> {
    req = serializeSslPolicy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/sslPolicies/${ sslPolicy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified TargetHttpProxy resource.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param targetHttpProxy Name of the TargetHttpProxy resource to delete.
   */
  async regionTargetHttpProxiesDelete(project: string, region: string, targetHttpProxy: string, opts: RegionTargetHttpProxiesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetHttpProxies/${ targetHttpProxy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified TargetHttpProxy resource in the specified region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param targetHttpProxy Name of the TargetHttpProxy resource to return.
   */
  async regionTargetHttpProxiesGet(project: string, region: string, targetHttpProxy: string): Promise<TargetHttpProxy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetHttpProxies/${ targetHttpProxy }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetHttpProxy(data);
  }

  /**
   * Creates a TargetHttpProxy resource in the specified project and region
   * using the data included in the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionTargetHttpProxiesInsert(project: string, region: string, req: TargetHttpProxy, opts: RegionTargetHttpProxiesInsertOptions = {}): Promise<Operation> {
    req = serializeTargetHttpProxy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetHttpProxies`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of TargetHttpProxy resources available to the specified
   * project in the specified region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionTargetHttpProxiesList(project: string, region: string, opts: RegionTargetHttpProxiesListOptions = {}): Promise<TargetHttpProxyList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetHttpProxies`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetHttpProxyList(data);
  }

  /**
   * Changes the URL map for TargetHttpProxy.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param targetHttpProxy Name of the TargetHttpProxy to set a URL map for.
   */
  async regionTargetHttpProxiesSetUrlMap(project: string, region: string, targetHttpProxy: string, req: UrlMapReference, opts: RegionTargetHttpProxiesSetUrlMapOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetHttpProxies/${ targetHttpProxy }/setUrlMap`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified TargetHttpsProxy resource.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param targetHttpsProxy Name of the TargetHttpsProxy resource to delete.
   */
  async regionTargetHttpsProxiesDelete(project: string, region: string, targetHttpsProxy: string, opts: RegionTargetHttpsProxiesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetHttpsProxies/${ targetHttpsProxy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified TargetHttpsProxy resource in the specified region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param targetHttpsProxy Name of the TargetHttpsProxy resource to return.
   */
  async regionTargetHttpsProxiesGet(project: string, region: string, targetHttpsProxy: string): Promise<TargetHttpsProxy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetHttpsProxies/${ targetHttpsProxy }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetHttpsProxy(data);
  }

  /**
   * Creates a TargetHttpsProxy resource in the specified project and region
   * using the data included in the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionTargetHttpsProxiesInsert(project: string, region: string, req: TargetHttpsProxy, opts: RegionTargetHttpsProxiesInsertOptions = {}): Promise<Operation> {
    req = serializeTargetHttpsProxy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetHttpsProxies`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of TargetHttpsProxy resources available to the
   * specified project in the specified region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionTargetHttpsProxiesList(project: string, region: string, opts: RegionTargetHttpsProxiesListOptions = {}): Promise<TargetHttpsProxyList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetHttpsProxies`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetHttpsProxyList(data);
  }

  /**
   * Patches the specified regional TargetHttpsProxy resource with the data
   * included in the request. This method supports PATCH semantics and uses JSON
   * merge patch format and processing rules.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   * @param targetHttpsProxy Name of the TargetHttpsProxy resource to patch.
   */
  async regionTargetHttpsProxiesPatch(project: string, region: string, targetHttpsProxy: string, req: TargetHttpsProxy, opts: RegionTargetHttpsProxiesPatchOptions = {}): Promise<Operation> {
    req = serializeTargetHttpsProxy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetHttpsProxies/${ targetHttpsProxy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Replaces SslCertificates for TargetHttpsProxy.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param targetHttpsProxy Name of the TargetHttpsProxy resource to set an SslCertificates resource for.
   */
  async regionTargetHttpsProxiesSetSslCertificates(project: string, region: string, targetHttpsProxy: string, req: RegionTargetHttpsProxiesSetSslCertificatesRequest, opts: RegionTargetHttpsProxiesSetSslCertificatesOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetHttpsProxies/${ targetHttpsProxy }/setSslCertificates`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Changes the URL map for TargetHttpsProxy.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param targetHttpsProxy Name of the TargetHttpsProxy to set a URL map for.
   */
  async regionTargetHttpsProxiesSetUrlMap(project: string, region: string, targetHttpsProxy: string, req: UrlMapReference, opts: RegionTargetHttpsProxiesSetUrlMapOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetHttpsProxies/${ targetHttpsProxy }/setUrlMap`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified TargetTcpProxy resource.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param targetTcpProxy Name of the TargetTcpProxy resource to delete.
   */
  async regionTargetTcpProxiesDelete(project: string, region: string, targetTcpProxy: string, opts: RegionTargetTcpProxiesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetTcpProxies/${ targetTcpProxy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified TargetTcpProxy resource.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param targetTcpProxy Name of the TargetTcpProxy resource to return.
   */
  async regionTargetTcpProxiesGet(project: string, region: string, targetTcpProxy: string): Promise<TargetTcpProxy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetTcpProxies/${ targetTcpProxy }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetTcpProxy(data);
  }

  /**
   * Creates a TargetTcpProxy resource in the specified project and region
   * using the data included in the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionTargetTcpProxiesInsert(project: string, region: string, req: TargetTcpProxy, opts: RegionTargetTcpProxiesInsertOptions = {}): Promise<Operation> {
    req = serializeTargetTcpProxy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetTcpProxies`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of TargetTcpProxy resources available to the specified
   * project in a given region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionTargetTcpProxiesList(project: string, region: string, opts: RegionTargetTcpProxiesListOptions = {}): Promise<TargetTcpProxyList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetTcpProxies`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetTcpProxyList(data);
  }

  /**
   * Deletes the specified UrlMap resource.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param urlMap Name of the UrlMap resource to delete.
   */
  async regionUrlMapsDelete(project: string, region: string, urlMap: string, opts: RegionUrlMapsDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/urlMaps/${ urlMap }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified UrlMap resource.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param urlMap Name of the UrlMap resource to return.
   */
  async regionUrlMapsGet(project: string, region: string, urlMap: string): Promise<UrlMap> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/urlMaps/${ urlMap }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeUrlMap(data);
  }

  /**
   * Creates a UrlMap resource in the specified project using the data included
   * in the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionUrlMapsInsert(project: string, region: string, req: UrlMap, opts: RegionUrlMapsInsertOptions = {}): Promise<Operation> {
    req = serializeUrlMap(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/urlMaps`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of UrlMap resources available to the specified project
   * in the specified region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async regionUrlMapsList(project: string, region: string, opts: RegionUrlMapsListOptions = {}): Promise<UrlMapList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/urlMaps`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeUrlMapList(data);
  }

  /**
   * Patches the specified UrlMap resource with the data included in the
   * request. This method supports PATCH semantics and uses JSON merge patch
   * format and processing rules.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param urlMap Name of the UrlMap resource to patch.
   */
  async regionUrlMapsPatch(project: string, region: string, urlMap: string, req: UrlMap, opts: RegionUrlMapsPatchOptions = {}): Promise<Operation> {
    req = serializeUrlMap(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/urlMaps/${ urlMap }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Updates the specified UrlMap resource with the data included in the
   * request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param urlMap Name of the UrlMap resource to update.
   */
  async regionUrlMapsUpdate(project: string, region: string, urlMap: string, req: UrlMap, opts: RegionUrlMapsUpdateOptions = {}): Promise<Operation> {
    req = serializeUrlMap(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/urlMaps/${ urlMap }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PUT",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Runs static validation for the UrlMap. In particular, the tests of the
   * provided UrlMap will be run. Calling this method does NOT create the
   * UrlMap.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param urlMap Name of the UrlMap resource to be validated as.
   */
  async regionUrlMapsValidate(project: string, region: string, urlMap: string, req: RegionUrlMapsValidateRequest): Promise<UrlMapsValidateResponse> {
    req = serializeRegionUrlMapsValidateRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/urlMaps/${ urlMap }/validate`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as UrlMapsValidateResponse;
  }

  /**
   * Retrieves an aggregated list of reservations.
   *
   * @param project Project ID for this request.
   */
  async reservationsAggregatedList(project: string, opts: ReservationsAggregatedListOptions = {}): Promise<ReservationAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/reservations`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeReservationAggregatedList(data);
  }

  /**
   * Deletes the specified reservation.
   *
   * @param project Project ID for this request.
   * @param reservation Name of the reservation to delete.
   * @param zone Name of the zone for this request.
   */
  async reservationsDelete(project: string, reservation: string, zone: string, opts: ReservationsDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/reservations/${ reservation }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves information about the specified reservation.
   *
   * @param project Project ID for this request.
   * @param reservation Name of the reservation to retrieve.
   * @param zone Name of the zone for this request.
   */
  async reservationsGet(project: string, reservation: string, zone: string): Promise<Reservation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/reservations/${ reservation }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeReservation(data);
  }

  /**
   * Gets the access control policy for a resource. May be empty if no such
   * policy or resource exists.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   * @param zone The name of the zone for this request.
   */
  async reservationsGetIamPolicy(project: string, resource: string, zone: string, opts: ReservationsGetIamPolicyOptions = {}): Promise<Policy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/reservations/${ resource }/getIamPolicy`);
    if (opts.optionsRequestedPolicyVersion !== undefined) {
      url.searchParams.append("optionsRequestedPolicyVersion", String(opts.optionsRequestedPolicyVersion));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePolicy(data);
  }

  /**
   * Creates a new reservation. For more information, read Reserving zonal
   * resources.
   *
   * @param project Project ID for this request.
   * @param zone Name of the zone for this request.
   */
  async reservationsInsert(project: string, zone: string, req: Reservation, opts: ReservationsInsertOptions = {}): Promise<Operation> {
    req = serializeReservation(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/reservations`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * A list of all the reservations that have been configured for the specified
   * project in specified zone.
   *
   * @param project Project ID for this request.
   * @param zone Name of the zone for this request.
   */
  async reservationsList(project: string, zone: string, opts: ReservationsListOptions = {}): Promise<ReservationList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/reservations`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeReservationList(data);
  }

  /**
   * Resizes the reservation (applicable to standalone reservations only). For
   * more information, read Modifying reservations.
   *
   * @param project Project ID for this request.
   * @param reservation Name of the reservation to update.
   * @param zone Name of the zone for this request.
   */
  async reservationsResize(project: string, reservation: string, zone: string, req: ReservationsResizeRequest, opts: ReservationsResizeOptions = {}): Promise<Operation> {
    req = serializeReservationsResizeRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/reservations/${ reservation }/resize`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   * @param zone The name of the zone for this request.
   */
  async reservationsSetIamPolicy(project: string, resource: string, zone: string, req: ZoneSetPolicyRequest): Promise<Policy> {
    req = serializeZoneSetPolicyRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/reservations/${ resource }/setIamPolicy`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializePolicy(data);
  }

  /**
   * Returns permissions that a caller has on the specified resource.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   * @param zone The name of the zone for this request.
   */
  async reservationsTestIamPermissions(project: string, resource: string, zone: string, req: TestPermissionsRequest): Promise<TestPermissionsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/reservations/${ resource }/testIamPermissions`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as TestPermissionsResponse;
  }

  /**
   * Update share settings of the reservation.
   *
   * @param project Project ID for this request.
   * @param reservation Name of the reservation to update.
   * @param zone Name of the zone for this request.
   */
  async reservationsUpdate(project: string, reservation: string, zone: string, req: Reservation, opts: ReservationsUpdateOptions = {}): Promise<Operation> {
    req = serializeReservation(req);
    opts = serializeReservationsUpdateOptions(opts);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/reservations/${ reservation }`);
    if (opts.paths !== undefined) {
      url.searchParams.append("paths", String(opts.paths));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    if (opts.updateMask !== undefined) {
      url.searchParams.append("updateMask", String(opts.updateMask));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves an aggregated list of resource policies.
   *
   * @param project Project ID for this request.
   */
  async resourcePoliciesAggregatedList(project: string, opts: ResourcePoliciesAggregatedListOptions = {}): Promise<ResourcePolicyAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/resourcePolicies`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeResourcePolicyAggregatedList(data);
  }

  /**
   * Deletes the specified resource policy.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   * @param resourcePolicy Name of the resource policy to delete.
   */
  async resourcePoliciesDelete(project: string, region: string, resourcePolicy: string, opts: ResourcePoliciesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/resourcePolicies/${ resourcePolicy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves all information of the specified resource policy.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   * @param resourcePolicy Name of the resource policy to retrieve.
   */
  async resourcePoliciesGet(project: string, region: string, resourcePolicy: string): Promise<ResourcePolicy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/resourcePolicies/${ resourcePolicy }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeResourcePolicy(data);
  }

  /**
   * Gets the access control policy for a resource. May be empty if no such
   * policy or resource exists.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async resourcePoliciesGetIamPolicy(project: string, region: string, resource: string, opts: ResourcePoliciesGetIamPolicyOptions = {}): Promise<Policy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/resourcePolicies/${ resource }/getIamPolicy`);
    if (opts.optionsRequestedPolicyVersion !== undefined) {
      url.searchParams.append("optionsRequestedPolicyVersion", String(opts.optionsRequestedPolicyVersion));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePolicy(data);
  }

  /**
   * Creates a new resource policy.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async resourcePoliciesInsert(project: string, region: string, req: ResourcePolicy, opts: ResourcePoliciesInsertOptions = {}): Promise<Operation> {
    req = serializeResourcePolicy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/resourcePolicies`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * A list all the resource policies that have been configured for the
   * specified project in specified region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async resourcePoliciesList(project: string, region: string, opts: ResourcePoliciesListOptions = {}): Promise<ResourcePolicyList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/resourcePolicies`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeResourcePolicyList(data);
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async resourcePoliciesSetIamPolicy(project: string, region: string, resource: string, req: RegionSetPolicyRequest): Promise<Policy> {
    req = serializeRegionSetPolicyRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/resourcePolicies/${ resource }/setIamPolicy`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializePolicy(data);
  }

  /**
   * Returns permissions that a caller has on the specified resource.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async resourcePoliciesTestIamPermissions(project: string, region: string, resource: string, req: TestPermissionsRequest): Promise<TestPermissionsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/resourcePolicies/${ resource }/testIamPermissions`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as TestPermissionsResponse;
  }

  /**
   * Retrieves an aggregated list of routers.
   *
   * @param project Project ID for this request.
   */
  async routersAggregatedList(project: string, opts: RoutersAggregatedListOptions = {}): Promise<RouterAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/routers`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeRouterAggregatedList(data);
  }

  /**
   * Deletes the specified Router resource.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   * @param router Name of the Router resource to delete.
   */
  async routersDelete(project: string, region: string, router: string, opts: RoutersDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/routers/${ router }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified Router resource.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   * @param router Name of the Router resource to return.
   */
  async routersGet(project: string, region: string, router: string): Promise<Router> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/routers/${ router }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeRouter(data);
  }

  /**
   * Retrieves runtime Nat mapping information of VM endpoints.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   * @param router Name of the Router resource to query for Nat Mapping information of VM endpoints.
   */
  async routersGetNatMappingInfo(project: string, region: string, router: string, opts: RoutersGetNatMappingInfoOptions = {}): Promise<VmEndpointNatMappingsList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/routers/${ router }/getNatMappingInfo`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return data as VmEndpointNatMappingsList;
  }

  /**
   * Retrieves runtime information of the specified router.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   * @param router Name of the Router resource to query.
   */
  async routersGetRouterStatus(project: string, region: string, router: string): Promise<RouterStatusResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/routers/${ router }/getRouterStatus`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeRouterStatusResponse(data);
  }

  /**
   * Creates a Router resource in the specified project and region using the
   * data included in the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async routersInsert(project: string, region: string, req: Router, opts: RoutersInsertOptions = {}): Promise<Operation> {
    req = serializeRouter(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/routers`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of Router resources available to the specified project.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async routersList(project: string, region: string, opts: RoutersListOptions = {}): Promise<RouterList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/routers`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeRouterList(data);
  }

  /**
   * Patches the specified Router resource with the data included in the
   * request. This method supports PATCH semantics and uses JSON merge patch
   * format and processing rules.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   * @param router Name of the Router resource to patch.
   */
  async routersPatch(project: string, region: string, router: string, req: Router, opts: RoutersPatchOptions = {}): Promise<Operation> {
    req = serializeRouter(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/routers/${ router }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Preview fields auto-generated during router create and update operations.
   * Calling this method does NOT create or update the router.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   * @param router Name of the Router resource to query.
   */
  async routersPreview(project: string, region: string, router: string, req: Router): Promise<RoutersPreviewResponse> {
    req = serializeRouter(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/routers/${ router }/preview`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeRoutersPreviewResponse(data);
  }

  /**
   * Updates the specified Router resource with the data included in the
   * request. This method conforms to PUT semantics, which requests that the
   * state of the target resource be created or replaced with the state defined
   * by the representation enclosed in the request message payload.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   * @param router Name of the Router resource to update.
   */
  async routersUpdate(project: string, region: string, router: string, req: Router, opts: RoutersUpdateOptions = {}): Promise<Operation> {
    req = serializeRouter(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/routers/${ router }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PUT",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified Route resource.
   *
   * @param project Project ID for this request.
   * @param route Name of the Route resource to delete.
   */
  async routesDelete(project: string, route: string, opts: RoutesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/routes/${ route }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified Route resource.
   *
   * @param project Project ID for this request.
   * @param route Name of the Route resource to return.
   */
  async routesGet(project: string, route: string): Promise<Route> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/routes/${ route }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeRoute(data);
  }

  /**
   * Creates a Route resource in the specified project using the data included
   * in the request.
   *
   * @param project Project ID for this request.
   */
  async routesInsert(project: string, req: Route, opts: RoutesInsertOptions = {}): Promise<Operation> {
    req = serializeRoute(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/routes`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of Route resources available to the specified project.
   *
   * @param project Project ID for this request.
   */
  async routesList(project: string, opts: RoutesListOptions = {}): Promise<RouteList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/routes`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeRouteList(data);
  }

  /**
   * Inserts a rule into a security policy.
   *
   * @param project Project ID for this request.
   * @param securityPolicy Name of the security policy to update.
   */
  async securityPoliciesAddRule(project: string, securityPolicy: string, req: SecurityPolicyRule, opts: SecurityPoliciesAddRuleOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/securityPolicies/${ securityPolicy }/addRule`);
    if (opts.validateOnly !== undefined) {
      url.searchParams.append("validateOnly", String(opts.validateOnly));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of all SecurityPolicy resources, regional and global,
   * available to the specified project.
   *
   * @param project Name of the project scoping this request.
   */
  async securityPoliciesAggregatedList(project: string, opts: SecurityPoliciesAggregatedListOptions = {}): Promise<SecurityPoliciesAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/securityPolicies`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeSecurityPoliciesAggregatedList(data);
  }

  /**
   * Deletes the specified policy.
   *
   * @param project Project ID for this request.
   * @param securityPolicy Name of the security policy to delete.
   */
  async securityPoliciesDelete(project: string, securityPolicy: string, opts: SecurityPoliciesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/securityPolicies/${ securityPolicy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * List all of the ordered rules present in a single specified policy.
   *
   * @param project Project ID for this request.
   * @param securityPolicy Name of the security policy to get.
   */
  async securityPoliciesGet(project: string, securityPolicy: string): Promise<SecurityPolicy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/securityPolicies/${ securityPolicy }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeSecurityPolicy(data);
  }

  /**
   * Gets a rule at the specified priority.
   *
   * @param project Project ID for this request.
   * @param securityPolicy Name of the security policy to which the queried rule belongs.
   */
  async securityPoliciesGetRule(project: string, securityPolicy: string, opts: SecurityPoliciesGetRuleOptions = {}): Promise<SecurityPolicyRule> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/securityPolicies/${ securityPolicy }/getRule`);
    if (opts.priority !== undefined) {
      url.searchParams.append("priority", String(opts.priority));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return data as SecurityPolicyRule;
  }

  /**
   * Creates a new policy in the specified project using the data included in
   * the request.
   *
   * @param project Project ID for this request.
   */
  async securityPoliciesInsert(project: string, req: SecurityPolicy, opts: SecurityPoliciesInsertOptions = {}): Promise<Operation> {
    req = serializeSecurityPolicy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/securityPolicies`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    if (opts.validateOnly !== undefined) {
      url.searchParams.append("validateOnly", String(opts.validateOnly));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * List all the policies that have been configured for the specified project.
   *
   * @param project Project ID for this request.
   */
  async securityPoliciesList(project: string, opts: SecurityPoliciesListOptions = {}): Promise<SecurityPolicyList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/securityPolicies`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeSecurityPolicyList(data);
  }

  /**
   * Gets the current list of preconfigured Web Application Firewall (WAF)
   * expressions.
   *
   * @param project Project ID for this request.
   */
  async securityPoliciesListPreconfiguredExpressionSets(project: string, opts: SecurityPoliciesListPreconfiguredExpressionSetsOptions = {}): Promise<SecurityPoliciesListPreconfiguredExpressionSetsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/securityPolicies/listPreconfiguredExpressionSets`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return data as SecurityPoliciesListPreconfiguredExpressionSetsResponse;
  }

  /**
   * Patches the specified policy with the data included in the request. To
   * clear fields in the rule, leave the fields empty and specify them in the
   * updateMask. This cannot be used to be update the rules in the policy.
   * Please use the per rule methods like addRule, patchRule, and removeRule
   * instead.
   *
   * @param project Project ID for this request.
   * @param securityPolicy Name of the security policy to update.
   */
  async securityPoliciesPatch(project: string, securityPolicy: string, req: SecurityPolicy, opts: SecurityPoliciesPatchOptions = {}): Promise<Operation> {
    req = serializeSecurityPolicy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/securityPolicies/${ securityPolicy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Patches a rule at the specified priority.
   *
   * @param project Project ID for this request.
   * @param securityPolicy Name of the security policy to update.
   */
  async securityPoliciesPatchRule(project: string, securityPolicy: string, req: SecurityPolicyRule, opts: SecurityPoliciesPatchRuleOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/securityPolicies/${ securityPolicy }/patchRule`);
    if (opts.priority !== undefined) {
      url.searchParams.append("priority", String(opts.priority));
    }
    if (opts.validateOnly !== undefined) {
      url.searchParams.append("validateOnly", String(opts.validateOnly));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes a rule at the specified priority.
   *
   * @param project Project ID for this request.
   * @param securityPolicy Name of the security policy to update.
   */
  async securityPoliciesRemoveRule(project: string, securityPolicy: string, opts: SecurityPoliciesRemoveRuleOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/securityPolicies/${ securityPolicy }/removeRule`);
    if (opts.priority !== undefined) {
      url.searchParams.append("priority", String(opts.priority));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the labels on a security policy. To learn more about labels, read the
   * Labeling Resources documentation.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async securityPoliciesSetLabels(project: string, resource: string, req: GlobalSetLabelsRequest): Promise<Operation> {
    req = serializeGlobalSetLabelsRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/securityPolicies/${ resource }/setLabels`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of all ServiceAttachment resources, regional and
   * global, available to the specified project.
   *
   * @param project Name of the project scoping this request.
   */
  async serviceAttachmentsAggregatedList(project: string, opts: ServiceAttachmentsAggregatedListOptions = {}): Promise<ServiceAttachmentAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/serviceAttachments`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeServiceAttachmentAggregatedList(data);
  }

  /**
   * Deletes the specified ServiceAttachment in the given scope
   *
   * @param project Project ID for this request.
   * @param region Name of the region of this request.
   * @param serviceAttachment Name of the ServiceAttachment resource to delete.
   */
  async serviceAttachmentsDelete(project: string, region: string, serviceAttachment: string, opts: ServiceAttachmentsDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/serviceAttachments/${ serviceAttachment }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified ServiceAttachment resource in the given scope.
   *
   * @param project Project ID for this request.
   * @param region Name of the region of this request.
   * @param serviceAttachment Name of the ServiceAttachment resource to return.
   */
  async serviceAttachmentsGet(project: string, region: string, serviceAttachment: string): Promise<ServiceAttachment> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/serviceAttachments/${ serviceAttachment }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeServiceAttachment(data);
  }

  /**
   * Gets the access control policy for a resource. May be empty if no such
   * policy or resource exists.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async serviceAttachmentsGetIamPolicy(project: string, region: string, resource: string, opts: ServiceAttachmentsGetIamPolicyOptions = {}): Promise<Policy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/serviceAttachments/${ resource }/getIamPolicy`);
    if (opts.optionsRequestedPolicyVersion !== undefined) {
      url.searchParams.append("optionsRequestedPolicyVersion", String(opts.optionsRequestedPolicyVersion));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePolicy(data);
  }

  /**
   * Creates a ServiceAttachment in the specified project in the given scope
   * using the parameters that are included in the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region of this request.
   */
  async serviceAttachmentsInsert(project: string, region: string, req: ServiceAttachment, opts: ServiceAttachmentsInsertOptions = {}): Promise<Operation> {
    req = serializeServiceAttachment(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/serviceAttachments`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Lists the ServiceAttachments for a project in the given scope.
   *
   * @param project Project ID for this request.
   * @param region Name of the region of this request.
   */
  async serviceAttachmentsList(project: string, region: string, opts: ServiceAttachmentsListOptions = {}): Promise<ServiceAttachmentList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/serviceAttachments`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeServiceAttachmentList(data);
  }

  /**
   * Patches the specified ServiceAttachment resource with the data included in
   * the request. This method supports PATCH semantics and uses JSON merge patch
   * format and processing rules.
   *
   * @param project Project ID for this request.
   * @param region The region scoping this request and should conform to RFC1035.
   * @param serviceAttachment The resource id of the ServiceAttachment to patch. It should conform to RFC1035 resource name or be a string form on an unsigned long number.
   */
  async serviceAttachmentsPatch(project: string, region: string, serviceAttachment: string, req: ServiceAttachment, opts: ServiceAttachmentsPatchOptions = {}): Promise<Operation> {
    req = serializeServiceAttachment(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/serviceAttachments/${ serviceAttachment }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async serviceAttachmentsSetIamPolicy(project: string, region: string, resource: string, req: RegionSetPolicyRequest): Promise<Policy> {
    req = serializeRegionSetPolicyRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/serviceAttachments/${ resource }/setIamPolicy`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializePolicy(data);
  }

  /**
   * Returns permissions that a caller has on the specified resource.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async serviceAttachmentsTestIamPermissions(project: string, region: string, resource: string, req: TestPermissionsRequest): Promise<TestPermissionsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/serviceAttachments/${ resource }/testIamPermissions`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as TestPermissionsResponse;
  }

  /**
   * Deletes the specified Snapshot resource. Keep in mind that deleting a
   * single snapshot might not necessarily delete all the data on that snapshot.
   * If any data on the snapshot that is marked for deletion is needed for
   * subsequent snapshots, the data will be moved to the next corresponding
   * snapshot. For more information, see Deleting snapshots.
   *
   * @param project Project ID for this request.
   * @param snapshot Name of the Snapshot resource to delete.
   */
  async snapshotsDelete(project: string, snapshot: string, opts: SnapshotsDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/snapshots/${ snapshot }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified Snapshot resource.
   *
   * @param project Project ID for this request.
   * @param snapshot Name of the Snapshot resource to return.
   */
  async snapshotsGet(project: string, snapshot: string): Promise<Snapshot> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/snapshots/${ snapshot }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeSnapshot(data);
  }

  /**
   * Gets the access control policy for a resource. May be empty if no such
   * policy or resource exists.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async snapshotsGetIamPolicy(project: string, resource: string, opts: SnapshotsGetIamPolicyOptions = {}): Promise<Policy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/snapshots/${ resource }/getIamPolicy`);
    if (opts.optionsRequestedPolicyVersion !== undefined) {
      url.searchParams.append("optionsRequestedPolicyVersion", String(opts.optionsRequestedPolicyVersion));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePolicy(data);
  }

  /**
   * Creates a snapshot in the specified project using the data included in the
   * request. For regular snapshot creation, consider using this method instead
   * of disks.createSnapshot, as this method supports more features, such as
   * creating snapshots in a project different from the source disk project.
   *
   * @param project Project ID for this request.
   */
  async snapshotsInsert(project: string, req: Snapshot, opts: SnapshotsInsertOptions = {}): Promise<Operation> {
    req = serializeSnapshot(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/snapshots`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of Snapshot resources contained within the specified
   * project.
   *
   * @param project Project ID for this request.
   */
  async snapshotsList(project: string, opts: SnapshotsListOptions = {}): Promise<SnapshotList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/snapshots`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeSnapshotList(data);
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async snapshotsSetIamPolicy(project: string, resource: string, req: GlobalSetPolicyRequest): Promise<Policy> {
    req = serializeGlobalSetPolicyRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/snapshots/${ resource }/setIamPolicy`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializePolicy(data);
  }

  /**
   * Sets the labels on a snapshot. To learn more about labels, read the
   * Labeling Resources documentation.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async snapshotsSetLabels(project: string, resource: string, req: GlobalSetLabelsRequest): Promise<Operation> {
    req = serializeGlobalSetLabelsRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/snapshots/${ resource }/setLabels`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Returns permissions that a caller has on the specified resource.
   *
   * @param project Project ID for this request.
   * @param resource Name or id of the resource for this request.
   */
  async snapshotsTestIamPermissions(project: string, resource: string, req: TestPermissionsRequest): Promise<TestPermissionsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/snapshots/${ resource }/testIamPermissions`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as TestPermissionsResponse;
  }

  /**
   * Retrieves the list of all SslCertificate resources, regional and global,
   * available to the specified project.
   *
   * @param project Name of the project scoping this request.
   */
  async sslCertificatesAggregatedList(project: string, opts: SslCertificatesAggregatedListOptions = {}): Promise<SslCertificateAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/sslCertificates`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeSslCertificateAggregatedList(data);
  }

  /**
   * Deletes the specified SslCertificate resource.
   *
   * @param project Project ID for this request.
   * @param sslCertificate Name of the SslCertificate resource to delete.
   */
  async sslCertificatesDelete(project: string, sslCertificate: string, opts: SslCertificatesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/sslCertificates/${ sslCertificate }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified SslCertificate resource.
   *
   * @param project Project ID for this request.
   * @param sslCertificate Name of the SslCertificate resource to return.
   */
  async sslCertificatesGet(project: string, sslCertificate: string): Promise<SslCertificate> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/sslCertificates/${ sslCertificate }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeSslCertificate(data);
  }

  /**
   * Creates a SslCertificate resource in the specified project using the data
   * included in the request.
   *
   * @param project Project ID for this request.
   */
  async sslCertificatesInsert(project: string, req: SslCertificate, opts: SslCertificatesInsertOptions = {}): Promise<Operation> {
    req = serializeSslCertificate(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/sslCertificates`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of SslCertificate resources available to the specified
   * project.
   *
   * @param project Project ID for this request.
   */
  async sslCertificatesList(project: string, opts: SslCertificatesListOptions = {}): Promise<SslCertificateList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/sslCertificates`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeSslCertificateList(data);
  }

  /**
   * Retrieves the list of all SslPolicy resources, regional and global,
   * available to the specified project.
   *
   * @param project Name of the project scoping this request.
   */
  async sslPoliciesAggregatedList(project: string, opts: SslPoliciesAggregatedListOptions = {}): Promise<SslPoliciesAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/sslPolicies`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeSslPoliciesAggregatedList(data);
  }

  /**
   * Deletes the specified SSL policy. The SSL policy resource can be deleted
   * only if it is not in use by any TargetHttpsProxy or TargetSslProxy
   * resources.
   *
   * @param project Project ID for this request.
   * @param sslPolicy Name of the SSL policy to delete. The name must be 1-63 characters long, and comply with RFC1035.
   */
  async sslPoliciesDelete(project: string, sslPolicy: string, opts: SslPoliciesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/sslPolicies/${ sslPolicy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Lists all of the ordered rules present in a single specified policy.
   *
   * @param project Project ID for this request.
   * @param sslPolicy Name of the SSL policy to update. The name must be 1-63 characters long, and comply with RFC1035.
   */
  async sslPoliciesGet(project: string, sslPolicy: string): Promise<SslPolicy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/sslPolicies/${ sslPolicy }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeSslPolicy(data);
  }

  /**
   * Returns the specified SSL policy resource.
   *
   * @param project Project ID for this request.
   */
  async sslPoliciesInsert(project: string, req: SslPolicy, opts: SslPoliciesInsertOptions = {}): Promise<Operation> {
    req = serializeSslPolicy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/sslPolicies`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Lists all the SSL policies that have been configured for the specified
   * project.
   *
   * @param project Project ID for this request.
   */
  async sslPoliciesList(project: string, opts: SslPoliciesListOptions = {}): Promise<SslPoliciesList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/sslPolicies`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeSslPoliciesList(data);
  }

  /**
   * Lists all features that can be specified in the SSL policy when using
   * custom profile.
   *
   * @param project Project ID for this request.
   */
  async sslPoliciesListAvailableFeatures(project: string, opts: SslPoliciesListAvailableFeaturesOptions = {}): Promise<SslPoliciesListAvailableFeaturesResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/sslPolicies/listAvailableFeatures`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return data as SslPoliciesListAvailableFeaturesResponse;
  }

  /**
   * Patches the specified SSL policy with the data included in the request.
   *
   * @param project Project ID for this request.
   * @param sslPolicy Name of the SSL policy to update. The name must be 1-63 characters long, and comply with RFC1035.
   */
  async sslPoliciesPatch(project: string, sslPolicy: string, req: SslPolicy, opts: SslPoliciesPatchOptions = {}): Promise<Operation> {
    req = serializeSslPolicy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/sslPolicies/${ sslPolicy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves an aggregated list of subnetworks.
   *
   * @param project Project ID for this request.
   */
  async subnetworksAggregatedList(project: string, opts: SubnetworksAggregatedListOptions = {}): Promise<SubnetworkAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/subnetworks`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeSubnetworkAggregatedList(data);
  }

  /**
   * Deletes the specified subnetwork.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param subnetwork Name of the Subnetwork resource to delete.
   */
  async subnetworksDelete(project: string, region: string, subnetwork: string, opts: SubnetworksDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/subnetworks/${ subnetwork }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Expands the IP CIDR range of the subnetwork to a specified value.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param subnetwork Name of the Subnetwork resource to update.
   */
  async subnetworksExpandIpCidrRange(project: string, region: string, subnetwork: string, req: SubnetworksExpandIpCidrRangeRequest, opts: SubnetworksExpandIpCidrRangeOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/subnetworks/${ subnetwork }/expandIpCidrRange`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified subnetwork.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param subnetwork Name of the Subnetwork resource to return.
   */
  async subnetworksGet(project: string, region: string, subnetwork: string): Promise<Subnetwork> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/subnetworks/${ subnetwork }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeSubnetwork(data);
  }

  /**
   * Gets the access control policy for a resource. May be empty if no such
   * policy or resource exists.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async subnetworksGetIamPolicy(project: string, region: string, resource: string, opts: SubnetworksGetIamPolicyOptions = {}): Promise<Policy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/subnetworks/${ resource }/getIamPolicy`);
    if (opts.optionsRequestedPolicyVersion !== undefined) {
      url.searchParams.append("optionsRequestedPolicyVersion", String(opts.optionsRequestedPolicyVersion));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializePolicy(data);
  }

  /**
   * Creates a subnetwork in the specified project using the data included in
   * the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async subnetworksInsert(project: string, region: string, req: Subnetwork, opts: SubnetworksInsertOptions = {}): Promise<Operation> {
    req = serializeSubnetwork(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/subnetworks`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of subnetworks available to the specified project.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async subnetworksList(project: string, region: string, opts: SubnetworksListOptions = {}): Promise<SubnetworkList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/subnetworks`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeSubnetworkList(data);
  }

  /**
   * Retrieves an aggregated list of all usable subnetworks in the project.
   *
   * @param project Project ID for this request.
   */
  async subnetworksListUsable(project: string, opts: SubnetworksListUsableOptions = {}): Promise<UsableSubnetworksAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/subnetworks/listUsable`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return data as UsableSubnetworksAggregatedList;
  }

  /**
   * Patches the specified subnetwork with the data included in the request.
   * Only certain fields can be updated with a patch request as indicated in the
   * field descriptions. You must specify the current fingerprint of the
   * subnetwork resource being patched.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param subnetwork Name of the Subnetwork resource to patch.
   */
  async subnetworksPatch(project: string, region: string, subnetwork: string, req: Subnetwork, opts: SubnetworksPatchOptions = {}): Promise<Operation> {
    req = serializeSubnetwork(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/subnetworks/${ subnetwork }`);
    if (opts.drainTimeoutSeconds !== undefined) {
      url.searchParams.append("drainTimeoutSeconds", String(opts.drainTimeoutSeconds));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async subnetworksSetIamPolicy(project: string, region: string, resource: string, req: RegionSetPolicyRequest): Promise<Policy> {
    req = serializeRegionSetPolicyRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/subnetworks/${ resource }/setIamPolicy`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializePolicy(data);
  }

  /**
   * Set whether VMs in this subnet can access Google services without
   * assigning external IP addresses through Private Google Access.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param subnetwork Name of the Subnetwork resource.
   */
  async subnetworksSetPrivateIpGoogleAccess(project: string, region: string, subnetwork: string, req: SubnetworksSetPrivateIpGoogleAccessRequest, opts: SubnetworksSetPrivateIpGoogleAccessOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/subnetworks/${ subnetwork }/setPrivateIpGoogleAccess`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Returns permissions that a caller has on the specified resource.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async subnetworksTestIamPermissions(project: string, region: string, resource: string, req: TestPermissionsRequest): Promise<TestPermissionsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/subnetworks/${ resource }/testIamPermissions`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as TestPermissionsResponse;
  }

  /**
   * Deletes the specified TargetGrpcProxy in the given scope
   *
   * @param project Project ID for this request.
   * @param targetGrpcProxy Name of the TargetGrpcProxy resource to delete.
   */
  async targetGrpcProxiesDelete(project: string, targetGrpcProxy: string, opts: TargetGrpcProxiesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetGrpcProxies/${ targetGrpcProxy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified TargetGrpcProxy resource in the given scope.
   *
   * @param project Project ID for this request.
   * @param targetGrpcProxy Name of the TargetGrpcProxy resource to return.
   */
  async targetGrpcProxiesGet(project: string, targetGrpcProxy: string): Promise<TargetGrpcProxy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetGrpcProxies/${ targetGrpcProxy }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetGrpcProxy(data);
  }

  /**
   * Creates a TargetGrpcProxy in the specified project in the given scope
   * using the parameters that are included in the request.
   *
   * @param project Project ID for this request.
   */
  async targetGrpcProxiesInsert(project: string, req: TargetGrpcProxy, opts: TargetGrpcProxiesInsertOptions = {}): Promise<Operation> {
    req = serializeTargetGrpcProxy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetGrpcProxies`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Lists the TargetGrpcProxies for a project in the given scope.
   *
   * @param project Project ID for this request.
   */
  async targetGrpcProxiesList(project: string, opts: TargetGrpcProxiesListOptions = {}): Promise<TargetGrpcProxyList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetGrpcProxies`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetGrpcProxyList(data);
  }

  /**
   * Patches the specified TargetGrpcProxy resource with the data included in
   * the request. This method supports PATCH semantics and uses JSON merge patch
   * format and processing rules.
   *
   * @param project Project ID for this request.
   * @param targetGrpcProxy Name of the TargetGrpcProxy resource to patch.
   */
  async targetGrpcProxiesPatch(project: string, targetGrpcProxy: string, req: TargetGrpcProxy, opts: TargetGrpcProxiesPatchOptions = {}): Promise<Operation> {
    req = serializeTargetGrpcProxy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetGrpcProxies/${ targetGrpcProxy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of all TargetHttpProxy resources, regional and global,
   * available to the specified project.
   *
   * @param project Name of the project scoping this request.
   */
  async targetHttpProxiesAggregatedList(project: string, opts: TargetHttpProxiesAggregatedListOptions = {}): Promise<TargetHttpProxyAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/targetHttpProxies`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetHttpProxyAggregatedList(data);
  }

  /**
   * Deletes the specified TargetHttpProxy resource.
   *
   * @param project Project ID for this request.
   * @param targetHttpProxy Name of the TargetHttpProxy resource to delete.
   */
  async targetHttpProxiesDelete(project: string, targetHttpProxy: string, opts: TargetHttpProxiesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetHttpProxies/${ targetHttpProxy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified TargetHttpProxy resource.
   *
   * @param project Project ID for this request.
   * @param targetHttpProxy Name of the TargetHttpProxy resource to return.
   */
  async targetHttpProxiesGet(project: string, targetHttpProxy: string): Promise<TargetHttpProxy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetHttpProxies/${ targetHttpProxy }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetHttpProxy(data);
  }

  /**
   * Creates a TargetHttpProxy resource in the specified project using the data
   * included in the request.
   *
   * @param project Project ID for this request.
   */
  async targetHttpProxiesInsert(project: string, req: TargetHttpProxy, opts: TargetHttpProxiesInsertOptions = {}): Promise<Operation> {
    req = serializeTargetHttpProxy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetHttpProxies`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of TargetHttpProxy resources available to the specified
   * project.
   *
   * @param project Project ID for this request.
   */
  async targetHttpProxiesList(project: string, opts: TargetHttpProxiesListOptions = {}): Promise<TargetHttpProxyList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetHttpProxies`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetHttpProxyList(data);
  }

  /**
   * Patches the specified TargetHttpProxy resource with the data included in
   * the request. This method supports PATCH semantics and uses JSON merge patch
   * format and processing rules.
   *
   * @param project Project ID for this request.
   * @param targetHttpProxy Name of the TargetHttpProxy resource to patch.
   */
  async targetHttpProxiesPatch(project: string, targetHttpProxy: string, req: TargetHttpProxy, opts: TargetHttpProxiesPatchOptions = {}): Promise<Operation> {
    req = serializeTargetHttpProxy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetHttpProxies/${ targetHttpProxy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Changes the URL map for TargetHttpProxy.
   *
   * @param project Project ID for this request.
   * @param targetHttpProxy Name of the TargetHttpProxy to set a URL map for.
   */
  async targetHttpProxiesSetUrlMap(project: string, targetHttpProxy: string, req: UrlMapReference, opts: TargetHttpProxiesSetUrlMapOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/targetHttpProxies/${ targetHttpProxy }/setUrlMap`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of all TargetHttpsProxy resources, regional and global,
   * available to the specified project.
   *
   * @param project Name of the project scoping this request.
   */
  async targetHttpsProxiesAggregatedList(project: string, opts: TargetHttpsProxiesAggregatedListOptions = {}): Promise<TargetHttpsProxyAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/targetHttpsProxies`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetHttpsProxyAggregatedList(data);
  }

  /**
   * Deletes the specified TargetHttpsProxy resource.
   *
   * @param project Project ID for this request.
   * @param targetHttpsProxy Name of the TargetHttpsProxy resource to delete.
   */
  async targetHttpsProxiesDelete(project: string, targetHttpsProxy: string, opts: TargetHttpsProxiesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetHttpsProxies/${ targetHttpsProxy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified TargetHttpsProxy resource.
   *
   * @param project Project ID for this request.
   * @param targetHttpsProxy Name of the TargetHttpsProxy resource to return.
   */
  async targetHttpsProxiesGet(project: string, targetHttpsProxy: string): Promise<TargetHttpsProxy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetHttpsProxies/${ targetHttpsProxy }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetHttpsProxy(data);
  }

  /**
   * Creates a TargetHttpsProxy resource in the specified project using the
   * data included in the request.
   *
   * @param project Project ID for this request.
   */
  async targetHttpsProxiesInsert(project: string, req: TargetHttpsProxy, opts: TargetHttpsProxiesInsertOptions = {}): Promise<Operation> {
    req = serializeTargetHttpsProxy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetHttpsProxies`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of TargetHttpsProxy resources available to the
   * specified project.
   *
   * @param project Project ID for this request.
   */
  async targetHttpsProxiesList(project: string, opts: TargetHttpsProxiesListOptions = {}): Promise<TargetHttpsProxyList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetHttpsProxies`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetHttpsProxyList(data);
  }

  /**
   * Patches the specified TargetHttpsProxy resource with the data included in
   * the request. This method supports PATCH semantics and uses JSON merge patch
   * format and processing rules.
   *
   * @param project Project ID for this request.
   * @param targetHttpsProxy Name of the TargetHttpsProxy resource to patch.
   */
  async targetHttpsProxiesPatch(project: string, targetHttpsProxy: string, req: TargetHttpsProxy, opts: TargetHttpsProxiesPatchOptions = {}): Promise<Operation> {
    req = serializeTargetHttpsProxy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetHttpsProxies/${ targetHttpsProxy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Changes the Certificate Map for TargetHttpsProxy.
   *
   * @param project Project ID for this request.
   * @param targetHttpsProxy Name of the TargetHttpsProxy resource whose CertificateMap is to be set. The name must be 1-63 characters long, and comply with RFC1035.
   */
  async targetHttpsProxiesSetCertificateMap(project: string, targetHttpsProxy: string, req: TargetHttpsProxiesSetCertificateMapRequest, opts: TargetHttpsProxiesSetCertificateMapOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetHttpsProxies/${ targetHttpsProxy }/setCertificateMap`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the QUIC override policy for TargetHttpsProxy.
   *
   * @param project Project ID for this request.
   * @param targetHttpsProxy Name of the TargetHttpsProxy resource to set the QUIC override policy for. The name should conform to RFC1035.
   */
  async targetHttpsProxiesSetQuicOverride(project: string, targetHttpsProxy: string, req: TargetHttpsProxiesSetQuicOverrideRequest, opts: TargetHttpsProxiesSetQuicOverrideOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetHttpsProxies/${ targetHttpsProxy }/setQuicOverride`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Replaces SslCertificates for TargetHttpsProxy.
   *
   * @param project Project ID for this request.
   * @param targetHttpsProxy Name of the TargetHttpsProxy resource to set an SslCertificates resource for.
   */
  async targetHttpsProxiesSetSslCertificates(project: string, targetHttpsProxy: string, req: TargetHttpsProxiesSetSslCertificatesRequest, opts: TargetHttpsProxiesSetSslCertificatesOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/targetHttpsProxies/${ targetHttpsProxy }/setSslCertificates`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the SSL policy for TargetHttpsProxy. The SSL policy specifies the
   * server-side support for SSL features. This affects connections between
   * clients and the HTTPS proxy load balancer. They do not affect the
   * connection between the load balancer and the backends.
   *
   * @param project Project ID for this request.
   * @param targetHttpsProxy Name of the TargetHttpsProxy resource whose SSL policy is to be set. The name must be 1-63 characters long, and comply with RFC1035.
   */
  async targetHttpsProxiesSetSslPolicy(project: string, targetHttpsProxy: string, req: SslPolicyReference, opts: TargetHttpsProxiesSetSslPolicyOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetHttpsProxies/${ targetHttpsProxy }/setSslPolicy`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Changes the URL map for TargetHttpsProxy.
   *
   * @param project Project ID for this request.
   * @param targetHttpsProxy Name of the TargetHttpsProxy resource whose URL map is to be set.
   */
  async targetHttpsProxiesSetUrlMap(project: string, targetHttpsProxy: string, req: UrlMapReference, opts: TargetHttpsProxiesSetUrlMapOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/targetHttpsProxies/${ targetHttpsProxy }/setUrlMap`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves an aggregated list of target instances.
   *
   * @param project Project ID for this request.
   */
  async targetInstancesAggregatedList(project: string, opts: TargetInstancesAggregatedListOptions = {}): Promise<TargetInstanceAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/targetInstances`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetInstanceAggregatedList(data);
  }

  /**
   * Deletes the specified TargetInstance resource.
   *
   * @param project Project ID for this request.
   * @param targetInstance Name of the TargetInstance resource to delete.
   * @param zone Name of the zone scoping this request.
   */
  async targetInstancesDelete(project: string, targetInstance: string, zone: string, opts: TargetInstancesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/targetInstances/${ targetInstance }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified TargetInstance resource.
   *
   * @param project Project ID for this request.
   * @param targetInstance Name of the TargetInstance resource to return.
   * @param zone Name of the zone scoping this request.
   */
  async targetInstancesGet(project: string, targetInstance: string, zone: string): Promise<TargetInstance> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/targetInstances/${ targetInstance }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetInstance(data);
  }

  /**
   * Creates a TargetInstance resource in the specified project and zone using
   * the data included in the request.
   *
   * @param project Project ID for this request.
   * @param zone Name of the zone scoping this request.
   */
  async targetInstancesInsert(project: string, zone: string, req: TargetInstance, opts: TargetInstancesInsertOptions = {}): Promise<Operation> {
    req = serializeTargetInstance(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/targetInstances`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of TargetInstance resources available to the specified
   * project and zone.
   *
   * @param project Project ID for this request.
   * @param zone Name of the zone scoping this request.
   */
  async targetInstancesList(project: string, zone: string, opts: TargetInstancesListOptions = {}): Promise<TargetInstanceList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/targetInstances`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetInstanceList(data);
  }

  /**
   * Adds health check URLs to a target pool.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param targetPool Name of the target pool to add a health check to.
   */
  async targetPoolsAddHealthCheck(project: string, region: string, targetPool: string, req: TargetPoolsAddHealthCheckRequest, opts: TargetPoolsAddHealthCheckOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetPools/${ targetPool }/addHealthCheck`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Adds an instance to a target pool.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param targetPool Name of the TargetPool resource to add instances to.
   */
  async targetPoolsAddInstance(project: string, region: string, targetPool: string, req: TargetPoolsAddInstanceRequest, opts: TargetPoolsAddInstanceOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetPools/${ targetPool }/addInstance`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves an aggregated list of target pools.
   *
   * @param project Project ID for this request.
   */
  async targetPoolsAggregatedList(project: string, opts: TargetPoolsAggregatedListOptions = {}): Promise<TargetPoolAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/targetPools`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetPoolAggregatedList(data);
  }

  /**
   * Deletes the specified target pool.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param targetPool Name of the TargetPool resource to delete.
   */
  async targetPoolsDelete(project: string, region: string, targetPool: string, opts: TargetPoolsDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetPools/${ targetPool }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified target pool.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param targetPool Name of the TargetPool resource to return.
   */
  async targetPoolsGet(project: string, region: string, targetPool: string): Promise<TargetPool> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetPools/${ targetPool }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetPool(data);
  }

  /**
   * Gets the most recent health check results for each IP for the instance
   * that is referenced by the given target pool.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param targetPool Name of the TargetPool resource to which the queried instance belongs.
   */
  async targetPoolsGetHealth(project: string, region: string, targetPool: string, req: InstanceReference): Promise<TargetPoolInstanceHealth> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetPools/${ targetPool }/getHealth`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as TargetPoolInstanceHealth;
  }

  /**
   * Creates a target pool in the specified project and region using the data
   * included in the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async targetPoolsInsert(project: string, region: string, req: TargetPool, opts: TargetPoolsInsertOptions = {}): Promise<Operation> {
    req = serializeTargetPool(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetPools`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of target pools available to the specified project and
   * region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   */
  async targetPoolsList(project: string, region: string, opts: TargetPoolsListOptions = {}): Promise<TargetPoolList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetPools`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetPoolList(data);
  }

  /**
   * Removes health check URL from a target pool.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   * @param targetPool Name of the target pool to remove health checks from.
   */
  async targetPoolsRemoveHealthCheck(project: string, region: string, targetPool: string, req: TargetPoolsRemoveHealthCheckRequest, opts: TargetPoolsRemoveHealthCheckOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetPools/${ targetPool }/removeHealthCheck`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Removes instance URL from a target pool.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param targetPool Name of the TargetPool resource to remove instances from.
   */
  async targetPoolsRemoveInstance(project: string, region: string, targetPool: string, req: TargetPoolsRemoveInstanceRequest, opts: TargetPoolsRemoveInstanceOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetPools/${ targetPool }/removeInstance`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Changes a backup target pool's configurations.
   *
   * @param project Project ID for this request.
   * @param region Name of the region scoping this request.
   * @param targetPool Name of the TargetPool resource to set a backup pool for.
   */
  async targetPoolsSetBackup(project: string, region: string, targetPool: string, req: TargetReference, opts: TargetPoolsSetBackupOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetPools/${ targetPool }/setBackup`);
    if (opts.failoverRatio !== undefined) {
      url.searchParams.append("failoverRatio", String(opts.failoverRatio));
    }
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified TargetSslProxy resource.
   *
   * @param project Project ID for this request.
   * @param targetSslProxy Name of the TargetSslProxy resource to delete.
   */
  async targetSslProxiesDelete(project: string, targetSslProxy: string, opts: TargetSslProxiesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetSslProxies/${ targetSslProxy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified TargetSslProxy resource.
   *
   * @param project Project ID for this request.
   * @param targetSslProxy Name of the TargetSslProxy resource to return.
   */
  async targetSslProxiesGet(project: string, targetSslProxy: string): Promise<TargetSslProxy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetSslProxies/${ targetSslProxy }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetSslProxy(data);
  }

  /**
   * Creates a TargetSslProxy resource in the specified project using the data
   * included in the request.
   *
   * @param project Project ID for this request.
   */
  async targetSslProxiesInsert(project: string, req: TargetSslProxy, opts: TargetSslProxiesInsertOptions = {}): Promise<Operation> {
    req = serializeTargetSslProxy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetSslProxies`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of TargetSslProxy resources available to the specified
   * project.
   *
   * @param project Project ID for this request.
   */
  async targetSslProxiesList(project: string, opts: TargetSslProxiesListOptions = {}): Promise<TargetSslProxyList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetSslProxies`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetSslProxyList(data);
  }

  /**
   * Changes the BackendService for TargetSslProxy.
   *
   * @param project Project ID for this request.
   * @param targetSslProxy Name of the TargetSslProxy resource whose BackendService resource is to be set.
   */
  async targetSslProxiesSetBackendService(project: string, targetSslProxy: string, req: TargetSslProxiesSetBackendServiceRequest, opts: TargetSslProxiesSetBackendServiceOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetSslProxies/${ targetSslProxy }/setBackendService`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Changes the Certificate Map for TargetSslProxy.
   *
   * @param project Project ID for this request.
   * @param targetSslProxy Name of the TargetSslProxy resource whose CertificateMap is to be set. The name must be 1-63 characters long, and comply with RFC1035.
   */
  async targetSslProxiesSetCertificateMap(project: string, targetSslProxy: string, req: TargetSslProxiesSetCertificateMapRequest, opts: TargetSslProxiesSetCertificateMapOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetSslProxies/${ targetSslProxy }/setCertificateMap`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Changes the ProxyHeaderType for TargetSslProxy.
   *
   * @param project Project ID for this request.
   * @param targetSslProxy Name of the TargetSslProxy resource whose ProxyHeader is to be set.
   */
  async targetSslProxiesSetProxyHeader(project: string, targetSslProxy: string, req: TargetSslProxiesSetProxyHeaderRequest, opts: TargetSslProxiesSetProxyHeaderOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetSslProxies/${ targetSslProxy }/setProxyHeader`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Changes SslCertificates for TargetSslProxy.
   *
   * @param project Project ID for this request.
   * @param targetSslProxy Name of the TargetSslProxy resource whose SslCertificate resource is to be set.
   */
  async targetSslProxiesSetSslCertificates(project: string, targetSslProxy: string, req: TargetSslProxiesSetSslCertificatesRequest, opts: TargetSslProxiesSetSslCertificatesOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetSslProxies/${ targetSslProxy }/setSslCertificates`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Sets the SSL policy for TargetSslProxy. The SSL policy specifies the
   * server-side support for SSL features. This affects connections between
   * clients and the SSL proxy load balancer. They do not affect the connection
   * between the load balancer and the backends.
   *
   * @param project Project ID for this request.
   * @param targetSslProxy Name of the TargetSslProxy resource whose SSL policy is to be set. The name must be 1-63 characters long, and comply with RFC1035.
   */
  async targetSslProxiesSetSslPolicy(project: string, targetSslProxy: string, req: SslPolicyReference, opts: TargetSslProxiesSetSslPolicyOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetSslProxies/${ targetSslProxy }/setSslPolicy`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of all TargetTcpProxy resources, regional and global,
   * available to the specified project.
   *
   * @param project Name of the project scoping this request.
   */
  async targetTcpProxiesAggregatedList(project: string, opts: TargetTcpProxiesAggregatedListOptions = {}): Promise<TargetTcpProxyAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/targetTcpProxies`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetTcpProxyAggregatedList(data);
  }

  /**
   * Deletes the specified TargetTcpProxy resource.
   *
   * @param project Project ID for this request.
   * @param targetTcpProxy Name of the TargetTcpProxy resource to delete.
   */
  async targetTcpProxiesDelete(project: string, targetTcpProxy: string, opts: TargetTcpProxiesDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetTcpProxies/${ targetTcpProxy }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified TargetTcpProxy resource.
   *
   * @param project Project ID for this request.
   * @param targetTcpProxy Name of the TargetTcpProxy resource to return.
   */
  async targetTcpProxiesGet(project: string, targetTcpProxy: string): Promise<TargetTcpProxy> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetTcpProxies/${ targetTcpProxy }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetTcpProxy(data);
  }

  /**
   * Creates a TargetTcpProxy resource in the specified project using the data
   * included in the request.
   *
   * @param project Project ID for this request.
   */
  async targetTcpProxiesInsert(project: string, req: TargetTcpProxy, opts: TargetTcpProxiesInsertOptions = {}): Promise<Operation> {
    req = serializeTargetTcpProxy(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetTcpProxies`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of TargetTcpProxy resources available to the specified
   * project.
   *
   * @param project Project ID for this request.
   */
  async targetTcpProxiesList(project: string, opts: TargetTcpProxiesListOptions = {}): Promise<TargetTcpProxyList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetTcpProxies`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetTcpProxyList(data);
  }

  /**
   * Changes the BackendService for TargetTcpProxy.
   *
   * @param project Project ID for this request.
   * @param targetTcpProxy Name of the TargetTcpProxy resource whose BackendService resource is to be set.
   */
  async targetTcpProxiesSetBackendService(project: string, targetTcpProxy: string, req: TargetTcpProxiesSetBackendServiceRequest, opts: TargetTcpProxiesSetBackendServiceOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetTcpProxies/${ targetTcpProxy }/setBackendService`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Changes the ProxyHeaderType for TargetTcpProxy.
   *
   * @param project Project ID for this request.
   * @param targetTcpProxy Name of the TargetTcpProxy resource whose ProxyHeader is to be set.
   */
  async targetTcpProxiesSetProxyHeader(project: string, targetTcpProxy: string, req: TargetTcpProxiesSetProxyHeaderRequest, opts: TargetTcpProxiesSetProxyHeaderOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/targetTcpProxies/${ targetTcpProxy }/setProxyHeader`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves an aggregated list of target VPN gateways.
   *
   * @param project Project ID for this request.
   */
  async targetVpnGatewaysAggregatedList(project: string, opts: TargetVpnGatewaysAggregatedListOptions = {}): Promise<TargetVpnGatewayAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/targetVpnGateways`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetVpnGatewayAggregatedList(data);
  }

  /**
   * Deletes the specified target VPN gateway.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   * @param targetVpnGateway Name of the target VPN gateway to delete.
   */
  async targetVpnGatewaysDelete(project: string, region: string, targetVpnGateway: string, opts: TargetVpnGatewaysDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetVpnGateways/${ targetVpnGateway }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified target VPN gateway.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   * @param targetVpnGateway Name of the target VPN gateway to return.
   */
  async targetVpnGatewaysGet(project: string, region: string, targetVpnGateway: string): Promise<TargetVpnGateway> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetVpnGateways/${ targetVpnGateway }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetVpnGateway(data);
  }

  /**
   * Creates a target VPN gateway in the specified project and region using the
   * data included in the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async targetVpnGatewaysInsert(project: string, region: string, req: TargetVpnGateway, opts: TargetVpnGatewaysInsertOptions = {}): Promise<Operation> {
    req = serializeTargetVpnGateway(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetVpnGateways`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of target VPN gateways available to the specified project
   * and region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async targetVpnGatewaysList(project: string, region: string, opts: TargetVpnGatewaysListOptions = {}): Promise<TargetVpnGatewayList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetVpnGateways`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeTargetVpnGatewayList(data);
  }

  /**
   * Sets the labels on a TargetVpnGateway. To learn more about labels, read
   * the Labeling Resources documentation.
   *
   * @param project Project ID for this request.
   * @param region The region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async targetVpnGatewaysSetLabels(project: string, region: string, resource: string, req: RegionSetLabelsRequest, opts: TargetVpnGatewaysSetLabelsOptions = {}): Promise<Operation> {
    req = serializeRegionSetLabelsRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/targetVpnGateways/${ resource }/setLabels`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of all UrlMap resources, regional and global, available
   * to the specified project.
   *
   * @param project Name of the project scoping this request.
   */
  async urlMapsAggregatedList(project: string, opts: UrlMapsAggregatedListOptions = {}): Promise<UrlMapsAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/urlMaps`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeUrlMapsAggregatedList(data);
  }

  /**
   * Deletes the specified UrlMap resource.
   *
   * @param project Project ID for this request.
   * @param urlMap Name of the UrlMap resource to delete.
   */
  async urlMapsDelete(project: string, urlMap: string, opts: UrlMapsDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/urlMaps/${ urlMap }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified UrlMap resource.
   *
   * @param project Project ID for this request.
   * @param urlMap Name of the UrlMap resource to return.
   */
  async urlMapsGet(project: string, urlMap: string): Promise<UrlMap> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/urlMaps/${ urlMap }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeUrlMap(data);
  }

  /**
   * Creates a UrlMap resource in the specified project using the data included
   * in the request.
   *
   * @param project Project ID for this request.
   */
  async urlMapsInsert(project: string, req: UrlMap, opts: UrlMapsInsertOptions = {}): Promise<Operation> {
    req = serializeUrlMap(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/urlMaps`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Initiates a cache invalidation operation, invalidating the specified path,
   * scoped to the specified UrlMap. For more information, see [Invalidating
   * cached content](/cdn/docs/invalidating-cached-content).
   *
   * @param project Project ID for this request.
   * @param urlMap Name of the UrlMap scoping this request.
   */
  async urlMapsInvalidateCache(project: string, urlMap: string, req: CacheInvalidationRule, opts: UrlMapsInvalidateCacheOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/urlMaps/${ urlMap }/invalidateCache`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves the list of UrlMap resources available to the specified project.
   *
   * @param project Project ID for this request.
   */
  async urlMapsList(project: string, opts: UrlMapsListOptions = {}): Promise<UrlMapList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/urlMaps`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeUrlMapList(data);
  }

  /**
   * Patches the specified UrlMap resource with the data included in the
   * request. This method supports PATCH semantics and uses the JSON merge patch
   * format and processing rules.
   *
   * @param project Project ID for this request.
   * @param urlMap Name of the UrlMap resource to patch.
   */
  async urlMapsPatch(project: string, urlMap: string, req: UrlMap, opts: UrlMapsPatchOptions = {}): Promise<Operation> {
    req = serializeUrlMap(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/urlMaps/${ urlMap }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PATCH",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Updates the specified UrlMap resource with the data included in the
   * request.
   *
   * @param project Project ID for this request.
   * @param urlMap Name of the UrlMap resource to update.
   */
  async urlMapsUpdate(project: string, urlMap: string, req: UrlMap, opts: UrlMapsUpdateOptions = {}): Promise<Operation> {
    req = serializeUrlMap(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/urlMaps/${ urlMap }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "PUT",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Runs static validation for the UrlMap. In particular, the tests of the
   * provided UrlMap will be run. Calling this method does NOT create the
   * UrlMap.
   *
   * @param project Project ID for this request.
   * @param urlMap Name of the UrlMap resource to be validated as.
   */
  async urlMapsValidate(project: string, urlMap: string, req: UrlMapsValidateRequest): Promise<UrlMapsValidateResponse> {
    req = serializeUrlMapsValidateRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/global/urlMaps/${ urlMap }/validate`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as UrlMapsValidateResponse;
  }

  /**
   * Retrieves an aggregated list of VPN gateways.
   *
   * @param project Project ID for this request.
   */
  async vpnGatewaysAggregatedList(project: string, opts: VpnGatewaysAggregatedListOptions = {}): Promise<VpnGatewayAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/vpnGateways`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeVpnGatewayAggregatedList(data);
  }

  /**
   * Deletes the specified VPN gateway.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   * @param vpnGateway Name of the VPN gateway to delete.
   */
  async vpnGatewaysDelete(project: string, region: string, vpnGateway: string, opts: VpnGatewaysDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/vpnGateways/${ vpnGateway }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified VPN gateway.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   * @param vpnGateway Name of the VPN gateway to return.
   */
  async vpnGatewaysGet(project: string, region: string, vpnGateway: string): Promise<VpnGateway> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/vpnGateways/${ vpnGateway }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeVpnGateway(data);
  }

  /**
   * Returns the status for the specified VPN gateway.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   * @param vpnGateway Name of the VPN gateway to return.
   */
  async vpnGatewaysGetStatus(project: string, region: string, vpnGateway: string): Promise<VpnGatewaysGetStatusResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/vpnGateways/${ vpnGateway }/getStatus`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return data as VpnGatewaysGetStatusResponse;
  }

  /**
   * Creates a VPN gateway in the specified project and region using the data
   * included in the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async vpnGatewaysInsert(project: string, region: string, req: VpnGateway, opts: VpnGatewaysInsertOptions = {}): Promise<Operation> {
    req = serializeVpnGateway(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/vpnGateways`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of VPN gateways available to the specified project and
   * region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async vpnGatewaysList(project: string, region: string, opts: VpnGatewaysListOptions = {}): Promise<VpnGatewayList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/vpnGateways`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeVpnGatewayList(data);
  }

  /**
   * Sets the labels on a VpnGateway. To learn more about labels, read the
   * Labeling Resources documentation.
   *
   * @param project Project ID for this request.
   * @param region The region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async vpnGatewaysSetLabels(project: string, region: string, resource: string, req: RegionSetLabelsRequest, opts: VpnGatewaysSetLabelsOptions = {}): Promise<Operation> {
    req = serializeRegionSetLabelsRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/vpnGateways/${ resource }/setLabels`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Returns permissions that a caller has on the specified resource.
   *
   * @param project Project ID for this request.
   * @param region The name of the region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async vpnGatewaysTestIamPermissions(project: string, region: string, resource: string, req: TestPermissionsRequest): Promise<TestPermissionsResponse> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/vpnGateways/${ resource }/testIamPermissions`);
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return data as TestPermissionsResponse;
  }

  /**
   * Retrieves an aggregated list of VPN tunnels.
   *
   * @param project Project ID for this request.
   */
  async vpnTunnelsAggregatedList(project: string, opts: VpnTunnelsAggregatedListOptions = {}): Promise<VpnTunnelAggregatedList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/aggregated/vpnTunnels`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.includeAllScopes !== undefined) {
      url.searchParams.append("includeAllScopes", String(opts.includeAllScopes));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeVpnTunnelAggregatedList(data);
  }

  /**
   * Deletes the specified VpnTunnel resource.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   * @param vpnTunnel Name of the VpnTunnel resource to delete.
   */
  async vpnTunnelsDelete(project: string, region: string, vpnTunnel: string, opts: VpnTunnelsDeleteOptions = {}): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/vpnTunnels/${ vpnTunnel }`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified VpnTunnel resource.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   * @param vpnTunnel Name of the VpnTunnel resource to return.
   */
  async vpnTunnelsGet(project: string, region: string, vpnTunnel: string): Promise<VpnTunnel> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/vpnTunnels/${ vpnTunnel }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeVpnTunnel(data);
  }

  /**
   * Creates a VpnTunnel resource in the specified project and region using the
   * data included in the request.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async vpnTunnelsInsert(project: string, region: string, req: VpnTunnel, opts: VpnTunnelsInsertOptions = {}): Promise<Operation> {
    req = serializeVpnTunnel(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/vpnTunnels`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of VpnTunnel resources contained in the specified project
   * and region.
   *
   * @param project Project ID for this request.
   * @param region Name of the region for this request.
   */
  async vpnTunnelsList(project: string, region: string, opts: VpnTunnelsListOptions = {}): Promise<VpnTunnelList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/vpnTunnels`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeVpnTunnelList(data);
  }

  /**
   * Sets the labels on a VpnTunnel. To learn more about labels, read the
   * Labeling Resources documentation.
   *
   * @param project Project ID for this request.
   * @param region The region for this request.
   * @param resource Name or id of the resource for this request.
   */
  async vpnTunnelsSetLabels(project: string, region: string, resource: string, req: RegionSetLabelsRequest, opts: VpnTunnelsSetLabelsOptions = {}): Promise<Operation> {
    req = serializeRegionSetLabelsRequest(req);
    const url = new URL(`${this.#baseUrl}projects/${ project }/regions/${ region }/vpnTunnels/${ resource }/setLabels`);
    if (opts.requestId !== undefined) {
      url.searchParams.append("requestId", String(opts.requestId));
    }
    const body = JSON.stringify(req);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
      body,
    });
    return deserializeOperation(data);
  }

  /**
   * Deletes the specified zone-specific Operations resource.
   *
   * @param operation Name of the Operations resource to delete.
   * @param project Project ID for this request.
   * @param zone Name of the zone for this request.
   */
  async zoneOperationsDelete(operation: string, project: string, zone: string): Promise<void> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/operations/${ operation }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "DELETE",
    });
  }

  /**
   * Retrieves the specified zone-specific Operations resource.
   *
   * @param operation Name of the Operations resource to return.
   * @param project Project ID for this request.
   * @param zone Name of the zone for this request.
   */
  async zoneOperationsGet(operation: string, project: string, zone: string): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/operations/${ operation }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeOperation(data);
  }

  /**
   * Retrieves a list of Operation resources contained within the specified
   * zone.
   *
   * @param project Project ID for this request.
   * @param zone Name of the zone for request.
   */
  async zoneOperationsList(project: string, zone: string, opts: ZoneOperationsListOptions = {}): Promise<OperationList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/operations`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeOperationList(data);
  }

  /**
   * Waits for the specified Operation resource to return as `DONE` or for the
   * request to approach the 2 minute deadline, and retrieves the specified
   * Operation resource. This method waits for no more than the 2 minutes and
   * then returns the current state of the operation, which might be `DONE` or
   * still in progress. This method is called on a best-effort basis.
   * Specifically: - In uncommon cases, when the server is overloaded, the
   * request might return before the default deadline is reached, or might
   * return after zero seconds. - If the default deadline is reached, there is
   * no guarantee that the operation is actually done when the method returns.
   * Be prepared to retry if the operation is not `DONE`.
   *
   * @param operation Name of the Operations resource to return.
   * @param project Project ID for this request.
   * @param zone Name of the zone for this request.
   */
  async zoneOperationsWait(operation: string, project: string, zone: string): Promise<Operation> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }/operations/${ operation }/wait`);
    const data = await request(url.href, {
      client: this.#client,
      method: "POST",
    });
    return deserializeOperation(data);
  }

  /**
   * Returns the specified Zone resource.
   *
   * @param project Project ID for this request.
   * @param zone Name of the zone resource to return.
   */
  async zonesGet(project: string, zone: string): Promise<Zone> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones/${ zone }`);
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeZone(data);
  }

  /**
   * Retrieves the list of Zone resources available to the specified project.
   *
   * @param project Project ID for this request.
   */
  async zonesList(project: string, opts: ZonesListOptions = {}): Promise<ZoneList> {
    const url = new URL(`${this.#baseUrl}projects/${ project }/zones`);
    if (opts.filter !== undefined) {
      url.searchParams.append("filter", String(opts.filter));
    }
    if (opts.maxResults !== undefined) {
      url.searchParams.append("maxResults", String(opts.maxResults));
    }
    if (opts.orderBy !== undefined) {
      url.searchParams.append("orderBy", String(opts.orderBy));
    }
    if (opts.pageToken !== undefined) {
      url.searchParams.append("pageToken", String(opts.pageToken));
    }
    if (opts.returnPartialSuccess !== undefined) {
      url.searchParams.append("returnPartialSuccess", String(opts.returnPartialSuccess));
    }
    const data = await request(url.href, {
      client: this.#client,
      method: "GET",
    });
    return deserializeZoneList(data);
  }
}

/**
 * A specification of the type and number of accelerator cards attached to the
 * instance.
 */
export interface AcceleratorConfig {
  /**
   * The number of the guest accelerator cards exposed to this instance.
   */
  acceleratorCount?: number;
  /**
   * Full or partial URL of the accelerator type resource to attach to this
   * instance. For example:
   * projects/my-project/zones/us-central1-c/acceleratorTypes/nvidia-tesla-p100
   * If you are creating an instance template, specify only the accelerator
   * name. See GPUs on Compute Engine for a full list of accelerator types.
   */
  acceleratorType?: string;
}

/**
 * Represents an Accelerator Type resource. Google Cloud Platform provides
 * graphics processing units (accelerators) that you can add to VM instances to
 * improve or accelerate performance when working with intensive workloads. For
 * more information, read GPUs on Compute Engine.
 */
export interface AcceleratorType {
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * [Output Only] The deprecation status associated with this accelerator
   * type.
   */
  deprecated?: DeprecationStatus;
  /**
   * [Output Only] An optional textual description of the resource.
   */
  description?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] The type of the resource. Always compute#acceleratorType for
   * accelerator types.
   */
  kind?: string;
  /**
   * [Output Only] Maximum number of accelerator cards allowed per instance.
   */
  maximumCardsPerInstance?: number;
  /**
   * [Output Only] Name of the resource.
   */
  name?: string;
  /**
   * [Output Only] Server-defined, fully qualified URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] The name of the zone where the accelerator type resides,
   * such as us-central1-a. You must specify this field as part of the HTTP
   * request URL. It is not settable as a field in the request body.
   */
  zone?: string;
}

function serializeAcceleratorType(data: any): AcceleratorType {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeAcceleratorType(data: any): AcceleratorType {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface AcceleratorTypeAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of AcceleratorTypesScopedList resources.
   */
  items?: {
    [key: string]: AcceleratorTypesScopedList
  };
  /**
   * [Output Only] Type of resource. Always
   * compute#acceleratorTypeAggregatedList for aggregated lists of accelerator
   * types.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeAcceleratorTypeAggregatedList(data: any): AcceleratorTypeAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeAcceleratorTypesScopedList(v)]))) : undefined,
  };
}

function deserializeAcceleratorTypeAggregatedList(data: any): AcceleratorTypeAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeAcceleratorTypesScopedList(v)]))) : undefined,
  };
}

/**
 * Contains a list of accelerator types.
 */
export interface AcceleratorTypeList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of AcceleratorType resources.
   */
  items?: AcceleratorType[];
  /**
   * [Output Only] Type of resource. Always compute#acceleratorTypeList for
   * lists of accelerator types.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeAcceleratorTypeList(data: any): AcceleratorTypeList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeAcceleratorType(item))) : undefined,
  };
}

function deserializeAcceleratorTypeList(data: any): AcceleratorTypeList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeAcceleratorType(item))) : undefined,
  };
}

/**
 * Additional options for Compute#acceleratorTypesAggregatedList.
 */
export interface AcceleratorTypesAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#acceleratorTypesList.
 */
export interface AcceleratorTypesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface AcceleratorTypesScopedList {
  /**
   * [Output Only] A list of accelerator types contained in this scope.
   */
  acceleratorTypes?: AcceleratorType[];
  /**
   * [Output Only] An informational warning that appears when the accelerator
   * types list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeAcceleratorTypesScopedList(data: any): AcceleratorTypesScopedList {
  return {
    ...data,
    acceleratorTypes: data["acceleratorTypes"] !== undefined ? data["acceleratorTypes"].map((item: any) => (serializeAcceleratorType(item))) : undefined,
  };
}

function deserializeAcceleratorTypesScopedList(data: any): AcceleratorTypesScopedList {
  return {
    ...data,
    acceleratorTypes: data["acceleratorTypes"] !== undefined ? data["acceleratorTypes"].map((item: any) => (deserializeAcceleratorType(item))) : undefined,
  };
}

/**
 * An access configuration attached to an instance's network interface. Only
 * one access config per instance is supported.
 */
export interface AccessConfig {
  /**
   * The first IPv6 address of the external IPv6 range associated with this
   * instance, prefix length is stored in externalIpv6PrefixLength in
   * ipv6AccessConfig. To use a static external IP address, it must be unused
   * and in the same region as the instance's zone. If not specified, Google
   * Cloud will automatically assign an external IPv6 address from the
   * instance's subnetwork.
   */
  externalIpv6?: string;
  /**
   * The prefix length of the external IPv6 range.
   */
  externalIpv6PrefixLength?: number;
  /**
   * [Output Only] Type of the resource. Always compute#accessConfig for access
   * configs.
   */
  kind?: string;
  /**
   * The name of this access configuration. The default and recommended name is
   * External NAT, but you can use any arbitrary string, such as My external IP
   * or Network Access.
   */
  name?: string;
  /**
   * An external IP address associated with this instance. Specify an unused
   * static external IP address available to the project or leave this field
   * undefined to use an IP from a shared ephemeral IP address pool. If you
   * specify a static external IP address, it must live in the same region as
   * the zone of the instance.
   */
  natIP?: string;
  /**
   * This signifies the networking tier used for configuring this access
   * configuration and can only take the following values: PREMIUM, STANDARD. If
   * an AccessConfig is specified without a valid external IP address, an
   * ephemeral IP will be created with this networkTier. If an AccessConfig with
   * a valid external IP address is specified, it must match that of the
   * networkTier associated with the Address resource owning that IP.
   */
  networkTier?:  | "FIXED_STANDARD" | "PREMIUM" | "STANDARD" | "STANDARD_OVERRIDES_FIXED_STANDARD";
  /**
   * The DNS domain name for the public PTR record. You can set this field only
   * if the `setPublicPtr` field is enabled in accessConfig. If this field is
   * unspecified in ipv6AccessConfig, a default PTR record will be createc for
   * first IP in associated external IPv6 range.
   */
  publicPtrDomainName?: string;
  /**
   * Specifies whether a public DNS 'PTR' record should be created to map the
   * external IP address of the instance to a DNS domain name. This field is not
   * used in ipv6AccessConfig. A default PTR record will be created if the VM
   * has external IPv6 range associated.
   */
  setPublicPtr?: boolean;
  /**
   * The type of configuration. The default and only option is ONE_TO_ONE_NAT.
   */
  type?:  | "DIRECT_IPV6" | "ONE_TO_ONE_NAT";
}

/**
 * Represents an IP Address resource. Google Compute Engine has two IP Address
 * resources: * [Global (external and
 * internal)](https://cloud.google.com/compute/docs/reference/rest/v1/globalAddresses)
 * * [Regional (external and
 * internal)](https://cloud.google.com/compute/docs/reference/rest/v1/addresses)
 * For more information, see Reserving a static external IP address.
 */
export interface Address {
  /**
   * The static IP address represented by this resource.
   */
  address?: string;
  /**
   * The type of address to reserve, either INTERNAL or EXTERNAL. If
   * unspecified, defaults to EXTERNAL.
   */
  addressType?:  | "EXTERNAL" | "INTERNAL" | "UNSPECIFIED_TYPE";
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this field when you
   * create the resource.
   */
  description?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * The endpoint type of this address, which should be VM or NETLB. This is
   * used for deciding which type of endpoint this address can be used after the
   * external IPv6 address reservation.
   */
  ipv6EndpointType?:  | "NETLB" | "VM";
  /**
   * The IP version that will be used by this address. Valid options are IPV4
   * or IPV6. This can only be specified for a global address.
   */
  ipVersion?:  | "IPV4" | "IPV6" | "UNSPECIFIED_VERSION";
  /**
   * [Output Only] Type of the resource. Always compute#address for addresses.
   */
  kind?: string;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a
   * lowercase letter, and all following characters (except for the last
   * character) must be a dash, lowercase letter, or digit. The last character
   * must be a lowercase letter or digit.
   */
  name?: string;
  /**
   * The URL of the network in which to reserve the address. This field can
   * only be used with INTERNAL type with the VPC_PEERING purpose.
   */
  network?: string;
  /**
   * This signifies the networking tier used for configuring this address and
   * can only take the following values: PREMIUM or STANDARD. Internal IP
   * addresses are always Premium Tier; global external IP addresses are always
   * Premium Tier; regional external IP addresses can be either Standard or
   * Premium Tier. If this field is not specified, it is assumed to be PREMIUM.
   */
  networkTier?:  | "FIXED_STANDARD" | "PREMIUM" | "STANDARD" | "STANDARD_OVERRIDES_FIXED_STANDARD";
  /**
   * The prefix length if the resource represents an IP range.
   */
  prefixLength?: number;
  /**
   * The purpose of this resource, which can be one of the following values: -
   * GCE_ENDPOINT for addresses that are used by VM instances, alias IP ranges,
   * load balancers, and similar resources. - DNS_RESOLVER for a DNS resolver
   * address in a subnetwork for a Cloud DNS inbound forwarder IP addresses
   * (regional internal IP address in a subnet of a VPC network) - VPC_PEERING
   * for global internal IP addresses used for private services access allocated
   * ranges. - NAT_AUTO for the regional external IP addresses used by Cloud NAT
   * when allocating addresses using automatic NAT IP address allocation. -
   * IPSEC_INTERCONNECT for addresses created from a private IP range that are
   * reserved for a VLAN attachment in an *HA VPN over Cloud Interconnect*
   * configuration. These addresses are regional resources. -
   * `SHARED_LOADBALANCER_VIP` for an internal IP address that is assigned to
   * multiple internal forwarding rules. - `PRIVATE_SERVICE_CONNECT` for a
   * private network address that is used to configure Private Service Connect.
   * Only global internal addresses can use this purpose.
   */
  purpose?:  | "DNS_RESOLVER" | "GCE_ENDPOINT" | "IPSEC_INTERCONNECT" | "NAT_AUTO" | "PRIVATE_SERVICE_CONNECT" | "SERVERLESS" | "SHARED_LOADBALANCER_VIP" | "VPC_PEERING";
  /**
   * [Output Only] The URL of the region where a regional address resides. For
   * regional addresses, you must specify the region as a path parameter in the
   * HTTP request URL. *This field is not applicable to global addresses.*
   */
  region?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * [Output Only] The status of the address, which can be one of RESERVING,
   * RESERVED, or IN_USE. An address that is RESERVING is currently in the
   * process of being reserved. A RESERVED address is currently reserved and
   * available to use. An IN_USE address is currently being used by another
   * resource and is not available.
   */
  status?:  | "IN_USE" | "RESERVED" | "RESERVING";
  /**
   * The URL of the subnetwork in which to reserve the address. If an IP
   * address is specified, it must be within the subnetwork's IP range. This
   * field can only be used with INTERNAL type with a GCE_ENDPOINT or
   * DNS_RESOLVER purpose.
   */
  subnetwork?: string;
  /**
   * [Output Only] The URLs of the resources that are using this address.
   */
  users?: string[];
}

function serializeAddress(data: any): Address {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeAddress(data: any): Address {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface AddressAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of AddressesScopedList resources.
   */
  items?: {
    [key: string]: AddressesScopedList
  };
  /**
   * [Output Only] Type of resource. Always compute#addressAggregatedList for
   * aggregated lists of addresses.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeAddressAggregatedList(data: any): AddressAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeAddressesScopedList(v)]))) : undefined,
  };
}

function deserializeAddressAggregatedList(data: any): AddressAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeAddressesScopedList(v)]))) : undefined,
  };
}

/**
 * Additional options for Compute#addressesAggregatedList.
 */
export interface AddressesAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#addressesDelete.
 */
export interface AddressesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#addressesInsert.
 */
export interface AddressesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#addressesList.
 */
export interface AddressesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface AddressesScopedList {
  /**
   * [Output Only] A list of addresses contained in this scope.
   */
  addresses?: Address[];
  /**
   * [Output Only] Informational warning which replaces the list of addresses
   * when the list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeAddressesScopedList(data: any): AddressesScopedList {
  return {
    ...data,
    addresses: data["addresses"] !== undefined ? data["addresses"].map((item: any) => (serializeAddress(item))) : undefined,
  };
}

function deserializeAddressesScopedList(data: any): AddressesScopedList {
  return {
    ...data,
    addresses: data["addresses"] !== undefined ? data["addresses"].map((item: any) => (deserializeAddress(item))) : undefined,
  };
}

/**
 * Additional options for Compute#addressesSetLabels.
 */
export interface AddressesSetLabelsOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Contains a list of addresses.
 */
export interface AddressList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of Address resources.
   */
  items?: Address[];
  /**
   * [Output Only] Type of resource. Always compute#addressList for lists of
   * addresses.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeAddressList(data: any): AddressList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeAddress(item))) : undefined,
  };
}

function deserializeAddressList(data: any): AddressList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeAddress(item))) : undefined,
  };
}

/**
 * Specifies options for controlling advanced machine features. Options that
 * would traditionally be configured in a BIOS belong here. Features that
 * require operating system support may have corresponding entries in the
 * GuestOsFeatures of an Image (e.g., whether or not the OS in the Image
 * supports nested virtualization being enabled or disabled).
 */
export interface AdvancedMachineFeatures {
  /**
   * Whether to enable nested virtualization or not (default is false).
   */
  enableNestedVirtualization?: boolean;
  /**
   * Whether to enable UEFI networking for instance creation.
   */
  enableUefiNetworking?: boolean;
  /**
   * The number of threads per physical core. To disable simultaneous
   * multithreading (SMT) set this to 1. If unset, the maximum number of threads
   * supported per core by the underlying processor is assumed.
   */
  threadsPerCore?: number;
  /**
   * The number of physical cores to expose to an instance. Multiply by the
   * number of threads per core to compute the total number of virtual CPUs to
   * expose to the instance. If unset, the number of cores is inferred from the
   * instance's nominal CPU count and the underlying platform's SMT width.
   */
  visibleCoreCount?: number;
}

/**
 * An alias IP range attached to an instance's network interface.
 */
export interface AliasIpRange {
  /**
   * The IP alias ranges to allocate for this interface. This IP CIDR range
   * must belong to the specified subnetwork and cannot contain IP addresses
   * reserved by system or used by other network interfaces. This range may be a
   * single IP address (such as 10.2.3.4), a netmask (such as /24) or a
   * CIDR-formatted string (such as 10.1.2.0/24).
   */
  ipCidrRange?: string;
  /**
   * The name of a subnetwork secondary IP range from which to allocate an IP
   * alias range. If not specified, the primary range of the subnetwork is used.
   */
  subnetworkRangeName?: string;
}

/**
 * [Output Only] Contains output only fields.
 */
export interface AllocationResourceStatus {
  /**
   * Allocation Properties of this reservation.
   */
  specificSkuAllocation?: AllocationResourceStatusSpecificSKUAllocation;
}

/**
 * Contains Properties set for the reservation.
 */
export interface AllocationResourceStatusSpecificSKUAllocation {
  /**
   * ID of the instance template used to populate reservation properties.
   */
  sourceInstanceTemplateId?: string;
}

export interface AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk {
  /**
   * Specifies the size of the disk in base-2 GB.
   */
  diskSizeGb?: bigint;
  /**
   * Specifies the disk interface to use for attaching this disk, which is
   * either SCSI or NVME. The default is SCSI. For performance characteristics
   * of SCSI over NVMe, see Local SSD performance.
   */
  interface?:  | "NVME" | "SCSI";
}

function serializeAllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk(data: any): AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk {
  return {
    ...data,
    diskSizeGb: data["diskSizeGb"] !== undefined ? String(data["diskSizeGb"]) : undefined,
  };
}

function deserializeAllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk(data: any): AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk {
  return {
    ...data,
    diskSizeGb: data["diskSizeGb"] !== undefined ? BigInt(data["diskSizeGb"]) : undefined,
  };
}

/**
 * Properties of the SKU instances being reserved. Next ID: 9
 */
export interface AllocationSpecificSKUAllocationReservedInstanceProperties {
  /**
   * Specifies accelerator type and count.
   */
  guestAccelerators?: AcceleratorConfig[];
  /**
   * Specifies amount of local ssd to reserve with each instance. The type of
   * disk is local-ssd.
   */
  localSsds?: AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk[];
  /**
   * An opaque location hint used to place the allocation close to other
   * resources. This field is for use by internal tools that use the public API.
   */
  locationHint?: string;
  /**
   * Specifies type of machine (name only) which has fixed number of vCPUs and
   * fixed amount of memory. This also includes specifying custom machine type
   * following custom-NUMBER_OF_CPUS-AMOUNT_OF_MEMORY pattern.
   */
  machineType?: string;
  /**
   * Minimum cpu platform the reservation.
   */
  minCpuPlatform?: string;
}

function serializeAllocationSpecificSKUAllocationReservedInstanceProperties(data: any): AllocationSpecificSKUAllocationReservedInstanceProperties {
  return {
    ...data,
    localSsds: data["localSsds"] !== undefined ? data["localSsds"].map((item: any) => (serializeAllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk(item))) : undefined,
  };
}

function deserializeAllocationSpecificSKUAllocationReservedInstanceProperties(data: any): AllocationSpecificSKUAllocationReservedInstanceProperties {
  return {
    ...data,
    localSsds: data["localSsds"] !== undefined ? data["localSsds"].map((item: any) => (deserializeAllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk(item))) : undefined,
  };
}

/**
 * This reservation type allows to pre allocate specific instance
 * configuration. Next ID: 6
 */
export interface AllocationSpecificSKUReservation {
  /**
   * [Output Only] Indicates how many instances are actually usable currently.
   */
  assuredCount?: bigint;
  /**
   * Specifies the number of resources that are allocated.
   */
  count?: bigint;
  /**
   * The instance properties for the reservation.
   */
  instanceProperties?: AllocationSpecificSKUAllocationReservedInstanceProperties;
  /**
   * [Output Only] Indicates how many instances are in use.
   */
  inUseCount?: bigint;
  /**
   * Specifies the instance template to create the reservation. If you use this
   * field, you must exclude the instanceProperties field. This field is
   * optional, and it can be a full or partial URL. For example, the following
   * are all valid URLs to an instance template: -
   * https://www.googleapis.com/compute/v1/projects/project
   * /global/instanceTemplates/instanceTemplate -
   * projects/project/global/instanceTemplates/instanceTemplate -
   * global/instanceTemplates/instanceTemplate
   */
  sourceInstanceTemplate?: string;
}

function serializeAllocationSpecificSKUReservation(data: any): AllocationSpecificSKUReservation {
  return {
    ...data,
    assuredCount: data["assuredCount"] !== undefined ? String(data["assuredCount"]) : undefined,
    count: data["count"] !== undefined ? String(data["count"]) : undefined,
    instanceProperties: data["instanceProperties"] !== undefined ? serializeAllocationSpecificSKUAllocationReservedInstanceProperties(data["instanceProperties"]) : undefined,
    inUseCount: data["inUseCount"] !== undefined ? String(data["inUseCount"]) : undefined,
  };
}

function deserializeAllocationSpecificSKUReservation(data: any): AllocationSpecificSKUReservation {
  return {
    ...data,
    assuredCount: data["assuredCount"] !== undefined ? BigInt(data["assuredCount"]) : undefined,
    count: data["count"] !== undefined ? BigInt(data["count"]) : undefined,
    instanceProperties: data["instanceProperties"] !== undefined ? deserializeAllocationSpecificSKUAllocationReservedInstanceProperties(data["instanceProperties"]) : undefined,
    inUseCount: data["inUseCount"] !== undefined ? BigInt(data["inUseCount"]) : undefined,
  };
}

/**
 * An instance-attached disk resource.
 */
export interface AttachedDisk {
  /**
   * [Output Only] The architecture of the attached disk. Valid values are
   * ARM64 or X86_64.
   */
  architecture?:  | "ARCHITECTURE_UNSPECIFIED" | "ARM64" | "X86_64";
  /**
   * Specifies whether the disk will be auto-deleted when the instance is
   * deleted (but not when the disk is detached from the instance).
   */
  autoDelete?: boolean;
  /**
   * Indicates that this is a boot disk. The virtual machine will use the first
   * partition of the disk for its root filesystem.
   */
  boot?: boolean;
  /**
   * Specifies a unique device name of your choice that is reflected into the
   * /dev/disk/by-id/google-* tree of a Linux operating system running within
   * the instance. This name can be used to reference the device for mounting,
   * resizing, and so on, from within the instance. If not specified, the server
   * chooses a default device name to apply to this disk, in the form
   * persistent-disk-x, where x is a number assigned by Google Compute Engine.
   * This field is only applicable for persistent disks.
   */
  deviceName?: string;
  /**
   * Encrypts or decrypts a disk using a customer-supplied encryption key. If
   * you are creating a new disk, this field encrypts the new disk using an
   * encryption key that you provide. If you are attaching an existing disk that
   * is already encrypted, this field decrypts the disk using the
   * customer-supplied encryption key. If you encrypt a disk using a
   * customer-supplied key, you must provide the same key again when you attempt
   * to use this resource at a later time. For example, you must provide the key
   * when you create a snapshot or an image from the disk or when you attach the
   * disk to a virtual machine instance. If you do not provide an encryption
   * key, then the disk will be encrypted using an automatically generated key
   * and you do not need to provide a key to use the disk later. Instance
   * templates do not store customer-supplied encryption keys, so you cannot use
   * your own keys to encrypt disks in a managed instance group.
   */
  diskEncryptionKey?: CustomerEncryptionKey;
  /**
   * The size of the disk in GB.
   */
  diskSizeGb?: bigint;
  /**
   * [Input Only] Whether to force attach the regional disk even if it's
   * currently attached to another instance. If you try to force attach a zonal
   * disk to an instance, you will receive an error.
   */
  forceAttach?: boolean;
  /**
   * A list of features to enable on the guest operating system. Applicable
   * only for bootable images. Read Enabling guest operating system features to
   * see a list of available options.
   */
  guestOsFeatures?: GuestOsFeature[];
  /**
   * [Output Only] A zero-based index to this disk, where 0 is reserved for the
   * boot disk. If you have many disks attached to an instance, each disk would
   * have a unique index number.
   */
  index?: number;
  /**
   * [Input Only] Specifies the parameters for a new disk that will be created
   * alongside the new instance. Use initialization parameters to create boot
   * disks or local SSDs attached to the new instance. This property is mutually
   * exclusive with the source property; you can only define one or the other,
   * but not both.
   */
  initializeParams?: AttachedDiskInitializeParams;
  /**
   * Specifies the disk interface to use for attaching this disk, which is
   * either SCSI or NVME. For most machine types, the default is SCSI. Local
   * SSDs can use either NVME or SCSI. In certain configurations, persistent
   * disks can use NVMe. For more information, see About persistent disks.
   */
  interface?:  | "NVME" | "SCSI";
  /**
   * [Output Only] Type of the resource. Always compute#attachedDisk for
   * attached disks.
   */
  kind?: string;
  /**
   * [Output Only] Any valid publicly visible licenses.
   */
  licenses?: string[];
  /**
   * The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If
   * not specified, the default is to attach the disk in READ_WRITE mode.
   */
  mode?:  | "READ_ONLY" | "READ_WRITE";
  /**
   * [Output Only] shielded vm initial state stored on disk
   */
  shieldedInstanceInitialState?: InitialStateConfig;
  /**
   * Specifies a valid partial or full URL to an existing Persistent Disk
   * resource. When creating a new instance, one of initializeParams.sourceImage
   * or initializeParams.sourceSnapshot or disks.source is required except for
   * local SSD. If desired, you can also attach existing non-root persistent
   * disks using this property. This field is only applicable for persistent
   * disks. Note that for InstanceTemplate, specify the disk name for zonal
   * disk, and the URL for regional disk.
   */
  source?: string;
  /**
   * Specifies the type of the disk, either SCRATCH or PERSISTENT. If not
   * specified, the default is PERSISTENT.
   */
  type?:  | "PERSISTENT" | "SCRATCH";
}

function serializeAttachedDisk(data: any): AttachedDisk {
  return {
    ...data,
    diskSizeGb: data["diskSizeGb"] !== undefined ? String(data["diskSizeGb"]) : undefined,
    initializeParams: data["initializeParams"] !== undefined ? serializeAttachedDiskInitializeParams(data["initializeParams"]) : undefined,
    shieldedInstanceInitialState: data["shieldedInstanceInitialState"] !== undefined ? serializeInitialStateConfig(data["shieldedInstanceInitialState"]) : undefined,
  };
}

function deserializeAttachedDisk(data: any): AttachedDisk {
  return {
    ...data,
    diskSizeGb: data["diskSizeGb"] !== undefined ? BigInt(data["diskSizeGb"]) : undefined,
    initializeParams: data["initializeParams"] !== undefined ? deserializeAttachedDiskInitializeParams(data["initializeParams"]) : undefined,
    shieldedInstanceInitialState: data["shieldedInstanceInitialState"] !== undefined ? deserializeInitialStateConfig(data["shieldedInstanceInitialState"]) : undefined,
  };
}

/**
 * [Input Only] Specifies the parameters for a new disk that will be created
 * alongside the new instance. Use initialization parameters to create boot
 * disks or local SSDs attached to the new instance. This field is persisted and
 * returned for instanceTemplate and not returned in the context of instance.
 * This property is mutually exclusive with the source property; you can only
 * define one or the other, but not both.
 */
export interface AttachedDiskInitializeParams {
  /**
   * The architecture of the attached disk. Valid values are arm64 or x86_64.
   */
  architecture?:  | "ARCHITECTURE_UNSPECIFIED" | "ARM64" | "X86_64";
  /**
   * An optional description. Provide this property when creating the disk.
   */
  description?: string;
  /**
   * Specifies the disk name. If not specified, the default is to use the name
   * of the instance. If a disk with the same name already exists in the given
   * region, the existing disk is attached to the new instance and the new disk
   * is not created.
   */
  diskName?: string;
  /**
   * Specifies the size of the disk in base-2 GB. The size must be at least 10
   * GB. If you specify a sourceImage, which is required for boot disks, the
   * default size is the size of the sourceImage. If you do not specify a
   * sourceImage, the default disk size is 500 GB.
   */
  diskSizeGb?: bigint;
  /**
   * Specifies the disk type to use to create the instance. If not specified,
   * the default is pd-standard, specified using the full URL. For example:
   * https://www.googleapis.com/compute/v1/projects/project/zones/zone
   * /diskTypes/pd-standard For a full list of acceptable values, see Persistent
   * disk types. If you specify this field when creating a VM, you can provide
   * either the full or partial URL. For example, the following values are
   * valid: - https://www.googleapis.com/compute/v1/projects/project/zones/zone
   * /diskTypes/diskType - projects/project/zones/zone/diskTypes/diskType -
   * zones/zone/diskTypes/diskType If you specify this field when creating or
   * updating an instance template or all-instances configuration, specify the
   * type of the disk, not the URL. For example: pd-standard.
   */
  diskType?: string;
  /**
   * Labels to apply to this disk. These can be later modified by the
   * disks.setLabels method. This field is only applicable for persistent disks.
   */
  labels?: {
    [key: string]: string
  };
  /**
   * A list of publicly visible licenses. Reserved for Google's use.
   */
  licenses?: string[];
  /**
   * Specifies which action to take on instance update with this disk. Default
   * is to use the existing disk.
   */
  onUpdateAction?:  | "RECREATE_DISK" | "RECREATE_DISK_IF_SOURCE_CHANGED" | "USE_EXISTING_DISK";
  /**
   * Indicates how many IOPS to provision for the disk. This sets the number of
   * I/O operations per second that the disk can handle. Values must be between
   * 10,000 and 120,000. For more details, see the Extreme persistent disk
   * documentation.
   */
  provisionedIops?: bigint;
  /**
   * Resource manager tags to be bound to the disk. Tag keys and values have
   * the same definition as resource manager tags. Keys must be in the format
   * `tagKeys/{tag_key_id}`, and values are in the format `tagValues/456`. The
   * field is ignored (both PUT & PATCH) when empty.
   */
  resourceManagerTags?: {
    [key: string]: string
  };
  /**
   * Resource policies applied to this disk for automatic snapshot creations.
   * Specified using the full or partial URL. For instance template, specify
   * only the resource policy name.
   */
  resourcePolicies?: string[];
  /**
   * The source image to create this disk. When creating a new instance, one of
   * initializeParams.sourceImage or initializeParams.sourceSnapshot or
   * disks.source is required except for local SSD. To create a disk with one of
   * the public operating system images, specify the image by its family name.
   * For example, specify family/debian-9 to use the latest Debian 9 image:
   * projects/debian-cloud/global/images/family/debian-9 Alternatively, use a
   * specific version of a public operating system image:
   * projects/debian-cloud/global/images/debian-9-stretch-vYYYYMMDD To create a
   * disk with a custom image that you created, specify the image name in the
   * following format: global/images/my-custom-image You can also specify a
   * custom image by its image family, which returns the latest version of the
   * image in that family. Replace the image name with family/family-name:
   * global/images/family/my-image-family If the source image is deleted later,
   * this field will not be set.
   */
  sourceImage?: string;
  /**
   * The customer-supplied encryption key of the source image. Required if the
   * source image is protected by a customer-supplied encryption key.
   * InstanceTemplate and InstancePropertiesPatch do not store customer-supplied
   * encryption keys, so you cannot create disks for instances in a managed
   * instance group if the source images are encrypted with your own keys.
   */
  sourceImageEncryptionKey?: CustomerEncryptionKey;
  /**
   * The source snapshot to create this disk. When creating a new instance, one
   * of initializeParams.sourceSnapshot or initializeParams.sourceImage or
   * disks.source is required except for local SSD. To create a disk with a
   * snapshot that you created, specify the snapshot name in the following
   * format: global/snapshots/my-backup If the source snapshot is deleted later,
   * this field will not be set.
   */
  sourceSnapshot?: string;
  /**
   * The customer-supplied encryption key of the source snapshot.
   */
  sourceSnapshotEncryptionKey?: CustomerEncryptionKey;
}

function serializeAttachedDiskInitializeParams(data: any): AttachedDiskInitializeParams {
  return {
    ...data,
    diskSizeGb: data["diskSizeGb"] !== undefined ? String(data["diskSizeGb"]) : undefined,
    provisionedIops: data["provisionedIops"] !== undefined ? String(data["provisionedIops"]) : undefined,
  };
}

function deserializeAttachedDiskInitializeParams(data: any): AttachedDiskInitializeParams {
  return {
    ...data,
    diskSizeGb: data["diskSizeGb"] !== undefined ? BigInt(data["diskSizeGb"]) : undefined,
    provisionedIops: data["provisionedIops"] !== undefined ? BigInt(data["provisionedIops"]) : undefined,
  };
}

/**
 * Specifies the audit configuration for a service. The configuration
 * determines which permission types are logged, and what identities, if any,
 * are exempted from logging. An AuditConfig must have one or more
 * AuditLogConfigs. If there are AuditConfigs for both `allServices` and a
 * specific service, the union of the two AuditConfigs is used for that service:
 * the log_types specified in each AuditConfig are enabled, and the
 * exempted_members in each AuditLogConfig are exempted. Example Policy with
 * multiple AuditConfigs: { "audit_configs": [ { "service": "allServices",
 * "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [
 * "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type":
 * "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com",
 * "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type":
 * "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For
 * sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ
 * logging. It also exempts jose@example.com from DATA_READ logging, and
 * aliya@example.com from DATA_WRITE logging.
 */
export interface AuditConfig {
  /**
   * The configuration for logging of each type of permission.
   */
  auditLogConfigs?: AuditLogConfig[];
  /**
   * This is deprecated and has no effect. Do not use.
   */
  exemptedMembers?: string[];
  /**
   * Specifies a service that will be enabled for audit logging. For example,
   * `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a
   * special value that covers all services.
   */
  service?: string;
}

/**
 * Provides the configuration for logging a type of permissions. Example: {
 * "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [
 * "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables
 * 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from
 * DATA_READ logging.
 */
export interface AuditLogConfig {
  /**
   * Specifies the identities that do not cause logging for this type of
   * permission. Follows the same format of Binding.members.
   */
  exemptedMembers?: string[];
  /**
   * This is deprecated and has no effect. Do not use.
   */
  ignoreChildExemptions?: boolean;
  /**
   * The log type that this config enables.
   */
  logType?:  | "ADMIN_READ" | "DATA_READ" | "DATA_WRITE" | "LOG_TYPE_UNSPECIFIED";
}

/**
 * This is deprecated and has no effect. Do not use.
 */
export interface AuthorizationLoggingOptions {
  /**
   * This is deprecated and has no effect. Do not use.
   */
  permissionType?:  | "ADMIN_READ" | "ADMIN_WRITE" | "DATA_READ" | "DATA_WRITE" | "PERMISSION_TYPE_UNSPECIFIED";
}

/**
 * Represents an Autoscaler resource. Google Compute Engine has two Autoscaler
 * resources: * [Zonal](/compute/docs/reference/rest/v1/autoscalers) *
 * [Regional](/compute/docs/reference/rest/v1/regionAutoscalers) Use autoscalers
 * to automatically add or delete instances from a managed instance group
 * according to your defined autoscaling policy. For more information, read
 * Autoscaling Groups of Instances. For zonal managed instance groups resource,
 * use the autoscaler resource. For regional managed instance groups, use the
 * regionAutoscalers resource.
 */
export interface Autoscaler {
  /**
   * The configuration parameters for the autoscaling algorithm. You can define
   * one or more signals for an autoscaler: cpuUtilization,
   * customMetricUtilizations, and loadBalancingUtilization. If none of these
   * are specified, the default will be to autoscale based on cpuUtilization to
   * 0.6 or 60%.
   */
  autoscalingPolicy?: AutoscalingPolicy;
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of the resource. Always compute#autoscaler for
   * autoscalers.
   */
  kind?: string;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * [Output Only] Target recommended MIG size (number of instances) computed
   * by autoscaler. Autoscaler calculates the recommended MIG size even when the
   * autoscaling policy mode is different from ON. This field is empty when
   * autoscaler is not connected to an existing managed instance group or
   * autoscaler did not generate its prediction.
   */
  recommendedSize?: number;
  /**
   * [Output Only] URL of the region where the instance group resides (for
   * autoscalers living in regional scope).
   */
  region?: string;
  /**
   * [Output Only] Status information of existing scaling schedules.
   */
  scalingScheduleStatus?: {
    [key: string]: ScalingScheduleStatus
  };
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * [Output Only] The status of the autoscaler configuration. Current set of
   * possible values: - PENDING: Autoscaler backend hasn't read new/updated
   * configuration. - DELETING: Configuration is being deleted. - ACTIVE:
   * Configuration is acknowledged to be effective. Some warnings might be
   * present in the statusDetails field. - ERROR: Configuration has errors.
   * Actionable for users. Details are present in the statusDetails field. New
   * values might be added in the future.
   */
  status?:  | "ACTIVE" | "DELETING" | "ERROR" | "PENDING";
  /**
   * [Output Only] Human-readable details about the current state of the
   * autoscaler. Read the documentation for Commonly returned status messages
   * for examples of status messages you might encounter.
   */
  statusDetails?: AutoscalerStatusDetails[];
  /**
   * URL of the managed instance group that this autoscaler will scale. This
   * field is required when creating an autoscaler.
   */
  target?: string;
  /**
   * [Output Only] URL of the zone where the instance group resides (for
   * autoscalers living in zonal scope).
   */
  zone?: string;
}

function serializeAutoscaler(data: any): Autoscaler {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeAutoscaler(data: any): Autoscaler {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface AutoscalerAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of AutoscalersScopedList resources.
   */
  items?: {
    [key: string]: AutoscalersScopedList
  };
  /**
   * [Output Only] Type of resource. Always compute#autoscalerAggregatedList
   * for aggregated lists of autoscalers.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources. end_interface:
   * MixerListResponseWithEtagBuilder
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeAutoscalerAggregatedList(data: any): AutoscalerAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeAutoscalersScopedList(v)]))) : undefined,
  };
}

function deserializeAutoscalerAggregatedList(data: any): AutoscalerAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeAutoscalersScopedList(v)]))) : undefined,
  };
}

/**
 * Contains a list of Autoscaler resources.
 */
export interface AutoscalerList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of Autoscaler resources.
   */
  items?: Autoscaler[];
  /**
   * [Output Only] Type of resource. Always compute#autoscalerList for lists of
   * autoscalers.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeAutoscalerList(data: any): AutoscalerList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeAutoscaler(item))) : undefined,
  };
}

function deserializeAutoscalerList(data: any): AutoscalerList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeAutoscaler(item))) : undefined,
  };
}

/**
 * Additional options for Compute#autoscalersAggregatedList.
 */
export interface AutoscalersAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#autoscalersDelete.
 */
export interface AutoscalersDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#autoscalersInsert.
 */
export interface AutoscalersInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#autoscalersList.
 */
export interface AutoscalersListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#autoscalersPatch.
 */
export interface AutoscalersPatchOptions {
  /**
   * Name of the autoscaler to patch.
   */
  autoscaler?: string;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface AutoscalersScopedList {
  /**
   * [Output Only] A list of autoscalers contained in this scope.
   */
  autoscalers?: Autoscaler[];
  /**
   * [Output Only] Informational warning which replaces the list of autoscalers
   * when the list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeAutoscalersScopedList(data: any): AutoscalersScopedList {
  return {
    ...data,
    autoscalers: data["autoscalers"] !== undefined ? data["autoscalers"].map((item: any) => (serializeAutoscaler(item))) : undefined,
  };
}

function deserializeAutoscalersScopedList(data: any): AutoscalersScopedList {
  return {
    ...data,
    autoscalers: data["autoscalers"] !== undefined ? data["autoscalers"].map((item: any) => (deserializeAutoscaler(item))) : undefined,
  };
}

export interface AutoscalerStatusDetails {
  /**
   * The status message.
   */
  message?: string;
  /**
   * The type of error, warning, or notice returned. Current set of possible
   * values: - ALL_INSTANCES_UNHEALTHY (WARNING): All instances in the instance
   * group are unhealthy (not in RUNNING state). -
   * BACKEND_SERVICE_DOES_NOT_EXIST (ERROR): There is no backend service
   * attached to the instance group. - CAPPED_AT_MAX_NUM_REPLICAS (WARNING):
   * Autoscaler recommends a size greater than maxNumReplicas. -
   * CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE (WARNING): The custom metric samples
   * are not exported often enough to be a credible base for autoscaling. -
   * CUSTOM_METRIC_INVALID (ERROR): The custom metric that was specified does
   * not exist or does not have the necessary labels. - MIN_EQUALS_MAX
   * (WARNING): The minNumReplicas is equal to maxNumReplicas. This means the
   * autoscaler cannot add or remove instances from the instance group. -
   * MISSING_CUSTOM_METRIC_DATA_POINTS (WARNING): The autoscaler did not receive
   * any data from the custom metric configured for autoscaling. -
   * MISSING_LOAD_BALANCING_DATA_POINTS (WARNING): The autoscaler is configured
   * to scale based on a load balancing signal but the instance group has not
   * received any requests from the load balancer. - MODE_OFF (WARNING):
   * Autoscaling is turned off. The number of instances in the group won't
   * change automatically. The autoscaling configuration is preserved. -
   * MODE_ONLY_UP (WARNING): Autoscaling is in the "Autoscale only out" mode.
   * The autoscaler can add instances but not remove any. -
   * MORE_THAN_ONE_BACKEND_SERVICE (ERROR): The instance group cannot be
   * autoscaled because it has more than one backend service attached to it. -
   * NOT_ENOUGH_QUOTA_AVAILABLE (ERROR): There is insufficient quota for the
   * necessary resources, such as CPU or number of instances. -
   * REGION_RESOURCE_STOCKOUT (ERROR): Shown only for regional autoscalers:
   * there is a resource stockout in the chosen region. -
   * SCALING_TARGET_DOES_NOT_EXIST (ERROR): The target to be scaled does not
   * exist. - UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION (ERROR):
   * Autoscaling does not work with an HTTP/S load balancer that has been
   * configured for maxRate. - ZONE_RESOURCE_STOCKOUT (ERROR): For zonal
   * autoscalers: there is a resource stockout in the chosen zone. For regional
   * autoscalers: in at least one of the zones you're using there is a resource
   * stockout. New values might be added in the future. Some of the values might
   * not be available in all API versions.
   */
  type?:  | "ALL_INSTANCES_UNHEALTHY" | "BACKEND_SERVICE_DOES_NOT_EXIST" | "CAPPED_AT_MAX_NUM_REPLICAS" | "CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE" | "CUSTOM_METRIC_INVALID" | "MIN_EQUALS_MAX" | "MISSING_CUSTOM_METRIC_DATA_POINTS" | "MISSING_LOAD_BALANCING_DATA_POINTS" | "MODE_OFF" | "MODE_ONLY_SCALE_OUT" | "MODE_ONLY_UP" | "MORE_THAN_ONE_BACKEND_SERVICE" | "NOT_ENOUGH_QUOTA_AVAILABLE" | "REGION_RESOURCE_STOCKOUT" | "SCALING_TARGET_DOES_NOT_EXIST" | "SCHEDULED_INSTANCES_GREATER_THAN_AUTOSCALER_MAX" | "SCHEDULED_INSTANCES_LESS_THAN_AUTOSCALER_MIN" | "UNKNOWN" | "UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION" | "ZONE_RESOURCE_STOCKOUT";
}

/**
 * Additional options for Compute#autoscalersUpdate.
 */
export interface AutoscalersUpdateOptions {
  /**
   * Name of the autoscaler to update.
   */
  autoscaler?: string;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Cloud Autoscaler policy.
 */
export interface AutoscalingPolicy {
  /**
   * The number of seconds that the autoscaler waits before it starts
   * collecting information from a new instance. This prevents the autoscaler
   * from collecting information when the instance is initializing, during which
   * the collected usage would not be reliable. The default time autoscaler
   * waits is 60 seconds. Virtual machine initialization times might vary
   * because of numerous factors. We recommend that you test how long an
   * instance may take to initialize. To do this, create an instance and time
   * the startup process.
   */
  coolDownPeriodSec?: number;
  /**
   * Defines the CPU utilization policy that allows the autoscaler to scale
   * based on the average CPU utilization of a managed instance group.
   */
  cpuUtilization?: AutoscalingPolicyCpuUtilization;
  /**
   * Configuration parameters of autoscaling based on a custom metric.
   */
  customMetricUtilizations?: AutoscalingPolicyCustomMetricUtilization[];
  /**
   * Configuration parameters of autoscaling based on load balancer.
   */
  loadBalancingUtilization?: AutoscalingPolicyLoadBalancingUtilization;
  /**
   * The maximum number of instances that the autoscaler can scale out to. This
   * is required when creating or updating an autoscaler. The maximum number of
   * replicas must not be lower than minimal number of replicas.
   */
  maxNumReplicas?: number;
  /**
   * The minimum number of replicas that the autoscaler can scale in to. This
   * cannot be less than 0. If not provided, autoscaler chooses a default value
   * depending on maximum number of instances allowed.
   */
  minNumReplicas?: number;
  /**
   * Defines operating mode for this policy.
   */
  mode?:  | "OFF" | "ON" | "ONLY_SCALE_OUT" | "ONLY_UP";
  scaleInControl?: AutoscalingPolicyScaleInControl;
  /**
   * Scaling schedules defined for an autoscaler. Multiple schedules can be set
   * on an autoscaler, and they can overlap. During overlapping periods the
   * greatest min_required_replicas of all scaling schedules is applied. Up to
   * 128 scaling schedules are allowed.
   */
  scalingSchedules?: {
    [key: string]: AutoscalingPolicyScalingSchedule
  };
}

/**
 * CPU utilization policy.
 */
export interface AutoscalingPolicyCpuUtilization {
  /**
   * Indicates whether predictive autoscaling based on CPU metric is enabled.
   * Valid values are: * NONE (default). No predictive method is used. The
   * autoscaler scales the group to meet current demand based on real-time
   * metrics. * OPTIMIZE_AVAILABILITY. Predictive autoscaling improves
   * availability by monitoring daily and weekly load patterns and scaling out
   * ahead of anticipated demand.
   */
  predictiveMethod?:  | "NONE" | "OPTIMIZE_AVAILABILITY";
  /**
   * The target CPU utilization that the autoscaler maintains. Must be a float
   * value in the range (0, 1]. If not specified, the default is 0.6. If the CPU
   * level is below the target utilization, the autoscaler scales in the number
   * of instances until it reaches the minimum number of instances you specified
   * or until the average CPU of your instances reaches the target utilization.
   * If the average CPU is above the target utilization, the autoscaler scales
   * out until it reaches the maximum number of instances you specified or until
   * the average utilization reaches the target utilization.
   */
  utilizationTarget?: number;
}

/**
 * Custom utilization metric policy.
 */
export interface AutoscalingPolicyCustomMetricUtilization {
  /**
   * A filter string, compatible with a Stackdriver Monitoring filter string
   * for TimeSeries.list API call. This filter is used to select a specific
   * TimeSeries for the purpose of autoscaling and to determine whether the
   * metric is exporting per-instance or per-group data. For the filter to be
   * valid for autoscaling purposes, the following rules apply: - You can only
   * use the AND operator for joining selectors. - You can only use direct
   * equality comparison operator (=) without any functions for each selector. -
   * You can specify the metric in both the filter string and in the metric
   * field. However, if specified in both places, the metric must be identical.
   * - The monitored resource type determines what kind of values are expected
   * for the metric. If it is a gce_instance, the autoscaler expects the metric
   * to include a separate TimeSeries for each instance in a group. In such a
   * case, you cannot filter on resource labels. If the resource type is any
   * other value, the autoscaler expects this metric to contain values that
   * apply to the entire autoscaled instance group and resource label filtering
   * can be performed to point autoscaler at the correct TimeSeries to scale
   * upon. This is called a *per-group metric* for the purpose of autoscaling.
   * If not specified, the type defaults to gce_instance. Try to provide a
   * filter that is selective enough to pick just one TimeSeries for the
   * autoscaled group or for each of the instances (if you are using
   * gce_instance resource type). If multiple TimeSeries are returned upon the
   * query execution, the autoscaler will sum their respective values to obtain
   * its scaling value.
   */
  filter?: string;
  /**
   * The identifier (type) of the Stackdriver Monitoring metric. The metric
   * cannot have negative values. The metric must have a value type of INT64 or
   * DOUBLE.
   */
  metric?: string;
  /**
   * If scaling is based on a per-group metric value that represents the total
   * amount of work to be done or resource usage, set this value to an amount
   * assigned for a single instance of the scaled group. Autoscaler keeps the
   * number of instances proportional to the value of this metric. The metric
   * itself does not change value due to group resizing. A good metric to use
   * with the target is for example
   * pubsub.googleapis.com/subscription/num_undelivered_messages or a custom
   * metric exporting the total number of requests coming to your instances. A
   * bad example would be a metric exporting an average or median latency, since
   * this value can't include a chunk assignable to a single instance, it could
   * be better used with utilization_target instead.
   */
  singleInstanceAssignment?: number;
  /**
   * The target value of the metric that autoscaler maintains. This must be a
   * positive value. A utilization metric scales number of virtual machines
   * handling requests to increase or decrease proportionally to the metric. For
   * example, a good metric to use as a utilization_target is
   * https://www.googleapis.com/compute/v1/instance/network/received_bytes_count.
   * The autoscaler works to keep this value constant for each of the instances.
   */
  utilizationTarget?: number;
  /**
   * Defines how target utilization value is expressed for a Stackdriver
   * Monitoring metric. Either GAUGE, DELTA_PER_SECOND, or DELTA_PER_MINUTE.
   */
  utilizationTargetType?:  | "DELTA_PER_MINUTE" | "DELTA_PER_SECOND" | "GAUGE";
}

/**
 * Configuration parameters of autoscaling based on load balancing.
 */
export interface AutoscalingPolicyLoadBalancingUtilization {
  /**
   * Fraction of backend capacity utilization (set in HTTP(S) load balancing
   * configuration) that the autoscaler maintains. Must be a positive float
   * value. If not defined, the default is 0.8.
   */
  utilizationTarget?: number;
}

/**
 * Configuration that allows for slower scale in so that even if Autoscaler
 * recommends an abrupt scale in of a MIG, it will be throttled as specified by
 * the parameters below.
 */
export interface AutoscalingPolicyScaleInControl {
  /**
   * Maximum allowed number (or %) of VMs that can be deducted from the peak
   * recommendation during the window autoscaler looks at when computing
   * recommendations. Possibly all these VMs can be deleted at once so user
   * service needs to be prepared to lose that many VMs in one step.
   */
  maxScaledInReplicas?: FixedOrPercent;
  /**
   * How far back autoscaling looks when computing recommendations to include
   * directives regarding slower scale in, as described above.
   */
  timeWindowSec?: number;
}

/**
 * Scaling based on user-defined schedule. The message describes a single
 * scaling schedule. A scaling schedule changes the minimum number of VM
 * instances an autoscaler can recommend, which can trigger scaling out.
 */
export interface AutoscalingPolicyScalingSchedule {
  /**
   * A description of a scaling schedule.
   */
  description?: string;
  /**
   * A boolean value that specifies whether a scaling schedule can influence
   * autoscaler recommendations. If set to true, then a scaling schedule has no
   * effect. This field is optional, and its value is false by default.
   */
  disabled?: boolean;
  /**
   * The duration of time intervals, in seconds, for which this scaling
   * schedule is to run. The minimum allowed value is 300. This field is
   * required.
   */
  durationSec?: number;
  /**
   * The minimum number of VM instances that the autoscaler will recommend in
   * time intervals starting according to schedule. This field is required.
   */
  minRequiredReplicas?: number;
  /**
   * The start timestamps of time intervals when this scaling schedule is to
   * provide a scaling signal. This field uses the extended cron format (with an
   * optional year field). The expression can describe a single timestamp if the
   * optional year is set, in which case the scaling schedule runs once. The
   * schedule is interpreted with respect to time_zone. This field is required.
   * Note: These timestamps only describe when autoscaler starts providing the
   * scaling signal. The VMs need additional time to become serving.
   */
  schedule?: string;
  /**
   * The time zone to use when interpreting the schedule. The value of this
   * field must be a time zone name from the tz database:
   * http://en.wikipedia.org/wiki/Tz_database. This field is assigned a default
   * value of UTC if left empty.
   */
  timeZone?: string;
}

/**
 * Message containing information of one individual backend.
 */
export interface Backend {
  /**
   * Specifies how to determine whether the backend of a load balancer can
   * handle additional traffic or is fully loaded. For usage guidelines, see
   * Connection balancing mode. Backends must use compatible balancing modes.
   * For more information, see Supported balancing modes and target capacity
   * settings and Restrictions and guidance for instance groups. Note:
   * Currently, if you use the API to configure incompatible balancing modes,
   * the configuration might be accepted even though it has no impact and is
   * ignored. Specifically, Backend.maxUtilization is ignored when
   * Backend.balancingMode is RATE. In the future, this incompatible combination
   * will be rejected.
   */
  balancingMode?:  | "CONNECTION" | "RATE" | "UTILIZATION";
  /**
   * A multiplier applied to the backend's target capacity of its balancing
   * mode. The default value is 1, which means the group serves up to 100% of
   * its configured capacity (depending on balancingMode). A setting of 0 means
   * the group is completely drained, offering 0% of its available capacity. The
   * valid ranges are 0.0 and [0.1,1.0]. You cannot configure a setting larger
   * than 0 and smaller than 0.1. You cannot configure a setting of 0 when there
   * is only one backend attached to the backend service. Not available with
   * backends that don't support using a balancingMode. This includes backends
   * such as global internet NEGs, regional serverless NEGs, and PSC NEGs.
   */
  capacityScaler?: number;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * This field designates whether this is a failover backend. More than one
   * failover backend can be configured for a given BackendService.
   */
  failover?: boolean;
  /**
   * The fully-qualified URL of an instance group or network endpoint group
   * (NEG) resource. To determine what types of backends a load balancer
   * supports, see the [Backend services
   * overview](https://cloud.google.com/load-balancing/docs/backend-service#backends).
   * You must use the *fully-qualified* URL (starting with
   * https://www.googleapis.com/) to specify the instance group or NEG. Partial
   * URLs are not supported.
   */
  group?: string;
  /**
   * Defines a target maximum number of simultaneous connections. For usage
   * guidelines, see Connection balancing mode and Utilization balancing mode.
   * Not available if the backend's balancingMode is RATE.
   */
  maxConnections?: number;
  /**
   * Defines a target maximum number of simultaneous connections. For usage
   * guidelines, see Connection balancing mode and Utilization balancing mode.
   * Not available if the backend's balancingMode is RATE.
   */
  maxConnectionsPerEndpoint?: number;
  /**
   * Defines a target maximum number of simultaneous connections. For usage
   * guidelines, see Connection balancing mode and Utilization balancing mode.
   * Not available if the backend's balancingMode is RATE.
   */
  maxConnectionsPerInstance?: number;
  /**
   * Defines a maximum number of HTTP requests per second (RPS). For usage
   * guidelines, see Rate balancing mode and Utilization balancing mode. Not
   * available if the backend's balancingMode is CONNECTION.
   */
  maxRate?: number;
  /**
   * Defines a maximum target for requests per second (RPS). For usage
   * guidelines, see Rate balancing mode and Utilization balancing mode. Not
   * available if the backend's balancingMode is CONNECTION.
   */
  maxRatePerEndpoint?: number;
  /**
   * Defines a maximum target for requests per second (RPS). For usage
   * guidelines, see Rate balancing mode and Utilization balancing mode. Not
   * available if the backend's balancingMode is CONNECTION.
   */
  maxRatePerInstance?: number;
  /**
   * Optional parameter to define a target capacity for the UTILIZATION
   * balancing mode. The valid range is [0.0, 1.0]. For usage guidelines, see
   * Utilization balancing mode.
   */
  maxUtilization?: number;
}

/**
 * Represents a Cloud Storage Bucket resource. This Cloud Storage bucket
 * resource is referenced by a URL map of a load balancer. For more information,
 * read Backend Buckets.
 */
export interface BackendBucket {
  /**
   * Cloud Storage bucket name.
   */
  bucketName?: string;
  /**
   * Cloud CDN configuration for this BackendBucket.
   */
  cdnPolicy?: BackendBucketCdnPolicy;
  /**
   * Compress text responses using Brotli or gzip compression, based on the
   * client's Accept-Encoding header.
   */
  compressionMode?:  | "AUTOMATIC" | "DISABLED";
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * Headers that the HTTP/S load balancer should add to proxied responses.
   */
  customResponseHeaders?: string[];
  /**
   * An optional textual description of the resource; provided by the client
   * when the resource is created.
   */
  description?: string;
  /**
   * [Output Only] The resource URL for the edge security policy associated
   * with this backend bucket.
   */
  edgeSecurityPolicy?: string;
  /**
   * If true, enable Cloud CDN for this BackendBucket.
   */
  enableCdn?: boolean;
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: bigint;
  /**
   * Type of the resource.
   */
  kind?: string;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
}

function serializeBackendBucket(data: any): BackendBucket {
  return {
    ...data,
    cdnPolicy: data["cdnPolicy"] !== undefined ? serializeBackendBucketCdnPolicy(data["cdnPolicy"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeBackendBucket(data: any): BackendBucket {
  return {
    ...data,
    cdnPolicy: data["cdnPolicy"] !== undefined ? deserializeBackendBucketCdnPolicy(data["cdnPolicy"]) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

/**
 * Message containing Cloud CDN configuration for a backend bucket.
 */
export interface BackendBucketCdnPolicy {
  /**
   * Bypass the cache when the specified request headers are matched - e.g.
   * Pragma or Authorization headers. Up to 5 headers can be specified. The
   * cache is bypassed for all cdnPolicy.cacheMode settings.
   */
  bypassCacheOnRequestHeaders?: BackendBucketCdnPolicyBypassCacheOnRequestHeader[];
  /**
   * The CacheKeyPolicy for this CdnPolicy.
   */
  cacheKeyPolicy?: BackendBucketCdnPolicyCacheKeyPolicy;
  /**
   * Specifies the cache setting for all responses from this backend. The
   * possible values are: USE_ORIGIN_HEADERS Requires the origin to set valid
   * caching headers to cache content. Responses without these headers will not
   * be cached at Google's edge, and will require a full trip to the origin on
   * every request, potentially impacting performance and increasing load on the
   * origin server. FORCE_CACHE_ALL Cache all content, ignoring any "private",
   * "no-store" or "no-cache" directives in Cache-Control response headers.
   * Warning: this may result in Cloud CDN caching private, per-user (user
   * identifiable) content. CACHE_ALL_STATIC Automatically cache static content,
   * including common image formats, media (video and audio), and web assets
   * (JavaScript and CSS). Requests and responses that are marked as
   * uncacheable, as well as dynamic content (including HTML), will not be
   * cached.
   */
  cacheMode?:  | "CACHE_ALL_STATIC" | "FORCE_CACHE_ALL" | "INVALID_CACHE_MODE" | "USE_ORIGIN_HEADERS";
  /**
   * Specifies a separate client (e.g. browser client) maximum TTL. This is
   * used to clamp the max-age (or Expires) value sent to the client. With
   * FORCE_CACHE_ALL, the lesser of client_ttl and default_ttl is used for the
   * response max-age directive, along with a "public" directive. For cacheable
   * content in CACHE_ALL_STATIC mode, client_ttl clamps the max-age from the
   * origin (if specified), or else sets the response max-age directive to the
   * lesser of the client_ttl and default_ttl, and also ensures a "public"
   * cache-control directive is present. If a client TTL is not specified, a
   * default value (1 hour) will be used. The maximum allowed value is
   * 31,622,400s (1 year).
   */
  clientTtl?: number;
  /**
   * Specifies the default TTL for cached content served by this origin for
   * responses that do not have an existing valid TTL (max-age or s-max-age).
   * Setting a TTL of "0" means "always revalidate". The value of defaultTTL
   * cannot be set to a value greater than that of maxTTL, but can be equal.
   * When the cacheMode is set to FORCE_CACHE_ALL, the defaultTTL will overwrite
   * the TTL set in all responses. The maximum allowed value is 31,622,400s (1
   * year), noting that infrequently accessed objects may be evicted from the
   * cache before the defined TTL.
   */
  defaultTtl?: number;
  /**
   * Specifies the maximum allowed TTL for cached content served by this
   * origin. Cache directives that attempt to set a max-age or s-maxage higher
   * than this, or an Expires header more than maxTTL seconds in the future will
   * be capped at the value of maxTTL, as if it were the value of an s-maxage
   * Cache-Control directive. Headers sent to the client will not be modified.
   * Setting a TTL of "0" means "always revalidate". The maximum allowed value
   * is 31,622,400s (1 year), noting that infrequently accessed objects may be
   * evicted from the cache before the defined TTL.
   */
  maxTtl?: number;
  /**
   * Negative caching allows per-status code TTLs to be set, in order to apply
   * fine-grained caching for common errors or redirects. This can reduce the
   * load on your origin and improve end-user experience by reducing response
   * latency. When the cache mode is set to CACHE_ALL_STATIC or
   * USE_ORIGIN_HEADERS, negative caching applies to responses with the
   * specified response code that lack any Cache-Control, Expires, or Pragma:
   * no-cache directives. When the cache mode is set to FORCE_CACHE_ALL,
   * negative caching applies to all responses with the specified response code,
   * and override any caching headers. By default, Cloud CDN will apply the
   * following default TTLs to these status codes: HTTP 300 (Multiple Choice),
   * 301, 308 (Permanent Redirects): 10m HTTP 404 (Not Found), 410 (Gone), 451
   * (Unavailable For Legal Reasons): 120s HTTP 405 (Method Not Found), 421
   * (Misdirected Request), 501 (Not Implemented): 60s. These defaults can be
   * overridden in negative_caching_policy.
   */
  negativeCaching?: boolean;
  /**
   * Sets a cache TTL for the specified HTTP status code. negative_caching must
   * be enabled to configure negative_caching_policy. Omitting the policy and
   * leaving negative_caching enabled will use Cloud CDN's default cache TTLs.
   * Note that when specifying an explicit negative_caching_policy, you should
   * take care to specify a cache TTL for all response codes that you wish to
   * cache. Cloud CDN will not apply any default negative caching when a policy
   * exists.
   */
  negativeCachingPolicy?: BackendBucketCdnPolicyNegativeCachingPolicy[];
  /**
   * If true then Cloud CDN will combine multiple concurrent cache fill
   * requests into a small number of requests to the origin.
   */
  requestCoalescing?: boolean;
  /**
   * Serve existing content from the cache (if available) when revalidating
   * content with the origin, or when an error is encountered when refreshing
   * the cache. This setting defines the default "max-stale" duration for any
   * cached responses that do not specify a max-stale directive. Stale responses
   * that exceed the TTL configured here will not be served. The default limit
   * (max-stale) is 86400s (1 day), which will allow stale content to be served
   * up to this limit beyond the max-age (or s-max-age) of a cached response.
   * The maximum allowed value is 604800 (1 week). Set this to zero (0) to
   * disable serve-while-stale.
   */
  serveWhileStale?: number;
  /**
   * Maximum number of seconds the response to a signed URL request will be
   * considered fresh. After this time period, the response will be revalidated
   * before being served. Defaults to 1hr (3600s). When serving responses to
   * signed URL requests, Cloud CDN will internally behave as though all
   * responses from this backend had a "Cache-Control: public, max-age=[TTL]"
   * header, regardless of any existing Cache-Control header. The actual headers
   * served in responses will not be altered.
   */
  signedUrlCacheMaxAgeSec?: bigint;
  /**
   * [Output Only] Names of the keys for signing request URLs.
   */
  signedUrlKeyNames?: string[];
}

function serializeBackendBucketCdnPolicy(data: any): BackendBucketCdnPolicy {
  return {
    ...data,
    signedUrlCacheMaxAgeSec: data["signedUrlCacheMaxAgeSec"] !== undefined ? String(data["signedUrlCacheMaxAgeSec"]) : undefined,
  };
}

function deserializeBackendBucketCdnPolicy(data: any): BackendBucketCdnPolicy {
  return {
    ...data,
    signedUrlCacheMaxAgeSec: data["signedUrlCacheMaxAgeSec"] !== undefined ? BigInt(data["signedUrlCacheMaxAgeSec"]) : undefined,
  };
}

/**
 * Bypass the cache when the specified request headers are present, e.g. Pragma
 * or Authorization headers. Values are case insensitive. The presence of such a
 * header overrides the cache_mode setting.
 */
export interface BackendBucketCdnPolicyBypassCacheOnRequestHeader {
  /**
   * The header field name to match on when bypassing cache. Values are
   * case-insensitive.
   */
  headerName?: string;
}

/**
 * Message containing what to include in the cache key for a request for Cloud
 * CDN.
 */
export interface BackendBucketCdnPolicyCacheKeyPolicy {
  /**
   * Allows HTTP request headers (by name) to be used in the cache key.
   */
  includeHttpHeaders?: string[];
  /**
   * Names of query string parameters to include in cache keys. Default
   * parameters are always included. '&' and '=' will be percent encoded and not
   * treated as delimiters.
   */
  queryStringWhitelist?: string[];
}

/**
 * Specify CDN TTLs for response error codes.
 */
export interface BackendBucketCdnPolicyNegativeCachingPolicy {
  /**
   * The HTTP status code to define a TTL against. Only HTTP status codes 300,
   * 301, 302, 307, 308, 404, 405, 410, 421, 451 and 501 are can be specified as
   * values, and you cannot specify a status code more than once.
   */
  code?: number;
  /**
   * The TTL (in seconds) for which to cache responses with the corresponding
   * status code. The maximum allowed value is 1800s (30 minutes), noting that
   * infrequently accessed objects may be evicted from the cache before the
   * defined TTL.
   */
  ttl?: number;
}

/**
 * Contains a list of BackendBucket resources.
 */
export interface BackendBucketList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of BackendBucket resources.
   */
  items?: BackendBucket[];
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeBackendBucketList(data: any): BackendBucketList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeBackendBucket(item))) : undefined,
  };
}

function deserializeBackendBucketList(data: any): BackendBucketList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeBackendBucket(item))) : undefined,
  };
}

/**
 * Additional options for Compute#backendBucketsAddSignedUrlKey.
 */
export interface BackendBucketsAddSignedUrlKeyOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#backendBucketsDelete.
 */
export interface BackendBucketsDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#backendBucketsDeleteSignedUrlKey.
 */
export interface BackendBucketsDeleteSignedUrlKeyOptions {
  /**
   * The name of the Signed URL Key to delete.
   */
  keyName: string;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#backendBucketsInsert.
 */
export interface BackendBucketsInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#backendBucketsList.
 */
export interface BackendBucketsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#backendBucketsPatch.
 */
export interface BackendBucketsPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#backendBucketsSetEdgeSecurityPolicy.
 */
export interface BackendBucketsSetEdgeSecurityPolicyOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#backendBucketsUpdate.
 */
export interface BackendBucketsUpdateOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Represents a Backend Service resource. A backend service defines how Google
 * Cloud load balancers distribute traffic. The backend service configuration
 * contains a set of values, such as the protocol used to connect to backends,
 * various distribution and session settings, health checks, and timeouts. These
 * settings provide fine-grained control over how your load balancer behaves.
 * Most of the settings have default values that allow for easy configuration if
 * you need to get started quickly. Backend services in Google Compute Engine
 * can be either regionally or globally scoped. *
 * [Global](https://cloud.google.com/compute/docs/reference/rest/v1/backendServices)
 * *
 * [Regional](https://cloud.google.com/compute/docs/reference/rest/v1/regionBackendServices)
 * For more information, see Backend Services.
 */
export interface BackendService {
  /**
   * Lifetime of cookies in seconds. This setting is applicable to external and
   * internal HTTP(S) load balancers and Traffic Director and requires
   * GENERATED_COOKIE or HTTP_COOKIE session affinity. If set to 0, the cookie
   * is non-persistent and lasts only until the end of the browser session (or
   * equivalent). The maximum allowed value is two weeks (1,209,600). Not
   * supported when the backend service is referenced by a URL map that is bound
   * to target gRPC proxy that has validateForProxyless field set to true.
   */
  affinityCookieTtlSec?: number;
  /**
   * The list of backends that serve this BackendService.
   */
  backends?: Backend[];
  /**
   * Cloud CDN configuration for this BackendService. Only available for
   * specified load balancer types.
   */
  cdnPolicy?: BackendServiceCdnPolicy;
  circuitBreakers?: CircuitBreakers;
  /**
   * Compress text responses using Brotli or gzip compression, based on the
   * client's Accept-Encoding header.
   */
  compressionMode?:  | "AUTOMATIC" | "DISABLED";
  connectionDraining?: ConnectionDraining;
  /**
   * Connection Tracking configuration for this BackendService. Connection
   * tracking policy settings are only available for Network Load Balancing and
   * Internal TCP/UDP Load Balancing.
   */
  connectionTrackingPolicy?: BackendServiceConnectionTrackingPolicy;
  /**
   * Consistent Hash-based load balancing can be used to provide soft session
   * affinity based on HTTP headers, cookies or other properties. This load
   * balancing policy is applicable only for HTTP connections. The affinity to a
   * particular destination host will be lost when one or more hosts are
   * added/removed from the destination service. This field specifies parameters
   * that control consistent hashing. This field is only applicable when
   * localityLbPolicy is set to MAGLEV or RING_HASH. This field is applicable to
   * either: - A regional backend service with the service_protocol set to HTTP,
   * HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED. - A
   * global backend service with the load_balancing_scheme set to
   * INTERNAL_SELF_MANAGED.
   */
  consistentHash?: ConsistentHashLoadBalancerSettings;
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * Headers that the load balancer adds to proxied requests. See [Creating
   * custom
   * headers](https://cloud.google.com/load-balancing/docs/custom-headers).
   */
  customRequestHeaders?: string[];
  /**
   * Headers that the load balancer adds to proxied responses. See [Creating
   * custom
   * headers](https://cloud.google.com/load-balancing/docs/custom-headers).
   */
  customResponseHeaders?: string[];
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * [Output Only] The resource URL for the edge security policy associated
   * with this backend service.
   */
  edgeSecurityPolicy?: string;
  /**
   * If true, enables Cloud CDN for the backend service of an external HTTP(S)
   * load balancer.
   */
  enableCDN?: boolean;
  /**
   * Requires at least one backend instance group to be defined as a backup
   * (failover) backend. For load balancers that have configurable failover:
   * [Internal TCP/UDP Load
   * Balancing](https://cloud.google.com/load-balancing/docs/internal/failover-overview)
   * and [external TCP/UDP Load
   * Balancing](https://cloud.google.com/load-balancing/docs/network/networklb-failover-overview).
   */
  failoverPolicy?: BackendServiceFailoverPolicy;
  /**
   * Fingerprint of this resource. A hash of the contents stored in this
   * object. This field is used in optimistic locking. This field will be
   * ignored when inserting a BackendService. An up-to-date fingerprint must be
   * provided in order to update the BackendService, otherwise the request will
   * fail with error 412 conditionNotMet. To see the latest fingerprint, make a
   * get() request to retrieve a BackendService.
   */
  fingerprint?: Uint8Array;
  /**
   * The list of URLs to the healthChecks, httpHealthChecks (legacy), or
   * httpsHealthChecks (legacy) resource for health checking this backend
   * service. Not all backend services support legacy health checks. See Load
   * balancer guide. Currently, at most one health check can be specified for
   * each backend service. Backend services with instance group or zonal NEG
   * backends must have a health check. Backend services with internet or
   * serverless NEG backends must not have a health check.
   */
  healthChecks?: string[];
  /**
   * The configurations for Identity-Aware Proxy on this resource. Not
   * available for Internal TCP/UDP Load Balancing and Network Load Balancing.
   */
  iap?: BackendServiceIAP;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of resource. Always compute#backendService for backend
   * services.
   */
  kind?: string;
  /**
   * Specifies the load balancer type. A backend service created for one type
   * of load balancer cannot be used with another. For more information, refer
   * to Choosing a load balancer.
   */
  loadBalancingScheme?:  | "EXTERNAL" | "EXTERNAL_MANAGED" | "INTERNAL" | "INTERNAL_MANAGED" | "INTERNAL_SELF_MANAGED" | "INVALID_LOAD_BALANCING_SCHEME";
  /**
   * A list of locality load-balancing policies to be used in order of
   * preference. When you use localityLbPolicies, you must set at least one
   * value for either the localityLbPolicies[].policy or the
   * localityLbPolicies[].customPolicy field. localityLbPolicies overrides any
   * value set in the localityLbPolicy field. For an example of how to use this
   * field, see Define a list of preferred policies. Caution: This field and its
   * children are intended for use in a service mesh that includes gRPC clients
   * only. Envoy proxies can't use backend services that have this
   * configuration.
   */
  localityLbPolicies?: BackendServiceLocalityLoadBalancingPolicyConfig[];
  /**
   * The load balancing algorithm used within the scope of the locality. The
   * possible values are: - ROUND_ROBIN: This is a simple policy in which each
   * healthy backend is selected in round robin order. This is the default. -
   * LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts and
   * picks the host which has fewer active requests. - RING_HASH: The
   * ring/modulo hash load balancer implements consistent hashing to backends.
   * The algorithm has the property that the addition/removal of a host from a
   * set of N hosts only affects 1/N of the requests. - RANDOM: The load
   * balancer selects a random healthy host. - ORIGINAL_DESTINATION: Backend
   * host is selected based on the client connection metadata, i.e., connections
   * are opened to the same address as the destination address of the incoming
   * connection before the connection was redirected to the load balancer. -
   * MAGLEV: used as a drop in replacement for the ring hash load balancer.
   * Maglev is not as stable as ring hash but has faster table lookup build
   * times and host selection times. For more information about Maglev, see
   * https://ai.google/research/pubs/pub44824 This field is applicable to
   * either: - A regional backend service with the service_protocol set to HTTP,
   * HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED. - A
   * global backend service with the load_balancing_scheme set to
   * INTERNAL_SELF_MANAGED. If sessionAffinity is not NONE, and this field is
   * not set to MAGLEV or RING_HASH, session affinity settings will not take
   * effect. Only ROUND_ROBIN and RING_HASH are supported when the backend
   * service is referenced by a URL map that is bound to target gRPC proxy that
   * has validateForProxyless field set to true.
   */
  localityLbPolicy?:  | "INVALID_LB_POLICY" | "LEAST_REQUEST" | "MAGLEV" | "ORIGINAL_DESTINATION" | "RANDOM" | "RING_HASH" | "ROUND_ROBIN" | "WEIGHTED_MAGLEV";
  /**
   * This field denotes the logging options for the load balancer traffic
   * served by this backend service. If logging is enabled, logs will be
   * exported to Stackdriver.
   */
  logConfig?: BackendServiceLogConfig;
  /**
   * Specifies the default maximum duration (timeout) for streams to this
   * service. Duration is computed from the beginning of the stream until the
   * response has been completely processed, including all retries. A stream
   * that does not complete in this duration is closed. If not specified, there
   * will be no timeout limit, i.e. the maximum duration is infinite. This value
   * can be overridden in the PathMatcher configuration of the UrlMap that
   * references this backend service. This field is only allowed when the
   * loadBalancingScheme of the backend service is INTERNAL_SELF_MANAGED.
   */
  maxStreamDuration?: Duration;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * The URL of the network to which this backend service belongs. This field
   * can only be specified when the load balancing scheme is set to INTERNAL.
   */
  network?: string;
  /**
   * Settings controlling the eviction of unhealthy hosts from the load
   * balancing pool for the backend service. If not set, this feature is
   * considered disabled. This field is applicable to either: - A regional
   * backend service with the service_protocol set to HTTP, HTTPS, HTTP2, or
   * GRPC, and load_balancing_scheme set to INTERNAL_MANAGED. - A global backend
   * service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
   */
  outlierDetection?: OutlierDetection;
  /**
   * Deprecated in favor of portName. The TCP port to connect on the backend.
   * The default value is 80. For Internal TCP/UDP Load Balancing and Network
   * Load Balancing, omit port.
   */
  port?: number;
  /**
   * A named port on a backend instance group representing the port for
   * communication to the backend VMs in that group. The named port must be
   * [defined on each backend instance
   * group](https://cloud.google.com/load-balancing/docs/backend-service#named_ports).
   * This parameter has no meaning if the backends are NEGs. For Internal
   * TCP/UDP Load Balancing and Network Load Balancing, omit port_name.
   */
  portName?: string;
  /**
   * The protocol this BackendService uses to communicate with backends.
   * Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC. depending on
   * the chosen load balancer or Traffic Director configuration. Refer to the
   * documentation for the load balancers or for Traffic Director for more
   * information. Must be set to GRPC when the backend service is referenced by
   * a URL map that is bound to target gRPC proxy.
   */
  protocol?:  | "GRPC" | "HTTP" | "HTTP2" | "HTTPS" | "SSL" | "TCP" | "UDP" | "UNSPECIFIED";
  /**
   * [Output Only] URL of the region where the regional backend service
   * resides. This field is not applicable to global backend services. You must
   * specify this field as part of the HTTP request URL. It is not settable as a
   * field in the request body.
   */
  region?: string;
  /**
   * [Output Only] The resource URL for the security policy associated with
   * this backend service.
   */
  securityPolicy?: string;
  /**
   * This field specifies the security settings that apply to this backend
   * service. This field is applicable to a global backend service with the
   * load_balancing_scheme set to INTERNAL_SELF_MANAGED.
   */
  securitySettings?: SecuritySettings;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * URLs of networkservices.ServiceBinding resources. Can only be set if load
   * balancing scheme is INTERNAL_SELF_MANAGED. If set, lists of backends and
   * health checks must be both empty.
   */
  serviceBindings?: string[];
  /**
   * Type of session affinity to use. The default is NONE. Only NONE and
   * HEADER_FIELD are supported when the backend service is referenced by a URL
   * map that is bound to target gRPC proxy that has validateForProxyless field
   * set to true. For more details, see: [Session
   * Affinity](https://cloud.google.com/load-balancing/docs/backend-service#session_affinity).
   */
  sessionAffinity?:  | "CLIENT_IP" | "CLIENT_IP_NO_DESTINATION" | "CLIENT_IP_PORT_PROTO" | "CLIENT_IP_PROTO" | "GENERATED_COOKIE" | "HEADER_FIELD" | "HTTP_COOKIE" | "NONE";
  subsetting?: Subsetting;
  /**
   * The backend service timeout has a different meaning depending on the type
   * of load balancer. For more information see, Backend service settings. The
   * default is 30 seconds. The full range of timeout values allowed goes from 1
   * through 2,147,483,647 seconds. This value can be overridden in the
   * PathMatcher configuration of the UrlMap that references this backend
   * service. Not supported when the backend service is referenced by a URL map
   * that is bound to target gRPC proxy that has validateForProxyless field set
   * to true. Instead, use maxStreamDuration.
   */
  timeoutSec?: number;
}

function serializeBackendService(data: any): BackendService {
  return {
    ...data,
    cdnPolicy: data["cdnPolicy"] !== undefined ? serializeBackendServiceCdnPolicy(data["cdnPolicy"]) : undefined,
    consistentHash: data["consistentHash"] !== undefined ? serializeConsistentHashLoadBalancerSettings(data["consistentHash"]) : undefined,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
    maxStreamDuration: data["maxStreamDuration"] !== undefined ? serializeDuration(data["maxStreamDuration"]) : undefined,
    outlierDetection: data["outlierDetection"] !== undefined ? serializeOutlierDetection(data["outlierDetection"]) : undefined,
  };
}

function deserializeBackendService(data: any): BackendService {
  return {
    ...data,
    cdnPolicy: data["cdnPolicy"] !== undefined ? deserializeBackendServiceCdnPolicy(data["cdnPolicy"]) : undefined,
    consistentHash: data["consistentHash"] !== undefined ? deserializeConsistentHashLoadBalancerSettings(data["consistentHash"]) : undefined,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
    maxStreamDuration: data["maxStreamDuration"] !== undefined ? deserializeDuration(data["maxStreamDuration"]) : undefined,
    outlierDetection: data["outlierDetection"] !== undefined ? deserializeOutlierDetection(data["outlierDetection"]) : undefined,
  };
}

/**
 * Contains a list of BackendServicesScopedList.
 */
export interface BackendServiceAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of BackendServicesScopedList resources.
   */
  items?: {
    [key: string]: BackendServicesScopedList
  };
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeBackendServiceAggregatedList(data: any): BackendServiceAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeBackendServicesScopedList(v)]))) : undefined,
  };
}

function deserializeBackendServiceAggregatedList(data: any): BackendServiceAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeBackendServicesScopedList(v)]))) : undefined,
  };
}

/**
 * Message containing Cloud CDN configuration for a backend service.
 */
export interface BackendServiceCdnPolicy {
  /**
   * Bypass the cache when the specified request headers are matched - e.g.
   * Pragma or Authorization headers. Up to 5 headers can be specified. The
   * cache is bypassed for all cdnPolicy.cacheMode settings.
   */
  bypassCacheOnRequestHeaders?: BackendServiceCdnPolicyBypassCacheOnRequestHeader[];
  /**
   * The CacheKeyPolicy for this CdnPolicy.
   */
  cacheKeyPolicy?: CacheKeyPolicy;
  /**
   * Specifies the cache setting for all responses from this backend. The
   * possible values are: USE_ORIGIN_HEADERS Requires the origin to set valid
   * caching headers to cache content. Responses without these headers will not
   * be cached at Google's edge, and will require a full trip to the origin on
   * every request, potentially impacting performance and increasing load on the
   * origin server. FORCE_CACHE_ALL Cache all content, ignoring any "private",
   * "no-store" or "no-cache" directives in Cache-Control response headers.
   * Warning: this may result in Cloud CDN caching private, per-user (user
   * identifiable) content. CACHE_ALL_STATIC Automatically cache static content,
   * including common image formats, media (video and audio), and web assets
   * (JavaScript and CSS). Requests and responses that are marked as
   * uncacheable, as well as dynamic content (including HTML), will not be
   * cached.
   */
  cacheMode?:  | "CACHE_ALL_STATIC" | "FORCE_CACHE_ALL" | "INVALID_CACHE_MODE" | "USE_ORIGIN_HEADERS";
  /**
   * Specifies a separate client (e.g. browser client) maximum TTL. This is
   * used to clamp the max-age (or Expires) value sent to the client. With
   * FORCE_CACHE_ALL, the lesser of client_ttl and default_ttl is used for the
   * response max-age directive, along with a "public" directive. For cacheable
   * content in CACHE_ALL_STATIC mode, client_ttl clamps the max-age from the
   * origin (if specified), or else sets the response max-age directive to the
   * lesser of the client_ttl and default_ttl, and also ensures a "public"
   * cache-control directive is present. If a client TTL is not specified, a
   * default value (1 hour) will be used. The maximum allowed value is
   * 31,622,400s (1 year).
   */
  clientTtl?: number;
  /**
   * Specifies the default TTL for cached content served by this origin for
   * responses that do not have an existing valid TTL (max-age or s-max-age).
   * Setting a TTL of "0" means "always revalidate". The value of defaultTTL
   * cannot be set to a value greater than that of maxTTL, but can be equal.
   * When the cacheMode is set to FORCE_CACHE_ALL, the defaultTTL will overwrite
   * the TTL set in all responses. The maximum allowed value is 31,622,400s (1
   * year), noting that infrequently accessed objects may be evicted from the
   * cache before the defined TTL.
   */
  defaultTtl?: number;
  /**
   * Specifies the maximum allowed TTL for cached content served by this
   * origin. Cache directives that attempt to set a max-age or s-maxage higher
   * than this, or an Expires header more than maxTTL seconds in the future will
   * be capped at the value of maxTTL, as if it were the value of an s-maxage
   * Cache-Control directive. Headers sent to the client will not be modified.
   * Setting a TTL of "0" means "always revalidate". The maximum allowed value
   * is 31,622,400s (1 year), noting that infrequently accessed objects may be
   * evicted from the cache before the defined TTL.
   */
  maxTtl?: number;
  /**
   * Negative caching allows per-status code TTLs to be set, in order to apply
   * fine-grained caching for common errors or redirects. This can reduce the
   * load on your origin and improve end-user experience by reducing response
   * latency. When the cache mode is set to CACHE_ALL_STATIC or
   * USE_ORIGIN_HEADERS, negative caching applies to responses with the
   * specified response code that lack any Cache-Control, Expires, or Pragma:
   * no-cache directives. When the cache mode is set to FORCE_CACHE_ALL,
   * negative caching applies to all responses with the specified response code,
   * and override any caching headers. By default, Cloud CDN will apply the
   * following default TTLs to these status codes: HTTP 300 (Multiple Choice),
   * 301, 308 (Permanent Redirects): 10m HTTP 404 (Not Found), 410 (Gone), 451
   * (Unavailable For Legal Reasons): 120s HTTP 405 (Method Not Found), 421
   * (Misdirected Request), 501 (Not Implemented): 60s. These defaults can be
   * overridden in negative_caching_policy.
   */
  negativeCaching?: boolean;
  /**
   * Sets a cache TTL for the specified HTTP status code. negative_caching must
   * be enabled to configure negative_caching_policy. Omitting the policy and
   * leaving negative_caching enabled will use Cloud CDN's default cache TTLs.
   * Note that when specifying an explicit negative_caching_policy, you should
   * take care to specify a cache TTL for all response codes that you wish to
   * cache. Cloud CDN will not apply any default negative caching when a policy
   * exists.
   */
  negativeCachingPolicy?: BackendServiceCdnPolicyNegativeCachingPolicy[];
  /**
   * If true then Cloud CDN will combine multiple concurrent cache fill
   * requests into a small number of requests to the origin.
   */
  requestCoalescing?: boolean;
  /**
   * Serve existing content from the cache (if available) when revalidating
   * content with the origin, or when an error is encountered when refreshing
   * the cache. This setting defines the default "max-stale" duration for any
   * cached responses that do not specify a max-stale directive. Stale responses
   * that exceed the TTL configured here will not be served. The default limit
   * (max-stale) is 86400s (1 day), which will allow stale content to be served
   * up to this limit beyond the max-age (or s-max-age) of a cached response.
   * The maximum allowed value is 604800 (1 week). Set this to zero (0) to
   * disable serve-while-stale.
   */
  serveWhileStale?: number;
  /**
   * Maximum number of seconds the response to a signed URL request will be
   * considered fresh. After this time period, the response will be revalidated
   * before being served. Defaults to 1hr (3600s). When serving responses to
   * signed URL requests, Cloud CDN will internally behave as though all
   * responses from this backend had a "Cache-Control: public, max-age=[TTL]"
   * header, regardless of any existing Cache-Control header. The actual headers
   * served in responses will not be altered.
   */
  signedUrlCacheMaxAgeSec?: bigint;
  /**
   * [Output Only] Names of the keys for signing request URLs.
   */
  signedUrlKeyNames?: string[];
}

function serializeBackendServiceCdnPolicy(data: any): BackendServiceCdnPolicy {
  return {
    ...data,
    signedUrlCacheMaxAgeSec: data["signedUrlCacheMaxAgeSec"] !== undefined ? String(data["signedUrlCacheMaxAgeSec"]) : undefined,
  };
}

function deserializeBackendServiceCdnPolicy(data: any): BackendServiceCdnPolicy {
  return {
    ...data,
    signedUrlCacheMaxAgeSec: data["signedUrlCacheMaxAgeSec"] !== undefined ? BigInt(data["signedUrlCacheMaxAgeSec"]) : undefined,
  };
}

/**
 * Bypass the cache when the specified request headers are present, e.g. Pragma
 * or Authorization headers. Values are case insensitive. The presence of such a
 * header overrides the cache_mode setting.
 */
export interface BackendServiceCdnPolicyBypassCacheOnRequestHeader {
  /**
   * The header field name to match on when bypassing cache. Values are
   * case-insensitive.
   */
  headerName?: string;
}

/**
 * Specify CDN TTLs for response error codes.
 */
export interface BackendServiceCdnPolicyNegativeCachingPolicy {
  /**
   * The HTTP status code to define a TTL against. Only HTTP status codes 300,
   * 301, 302, 307, 308, 404, 405, 410, 421, 451 and 501 are can be specified as
   * values, and you cannot specify a status code more than once.
   */
  code?: number;
  /**
   * The TTL (in seconds) for which to cache responses with the corresponding
   * status code. The maximum allowed value is 1800s (30 minutes), noting that
   * infrequently accessed objects may be evicted from the cache before the
   * defined TTL.
   */
  ttl?: number;
}

/**
 * Connection Tracking configuration for this BackendService.
 */
export interface BackendServiceConnectionTrackingPolicy {
  /**
   * Specifies connection persistence when backends are unhealthy. The default
   * value is DEFAULT_FOR_PROTOCOL. If set to DEFAULT_FOR_PROTOCOL, the existing
   * connections persist on unhealthy backends only for connection-oriented
   * protocols (TCP and SCTP) and only if the Tracking Mode is PER_CONNECTION
   * (default tracking mode) or the Session Affinity is configured for 5-tuple.
   * They do not persist for UDP. If set to NEVER_PERSIST, after a backend
   * becomes unhealthy, the existing connections on the unhealthy backend are
   * never persisted on the unhealthy backend. They are always diverted to newly
   * selected healthy backends (unless all backends are unhealthy). If set to
   * ALWAYS_PERSIST, existing connections always persist on unhealthy backends
   * regardless of protocol and session affinity. It is generally not
   * recommended to use this mode overriding the default. For more details, see
   * [Connection Persistence for Network Load
   * Balancing](https://cloud.google.com/load-balancing/docs/network/networklb-backend-service#connection-persistence)
   * and [Connection Persistence for Internal TCP/UDP Load
   * Balancing](https://cloud.google.com/load-balancing/docs/internal#connection-persistence).
   */
  connectionPersistenceOnUnhealthyBackends?:  | "ALWAYS_PERSIST" | "DEFAULT_FOR_PROTOCOL" | "NEVER_PERSIST";
  /**
   * Enable Strong Session Affinity for Network Load Balancing. This option is
   * not available publicly.
   */
  enableStrongAffinity?: boolean;
  /**
   * Specifies how long to keep a Connection Tracking entry while there is no
   * matching traffic (in seconds). For Internal TCP/UDP Load Balancing: - The
   * minimum (default) is 10 minutes and the maximum is 16 hours. - It can be
   * set only if Connection Tracking is less than 5-tuple (i.e. Session Affinity
   * is CLIENT_IP_NO_DESTINATION, CLIENT_IP or CLIENT_IP_PROTO, and Tracking
   * Mode is PER_SESSION). For Network Load Balancer the default is 60 seconds.
   * This option is not available publicly.
   */
  idleTimeoutSec?: number;
  /**
   * Specifies the key used for connection tracking. There are two options: -
   * PER_CONNECTION: This is the default mode. The Connection Tracking is
   * performed as per the Connection Key (default Hash Method) for the specific
   * protocol. - PER_SESSION: The Connection Tracking is performed as per the
   * configured Session Affinity. It matches the configured Session Affinity.
   * For more details, see [Tracking Mode for Network Load
   * Balancing](https://cloud.google.com/load-balancing/docs/network/networklb-backend-service#tracking-mode)
   * and [Tracking Mode for Internal TCP/UDP Load
   * Balancing](https://cloud.google.com/load-balancing/docs/internal#tracking-mode).
   */
  trackingMode?:  | "INVALID_TRACKING_MODE" | "PER_CONNECTION" | "PER_SESSION";
}

/**
 * For load balancers that have configurable failover: [Internal TCP/UDP Load
 * Balancing](https://cloud.google.com/load-balancing/docs/internal/failover-overview)
 * and [external TCP/UDP Load
 * Balancing](https://cloud.google.com/load-balancing/docs/network/networklb-failover-overview).
 * On failover or failback, this field indicates whether connection draining
 * will be honored. Google Cloud has a fixed connection draining timeout of 10
 * minutes. A setting of true terminates existing TCP connections to the active
 * pool during failover and failback, immediately draining traffic. A setting of
 * false allows existing TCP connections to persist, even on VMs no longer in
 * the active pool, for up to the duration of the connection draining timeout
 * (10 minutes).
 */
export interface BackendServiceFailoverPolicy {
  /**
   * This can be set to true only if the protocol is TCP. The default is false.
   */
  disableConnectionDrainOnFailover?: boolean;
  /**
   * If set to true, connections to the load balancer are dropped when all
   * primary and all backup backend VMs are unhealthy.If set to false,
   * connections are distributed among all primary VMs when all primary and all
   * backup backend VMs are unhealthy. For load balancers that have configurable
   * failover: [Internal TCP/UDP Load
   * Balancing](https://cloud.google.com/load-balancing/docs/internal/failover-overview)
   * and [external TCP/UDP Load
   * Balancing](https://cloud.google.com/load-balancing/docs/network/networklb-failover-overview).
   * The default is false.
   */
  dropTrafficIfUnhealthy?: boolean;
  /**
   * The value of the field must be in the range [0, 1]. If the value is 0, the
   * load balancer performs a failover when the number of healthy primary VMs
   * equals zero. For all other values, the load balancer performs a failover
   * when the total number of healthy primary VMs is less than this ratio. For
   * load balancers that have configurable failover: [Internal TCP/UDP Load
   * Balancing](https://cloud.google.com/load-balancing/docs/internal/failover-overview)
   * and [external TCP/UDP Load
   * Balancing](https://cloud.google.com/load-balancing/docs/network/networklb-failover-overview).
   */
  failoverRatio?: number;
}

export interface BackendServiceGroupHealth {
  /**
   * Metadata defined as annotations on the network endpoint group.
   */
  annotations?: {
    [key: string]: string
  };
  /**
   * Health state of the backend instances or endpoints in requested instance
   * or network endpoint group, determined based on configured health checks.
   */
  healthStatus?: HealthStatus[];
  /**
   * [Output Only] Type of resource. Always compute#backendServiceGroupHealth
   * for the health of backend services.
   */
  kind?: string;
}

/**
 * Identity-Aware Proxy
 */
export interface BackendServiceIAP {
  /**
   * Whether the serving infrastructure will authenticate and authorize all
   * incoming requests. If true, the oauth2ClientId and oauth2ClientSecret
   * fields must be non-empty.
   */
  enabled?: boolean;
  /**
   * OAuth2 client ID to use for the authentication flow.
   */
  oauth2ClientId?: string;
  /**
   * OAuth2 client secret to use for the authentication flow. For security
   * reasons, this value cannot be retrieved via the API. Instead, the SHA-256
   * hash of the value is returned in the oauth2ClientSecretSha256 field.
   * @InputOnly
   */
  oauth2ClientSecret?: string;
  /**
   * [Output Only] SHA256 hash value for the field oauth2_client_secret above.
   */
  oauth2ClientSecretSha256?: string;
}

/**
 * Contains a list of BackendService resources.
 */
export interface BackendServiceList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of BackendService resources.
   */
  items?: BackendService[];
  /**
   * [Output Only] Type of resource. Always compute#backendServiceList for
   * lists of backend services.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeBackendServiceList(data: any): BackendServiceList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeBackendService(item))) : undefined,
  };
}

function deserializeBackendServiceList(data: any): BackendServiceList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeBackendService(item))) : undefined,
  };
}

/**
 * Container for either a built-in LB policy supported by gRPC or Envoy or a
 * custom one implemented by the end user.
 */
export interface BackendServiceLocalityLoadBalancingPolicyConfig {
  customPolicy?: BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicy;
  policy?: BackendServiceLocalityLoadBalancingPolicyConfigPolicy;
}

/**
 * The configuration for a custom policy implemented by the user and deployed
 * with the client.
 */
export interface BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicy {
  /**
   * An optional, arbitrary JSON object with configuration data, understood by
   * a locally installed custom policy implementation.
   */
  data?: string;
  /**
   * Identifies the custom policy. The value should match the name of a custom
   * implementation registered on the gRPC clients. It should follow protocol
   * buffer message naming conventions and include the full path (for example,
   * myorg.CustomLbPolicy). The maximum length is 256 characters. Do not specify
   * the same custom policy more than once for a backend. If you do, the
   * configuration is rejected. For an example of how to use this field, see Use
   * a custom policy.
   */
  name?: string;
}

/**
 * The configuration for a built-in load balancing policy.
 */
export interface BackendServiceLocalityLoadBalancingPolicyConfigPolicy {
  /**
   * The name of a locality load-balancing policy. Valid values include
   * ROUND_ROBIN and, for Java clients, LEAST_REQUEST. For information about
   * these values, see the description of localityLbPolicy. Do not specify the
   * same policy more than once for a backend. If you do, the configuration is
   * rejected.
   */
  name?:  | "INVALID_LB_POLICY" | "LEAST_REQUEST" | "MAGLEV" | "ORIGINAL_DESTINATION" | "RANDOM" | "RING_HASH" | "ROUND_ROBIN" | "WEIGHTED_MAGLEV";
}

/**
 * The available logging options for the load balancer traffic served by this
 * backend service.
 */
export interface BackendServiceLogConfig {
  /**
   * Denotes whether to enable logging for the load balancer traffic served by
   * this backend service. The default value is false.
   */
  enable?: boolean;
  /**
   * This field can only be specified if logging is enabled for this backend
   * service and "logConfig.optionalMode" was set to CUSTOM. Contains a list of
   * optional fields you want to include in the logs. For example:
   * serverInstance, serverGkeDetails.cluster, serverGkeDetails.pod.podNamespace
   */
  optionalFields?: string[];
  /**
   * This field can only be specified if logging is enabled for this backend
   * service. Configures whether all, none or a subset of optional fields should
   * be added to the reported logs. One of [INCLUDE_ALL_OPTIONAL,
   * EXCLUDE_ALL_OPTIONAL, CUSTOM]. Default is EXCLUDE_ALL_OPTIONAL.
   */
  optionalMode?:  | "CUSTOM" | "EXCLUDE_ALL_OPTIONAL" | "INCLUDE_ALL_OPTIONAL";
  /**
   * This field can only be specified if logging is enabled for this backend
   * service. The value of the field must be in [0, 1]. This configures the
   * sampling rate of requests to the load balancer where 1.0 means all logged
   * requests are reported and 0.0 means no logged requests are reported. The
   * default value is 1.0.
   */
  sampleRate?: number;
}

export interface BackendServiceReference {
  backendService?: string;
}

/**
 * Additional options for Compute#backendServicesAddSignedUrlKey.
 */
export interface BackendServicesAddSignedUrlKeyOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#backendServicesAggregatedList.
 */
export interface BackendServicesAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#backendServicesDelete.
 */
export interface BackendServicesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#backendServicesDeleteSignedUrlKey.
 */
export interface BackendServicesDeleteSignedUrlKeyOptions {
  /**
   * The name of the Signed URL Key to delete.
   */
  keyName: string;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#backendServicesGetIamPolicy.
 */
export interface BackendServicesGetIamPolicyOptions {
  /**
   * Requested IAM Policy version.
   */
  optionsRequestedPolicyVersion?: number;
}

/**
 * Additional options for Compute#backendServicesInsert.
 */
export interface BackendServicesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#backendServicesList.
 */
export interface BackendServicesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#backendServicesPatch.
 */
export interface BackendServicesPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface BackendServicesScopedList {
  /**
   * A list of BackendServices contained in this scope.
   */
  backendServices?: BackendService[];
  /**
   * Informational warning which replaces the list of backend services when the
   * list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeBackendServicesScopedList(data: any): BackendServicesScopedList {
  return {
    ...data,
    backendServices: data["backendServices"] !== undefined ? data["backendServices"].map((item: any) => (serializeBackendService(item))) : undefined,
  };
}

function deserializeBackendServicesScopedList(data: any): BackendServicesScopedList {
  return {
    ...data,
    backendServices: data["backendServices"] !== undefined ? data["backendServices"].map((item: any) => (deserializeBackendService(item))) : undefined,
  };
}

/**
 * Additional options for Compute#backendServicesSetEdgeSecurityPolicy.
 */
export interface BackendServicesSetEdgeSecurityPolicyOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#backendServicesSetSecurityPolicy.
 */
export interface BackendServicesSetSecurityPolicyOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#backendServicesUpdate.
 */
export interface BackendServicesUpdateOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface BfdPacket {
  /**
   * The Authentication Present bit of the BFD packet. This is specified in
   * section 4.1 of RFC5880
   */
  authenticationPresent?: boolean;
  /**
   * The Control Plane Independent bit of the BFD packet. This is specified in
   * section 4.1 of RFC5880
   */
  controlPlaneIndependent?: boolean;
  /**
   * The demand bit of the BFD packet. This is specified in section 4.1 of
   * RFC5880
   */
  demand?: boolean;
  /**
   * The diagnostic code specifies the local system's reason for the last
   * change in session state. This allows remote systems to determine the reason
   * that the previous session failed, for example. These diagnostic codes are
   * specified in section 4.1 of RFC5880
   */
  diagnostic?:  | "ADMINISTRATIVELY_DOWN" | "CONCATENATED_PATH_DOWN" | "CONTROL_DETECTION_TIME_EXPIRED" | "DIAGNOSTIC_UNSPECIFIED" | "ECHO_FUNCTION_FAILED" | "FORWARDING_PLANE_RESET" | "NEIGHBOR_SIGNALED_SESSION_DOWN" | "NO_DIAGNOSTIC" | "PATH_DOWN" | "REVERSE_CONCATENATED_PATH_DOWN";
  /**
   * The Final bit of the BFD packet. This is specified in section 4.1 of
   * RFC5880
   */
  final?: boolean;
  /**
   * The length of the BFD Control packet in bytes. This is specified in
   * section 4.1 of RFC5880
   */
  length?: number;
  /**
   * The Required Min Echo RX Interval value in the BFD packet. This is
   * specified in section 4.1 of RFC5880
   */
  minEchoRxIntervalMs?: number;
  /**
   * The Required Min RX Interval value in the BFD packet. This is specified in
   * section 4.1 of RFC5880
   */
  minRxIntervalMs?: number;
  /**
   * The Desired Min TX Interval value in the BFD packet. This is specified in
   * section 4.1 of RFC5880
   */
  minTxIntervalMs?: number;
  /**
   * The detection time multiplier of the BFD packet. This is specified in
   * section 4.1 of RFC5880
   */
  multiplier?: number;
  /**
   * The multipoint bit of the BFD packet. This is specified in section 4.1 of
   * RFC5880
   */
  multipoint?: boolean;
  /**
   * The My Discriminator value in the BFD packet. This is specified in section
   * 4.1 of RFC5880
   */
  myDiscriminator?: number;
  /**
   * The Poll bit of the BFD packet. This is specified in section 4.1 of
   * RFC5880
   */
  poll?: boolean;
  /**
   * The current BFD session state as seen by the transmitting system. These
   * states are specified in section 4.1 of RFC5880
   */
  state?:  | "ADMIN_DOWN" | "DOWN" | "INIT" | "STATE_UNSPECIFIED" | "UP";
  /**
   * The version number of the BFD protocol, as specified in section 4.1 of
   * RFC5880.
   */
  version?: number;
  /**
   * The Your Discriminator value in the BFD packet. This is specified in
   * section 4.1 of RFC5880
   */
  yourDiscriminator?: number;
}

/**
 * Next free: 15
 */
export interface BfdStatus {
  /**
   * The BFD session initialization mode for this BGP peer. If set to ACTIVE,
   * the Cloud Router will initiate the BFD session for this BGP peer. If set to
   * PASSIVE, the Cloud Router will wait for the peer router to initiate the BFD
   * session for this BGP peer. If set to DISABLED, BFD is disabled for this BGP
   * peer.
   */
  bfdSessionInitializationMode?:  | "ACTIVE" | "DISABLED" | "PASSIVE";
  /**
   * Unix timestamp of the most recent config update.
   */
  configUpdateTimestampMicros?: bigint;
  /**
   * Control packet counts for the current BFD session.
   */
  controlPacketCounts?: BfdStatusPacketCounts;
  /**
   * Inter-packet time interval statistics for control packets.
   */
  controlPacketIntervals?: PacketIntervals[];
  /**
   * The diagnostic code specifies the local system's reason for the last
   * change in session state. This allows remote systems to determine the reason
   * that the previous session failed, for example. These diagnostic codes are
   * specified in section 4.1 of RFC5880
   */
  localDiagnostic?:  | "ADMINISTRATIVELY_DOWN" | "CONCATENATED_PATH_DOWN" | "CONTROL_DETECTION_TIME_EXPIRED" | "DIAGNOSTIC_UNSPECIFIED" | "ECHO_FUNCTION_FAILED" | "FORWARDING_PLANE_RESET" | "NEIGHBOR_SIGNALED_SESSION_DOWN" | "NO_DIAGNOSTIC" | "PATH_DOWN" | "REVERSE_CONCATENATED_PATH_DOWN";
  /**
   * The current BFD session state as seen by the transmitting system. These
   * states are specified in section 4.1 of RFC5880
   */
  localState?:  | "ADMIN_DOWN" | "DOWN" | "INIT" | "STATE_UNSPECIFIED" | "UP";
  /**
   * Negotiated transmit interval for control packets.
   */
  negotiatedLocalControlTxIntervalMs?: number;
  /**
   * The most recent Rx control packet for this BFD session.
   */
  rxPacket?: BfdPacket;
  /**
   * The most recent Tx control packet for this BFD session.
   */
  txPacket?: BfdPacket;
  /**
   * Session uptime in milliseconds. Value will be 0 if session is not up.
   */
  uptimeMs?: bigint;
}

function serializeBfdStatus(data: any): BfdStatus {
  return {
    ...data,
    configUpdateTimestampMicros: data["configUpdateTimestampMicros"] !== undefined ? String(data["configUpdateTimestampMicros"]) : undefined,
    controlPacketIntervals: data["controlPacketIntervals"] !== undefined ? data["controlPacketIntervals"].map((item: any) => (serializePacketIntervals(item))) : undefined,
    uptimeMs: data["uptimeMs"] !== undefined ? String(data["uptimeMs"]) : undefined,
  };
}

function deserializeBfdStatus(data: any): BfdStatus {
  return {
    ...data,
    configUpdateTimestampMicros: data["configUpdateTimestampMicros"] !== undefined ? BigInt(data["configUpdateTimestampMicros"]) : undefined,
    controlPacketIntervals: data["controlPacketIntervals"] !== undefined ? data["controlPacketIntervals"].map((item: any) => (deserializePacketIntervals(item))) : undefined,
    uptimeMs: data["uptimeMs"] !== undefined ? BigInt(data["uptimeMs"]) : undefined,
  };
}

export interface BfdStatusPacketCounts {
  /**
   * Number of packets received since the beginning of the current BFD session.
   */
  numRx?: number;
  /**
   * Number of packets received that were rejected because of errors since the
   * beginning of the current BFD session.
   */
  numRxRejected?: number;
  /**
   * Number of packets received that were successfully processed since the
   * beginning of the current BFD session.
   */
  numRxSuccessful?: number;
  /**
   * Number of packets transmitted since the beginning of the current BFD
   * session.
   */
  numTx?: number;
}

/**
 * Associates `members`, or principals, with a `role`.
 */
export interface Binding {
  /**
   * This is deprecated and has no effect. Do not use.
   */
  bindingId?: string;
  /**
   * The condition that is associated with this binding. If the condition
   * evaluates to `true`, then this binding applies to the current request. If
   * the condition evaluates to `false`, then this binding does not apply to the
   * current request. However, a different role binding might grant the same
   * role to one or more of the principals in this binding. To learn which
   * resources support conditions in their IAM policies, see the [IAM
   * documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
   */
  condition?: Expr;
  /**
   * Specifies the principals requesting access for a Google Cloud resource.
   * `members` can have the following values: * `allUsers`: A special identifier
   * that represents anyone who is on the internet; with or without a Google
   * account. * `allAuthenticatedUsers`: A special identifier that represents
   * anyone who is authenticated with a Google account or a service account.
   * Does not include identities that come from external identity providers
   * (IdPs) through identity federation. * `user:{emailid}`: An email address
   * that represents a specific Google account. For example, `alice@example.com`
   * . * `serviceAccount:{emailid}`: An email address that represents a Google
   * service account. For example, `my-other-app@appspot.gserviceaccount.com`. *
   * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An
   * identifier for a [Kubernetes service
   * account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts).
   * For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. *
   * `group:{emailid}`: An email address that represents a Google group. For
   * example, `admins@example.com`. * `domain:{domain}`: The G Suite domain
   * (primary) that represents all the users of that domain. For example,
   * `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`:
   * An email address (plus unique identifier) representing a user that has been
   * recently deleted. For example,
   * `alice@example.com?uid=123456789012345678901`. If the user is recovered,
   * this value reverts to `user:{emailid}` and the recovered user retains the
   * role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`:
   * An email address (plus unique identifier) representing a service account
   * that has been recently deleted. For example,
   * `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If
   * the service account is undeleted, this value reverts to
   * `serviceAccount:{emailid}` and the undeleted service account retains the
   * role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email
   * address (plus unique identifier) representing a Google group that has been
   * recently deleted. For example,
   * `admins@example.com?uid=123456789012345678901`. If the group is recovered,
   * this value reverts to `group:{emailid}` and the recovered group retains the
   * role in the binding.
   */
  members?: string[];
  /**
   * Role that is assigned to the list of `members`, or principals. For
   * example, `roles/viewer`, `roles/editor`, or `roles/owner`.
   */
  role?: string;
}

/**
 * A transient resource used in compute.instances.bulkInsert and
 * compute.regionInstances.bulkInsert . This resource is not persisted anywhere,
 * it is used only for processing the requests.
 */
export interface BulkInsertInstanceResource {
  /**
   * The maximum number of instances to create.
   */
  count?: bigint;
  /**
   * The instance properties defining the VM instances to be created. Required
   * if sourceInstanceTemplate is not provided.
   */
  instanceProperties?: InstanceProperties;
  /**
   * Policy for chosing target zone. For more information, see Create VMs in
   * bulk .
   */
  locationPolicy?: LocationPolicy;
  /**
   * The minimum number of instances to create. If no min_count is specified
   * then count is used as the default value. If min_count instances cannot be
   * created, then no instances will be created and instances already created
   * will be deleted.
   */
  minCount?: bigint;
  /**
   * The string pattern used for the names of the VMs. Either name_pattern or
   * per_instance_properties must be set. The pattern must contain one
   * continuous sequence of placeholder hash characters (#) with each character
   * corresponding to one digit of the generated instance name. Example: a
   * name_pattern of inst-#### generates instance names such as inst-0001 and
   * inst-0002. If existing instances in the same project and zone have names
   * that match the name pattern then the generated instance numbers start after
   * the biggest existing number. For example, if there exists an instance with
   * name inst-0050, then instance names generated using the pattern inst-####
   * begin with inst-0051. The name pattern placeholder #...# can contain up to
   * 18 characters.
   */
  namePattern?: string;
  /**
   * Per-instance properties to be set on individual instances. Keys of this
   * map specify requested instance names. Can be empty if name_pattern is used.
   */
  perInstanceProperties?: {
    [key: string]: BulkInsertInstanceResourcePerInstanceProperties
  };
  /**
   * Specifies the instance template from which to create instances. You may
   * combine sourceInstanceTemplate with instanceProperties to override specific
   * values from an existing instance template. Bulk API follows the semantics
   * of JSON Merge Patch described by RFC 7396. It can be a full or partial URL.
   * For example, the following are all valid URLs to an instance template: -
   * https://www.googleapis.com/compute/v1/projects/project
   * /global/instanceTemplates/instanceTemplate -
   * projects/project/global/instanceTemplates/instanceTemplate -
   * global/instanceTemplates/instanceTemplate This field is optional.
   */
  sourceInstanceTemplate?: string;
}

function serializeBulkInsertInstanceResource(data: any): BulkInsertInstanceResource {
  return {
    ...data,
    count: data["count"] !== undefined ? String(data["count"]) : undefined,
    instanceProperties: data["instanceProperties"] !== undefined ? serializeInstanceProperties(data["instanceProperties"]) : undefined,
    minCount: data["minCount"] !== undefined ? String(data["minCount"]) : undefined,
  };
}

function deserializeBulkInsertInstanceResource(data: any): BulkInsertInstanceResource {
  return {
    ...data,
    count: data["count"] !== undefined ? BigInt(data["count"]) : undefined,
    instanceProperties: data["instanceProperties"] !== undefined ? deserializeInstanceProperties(data["instanceProperties"]) : undefined,
    minCount: data["minCount"] !== undefined ? BigInt(data["minCount"]) : undefined,
  };
}

/**
 * Per-instance properties to be set on individual instances. To be extended in
 * the future.
 */
export interface BulkInsertInstanceResourcePerInstanceProperties {
  /**
   * This field is only temporary. It will be removed. Do not use it.
   */
  name?: string;
}

export interface CacheInvalidationRule {
  /**
   * If set, this invalidation rule will only apply to requests with a Host
   * header matching host.
   */
  host?: string;
  path?: string;
}

/**
 * Message containing what to include in the cache key for a request for Cloud
 * CDN.
 */
export interface CacheKeyPolicy {
  /**
   * If true, requests to different hosts will be cached separately.
   */
  includeHost?: boolean;
  /**
   * Allows HTTP request headers (by name) to be used in the cache key.
   */
  includeHttpHeaders?: string[];
  /**
   * Allows HTTP cookies (by name) to be used in the cache key. The name=value
   * pair will be used in the cache key Cloud CDN generates.
   */
  includeNamedCookies?: string[];
  /**
   * If true, http and https requests will be cached separately.
   */
  includeProtocol?: boolean;
  /**
   * If true, include query string parameters in the cache key according to
   * query_string_whitelist and query_string_blacklist. If neither is set, the
   * entire query string will be included. If false, the query string will be
   * excluded from the cache key entirely.
   */
  includeQueryString?: boolean;
  /**
   * Names of query string parameters to exclude in cache keys. All other
   * parameters will be included. Either specify query_string_whitelist or
   * query_string_blacklist, not both. '&' and '=' will be percent encoded and
   * not treated as delimiters.
   */
  queryStringBlacklist?: string[];
  /**
   * Names of query string parameters to include in cache keys. All other
   * parameters will be excluded. Either specify query_string_whitelist or
   * query_string_blacklist, not both. '&' and '=' will be percent encoded and
   * not treated as delimiters.
   */
  queryStringWhitelist?: string[];
}

/**
 * Settings controlling the volume of requests, connections and retries to this
 * backend service.
 */
export interface CircuitBreakers {
  /**
   * The maximum number of connections to the backend service. If not
   * specified, there is no limit. Not supported when the backend service is
   * referenced by a URL map that is bound to target gRPC proxy that has
   * validateForProxyless field set to true.
   */
  maxConnections?: number;
  /**
   * The maximum number of pending requests allowed to the backend service. If
   * not specified, there is no limit. Not supported when the backend service is
   * referenced by a URL map that is bound to target gRPC proxy that has
   * validateForProxyless field set to true.
   */
  maxPendingRequests?: number;
  /**
   * The maximum number of parallel requests that allowed to the backend
   * service. If not specified, there is no limit.
   */
  maxRequests?: number;
  /**
   * Maximum requests for a single connection to the backend service. This
   * parameter is respected by both the HTTP/1.1 and HTTP/2 implementations. If
   * not specified, there is no limit. Setting this parameter to 1 will
   * effectively disable keep alive. Not supported when the backend service is
   * referenced by a URL map that is bound to target gRPC proxy that has
   * validateForProxyless field set to true.
   */
  maxRequestsPerConnection?: number;
  /**
   * The maximum number of parallel retries allowed to the backend cluster. If
   * not specified, the default is 1. Not supported when the backend service is
   * referenced by a URL map that is bound to target gRPC proxy that has
   * validateForProxyless field set to true.
   */
  maxRetries?: number;
}

/**
 * Represents a regional Commitment resource. Creating a commitment resource
 * means that you are purchasing a committed use contract with an explicit start
 * and end time. You can create commitments based on vCPUs and memory usage and
 * receive discounted rates. For full details, read Signing Up for Committed Use
 * Discounts.
 */
export interface Commitment {
  /**
   * Specifies whether to enable automatic renewal for the commitment. The
   * default value is false if not specified. The field can be updated until the
   * day of the commitment expiration at 12:00am PST. If the field is set to
   * true, the commitment will be automatically renewed for either one or three
   * years according to the terms of the existing commitment.
   */
  autoRenew?: boolean;
  /**
   * The category of the commitment. Category MACHINE specifies commitments
   * composed of machine resources such as VCPU or MEMORY, listed in resources.
   * Category LICENSE specifies commitments composed of software licenses,
   * listed in licenseResources. Note that only MACHINE commitments should have
   * a Type specified.
   */
  category?:  | "CATEGORY_UNSPECIFIED" | "LICENSE" | "MACHINE";
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * [Output Only] Commitment end time in RFC3339 text format.
   */
  endTimestamp?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of the resource. Always compute#commitment for
   * commitments.
   */
  kind?: string;
  /**
   * The license specification required as part of a license commitment.
   */
  licenseResource?: LicenseResourceCommitment;
  /**
   * List of source commitments to be merged into a new commitment.
   */
  mergeSourceCommitments?: string[];
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * The plan for this commitment, which determines duration and discount rate.
   * The currently supported plans are TWELVE_MONTH (1 year), and
   * THIRTY_SIX_MONTH (3 years).
   */
  plan?:  | "INVALID" | "THIRTY_SIX_MONTH" | "TWELVE_MONTH";
  /**
   * [Output Only] URL of the region where this commitment may be used.
   */
  region?: string;
  /**
   * List of reservations in this commitment.
   */
  reservations?: Reservation[];
  /**
   * A list of commitment amounts for particular resources. Note that VCPU and
   * MEMORY resource commitments must occur together.
   */
  resources?: ResourceCommitment[];
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * Source commitment to be splitted into a new commitment.
   */
  splitSourceCommitment?: string;
  /**
   * [Output Only] Commitment start time in RFC3339 text format.
   */
  startTimestamp?: string;
  /**
   * [Output Only] Status of the commitment with regards to eventual expiration
   * (each commitment has an end date defined). One of the following values:
   * NOT_YET_ACTIVE, ACTIVE, EXPIRED.
   */
  status?:  | "ACTIVE" | "CANCELLED" | "CREATING" | "EXPIRED" | "NOT_YET_ACTIVE";
  /**
   * [Output Only] An optional, human-readable explanation of the status.
   */
  statusMessage?: string;
  /**
   * The type of commitment, which affects the discount rate and the eligible
   * resources. Type MEMORY_OPTIMIZED specifies a commitment that will only
   * apply to memory optimized machines. Type ACCELERATOR_OPTIMIZED specifies a
   * commitment that will only apply to accelerator optimized machines.
   */
  type?:  | "ACCELERATOR_OPTIMIZED" | "COMPUTE_OPTIMIZED" | "COMPUTE_OPTIMIZED_C2D" | "COMPUTE_OPTIMIZED_C3" | "GENERAL_PURPOSE" | "GENERAL_PURPOSE_E2" | "GENERAL_PURPOSE_N2" | "GENERAL_PURPOSE_N2D" | "GENERAL_PURPOSE_T2D" | "MEMORY_OPTIMIZED" | "MEMORY_OPTIMIZED_M3" | "TYPE_UNSPECIFIED";
}

function serializeCommitment(data: any): Commitment {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
    licenseResource: data["licenseResource"] !== undefined ? serializeLicenseResourceCommitment(data["licenseResource"]) : undefined,
    reservations: data["reservations"] !== undefined ? data["reservations"].map((item: any) => (serializeReservation(item))) : undefined,
    resources: data["resources"] !== undefined ? data["resources"].map((item: any) => (serializeResourceCommitment(item))) : undefined,
  };
}

function deserializeCommitment(data: any): Commitment {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
    licenseResource: data["licenseResource"] !== undefined ? deserializeLicenseResourceCommitment(data["licenseResource"]) : undefined,
    reservations: data["reservations"] !== undefined ? data["reservations"].map((item: any) => (deserializeReservation(item))) : undefined,
    resources: data["resources"] !== undefined ? data["resources"].map((item: any) => (deserializeResourceCommitment(item))) : undefined,
  };
}

export interface CommitmentAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of CommitmentsScopedList resources.
   */
  items?: {
    [key: string]: CommitmentsScopedList
  };
  /**
   * [Output Only] Type of resource. Always compute#commitmentAggregatedList
   * for aggregated lists of commitments.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeCommitmentAggregatedList(data: any): CommitmentAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeCommitmentsScopedList(v)]))) : undefined,
  };
}

function deserializeCommitmentAggregatedList(data: any): CommitmentAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeCommitmentsScopedList(v)]))) : undefined,
  };
}

/**
 * Contains a list of Commitment resources.
 */
export interface CommitmentList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of Commitment resources.
   */
  items?: Commitment[];
  /**
   * [Output Only] Type of resource. Always compute#commitmentList for lists of
   * commitments.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeCommitmentList(data: any): CommitmentList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeCommitment(item))) : undefined,
  };
}

function deserializeCommitmentList(data: any): CommitmentList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeCommitment(item))) : undefined,
  };
}

export interface CommitmentsScopedList {
  /**
   * [Output Only] A list of commitments contained in this scope.
   */
  commitments?: Commitment[];
  /**
   * [Output Only] Informational warning which replaces the list of commitments
   * when the list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeCommitmentsScopedList(data: any): CommitmentsScopedList {
  return {
    ...data,
    commitments: data["commitments"] !== undefined ? data["commitments"].map((item: any) => (serializeCommitment(item))) : undefined,
  };
}

function deserializeCommitmentsScopedList(data: any): CommitmentsScopedList {
  return {
    ...data,
    commitments: data["commitments"] !== undefined ? data["commitments"].map((item: any) => (deserializeCommitment(item))) : undefined,
  };
}

/**
 * This is deprecated and has no effect. Do not use.
 */
export interface Condition {
  /**
   * This is deprecated and has no effect. Do not use.
   */
  iam?:  | "APPROVER" | "ATTRIBUTION" | "AUTHORITY" | "CREDENTIALS_TYPE" | "CREDS_ASSERTION" | "JUSTIFICATION_TYPE" | "NO_ATTR" | "SECURITY_REALM";
  /**
   * This is deprecated and has no effect. Do not use.
   */
  op?:  | "DISCHARGED" | "EQUALS" | "IN" | "NOT_EQUALS" | "NOT_IN" | "NO_OP";
  /**
   * This is deprecated and has no effect. Do not use.
   */
  svc?: string;
  /**
   * This is deprecated and has no effect. Do not use.
   */
  sys?:  | "IP" | "NAME" | "NO_ATTR" | "REGION" | "SERVICE";
  /**
   * This is deprecated and has no effect. Do not use.
   */
  values?: string[];
}

/**
 * A set of Confidential Instance options.
 */
export interface ConfidentialInstanceConfig {
  /**
   * Defines whether the instance should have confidential compute enabled.
   */
  enableConfidentialCompute?: boolean;
}

/**
 * Message containing connection draining configuration.
 */
export interface ConnectionDraining {
  /**
   * Configures a duration timeout for existing requests on a removed backend
   * instance. For supported load balancers and protocols, as described in
   * Enabling connection draining.
   */
  drainingTimeoutSec?: number;
}

/**
 * This message defines settings for a consistent hash style load balancer.
 */
export interface ConsistentHashLoadBalancerSettings {
  /**
   * Hash is based on HTTP Cookie. This field describes a HTTP cookie that will
   * be used as the hash key for the consistent hash load balancer. If the
   * cookie is not present, it will be generated. This field is applicable if
   * the sessionAffinity is set to HTTP_COOKIE. Not supported when the backend
   * service is referenced by a URL map that is bound to target gRPC proxy that
   * has validateForProxyless field set to true.
   */
  httpCookie?: ConsistentHashLoadBalancerSettingsHttpCookie;
  /**
   * The hash based on the value of the specified header field. This field is
   * applicable if the sessionAffinity is set to HEADER_FIELD.
   */
  httpHeaderName?: string;
  /**
   * The minimum number of virtual nodes to use for the hash ring. Defaults to
   * 1024. Larger ring sizes result in more granular load distributions. If the
   * number of hosts in the load balancing pool is larger than the ring size,
   * each host will be assigned a single virtual node.
   */
  minimumRingSize?: bigint;
}

function serializeConsistentHashLoadBalancerSettings(data: any): ConsistentHashLoadBalancerSettings {
  return {
    ...data,
    httpCookie: data["httpCookie"] !== undefined ? serializeConsistentHashLoadBalancerSettingsHttpCookie(data["httpCookie"]) : undefined,
    minimumRingSize: data["minimumRingSize"] !== undefined ? String(data["minimumRingSize"]) : undefined,
  };
}

function deserializeConsistentHashLoadBalancerSettings(data: any): ConsistentHashLoadBalancerSettings {
  return {
    ...data,
    httpCookie: data["httpCookie"] !== undefined ? deserializeConsistentHashLoadBalancerSettingsHttpCookie(data["httpCookie"]) : undefined,
    minimumRingSize: data["minimumRingSize"] !== undefined ? BigInt(data["minimumRingSize"]) : undefined,
  };
}

/**
 * The information about the HTTP Cookie on which the hash function is based
 * for load balancing policies that use a consistent hash.
 */
export interface ConsistentHashLoadBalancerSettingsHttpCookie {
  /**
   * Name of the cookie.
   */
  name?: string;
  /**
   * Path to set for the cookie.
   */
  path?: string;
  /**
   * Lifetime of the cookie.
   */
  ttl?: Duration;
}

function serializeConsistentHashLoadBalancerSettingsHttpCookie(data: any): ConsistentHashLoadBalancerSettingsHttpCookie {
  return {
    ...data,
    ttl: data["ttl"] !== undefined ? serializeDuration(data["ttl"]) : undefined,
  };
}

function deserializeConsistentHashLoadBalancerSettingsHttpCookie(data: any): ConsistentHashLoadBalancerSettingsHttpCookie {
  return {
    ...data,
    ttl: data["ttl"] !== undefined ? deserializeDuration(data["ttl"]) : undefined,
  };
}

/**
 * The specification for allowing client-side cross-origin requests. For more
 * information about the W3C recommendation for cross-origin resource sharing
 * (CORS), see Fetch API Living Standard.
 */
export interface CorsPolicy {
  /**
   * In response to a preflight request, setting this to true indicates that
   * the actual request can include user credentials. This field translates to
   * the Access-Control-Allow-Credentials header. Default is false.
   */
  allowCredentials?: boolean;
  /**
   * Specifies the content for the Access-Control-Allow-Headers header.
   */
  allowHeaders?: string[];
  /**
   * Specifies the content for the Access-Control-Allow-Methods header.
   */
  allowMethods?: string[];
  /**
   * Specifies a regular expression that matches allowed origins. For more
   * information about the regular expression syntax, see Syntax. An origin is
   * allowed if it matches either an item in allowOrigins or an item in
   * allowOriginRegexes. Regular expressions can only be used when the
   * loadBalancingScheme is set to INTERNAL_SELF_MANAGED.
   */
  allowOriginRegexes?: string[];
  /**
   * Specifies the list of origins that is allowed to do CORS requests. An
   * origin is allowed if it matches either an item in allowOrigins or an item
   * in allowOriginRegexes.
   */
  allowOrigins?: string[];
  /**
   * If true, the setting specifies the CORS policy is disabled. The default
   * value of false, which indicates that the CORS policy is in effect.
   */
  disabled?: boolean;
  /**
   * Specifies the content for the Access-Control-Expose-Headers header.
   */
  exposeHeaders?: string[];
  /**
   * Specifies how long results of a preflight request can be cached in
   * seconds. This field translates to the Access-Control-Max-Age header.
   */
  maxAge?: number;
}

export interface CustomerEncryptionKey {
  /**
   * The name of the encryption key that is stored in Google Cloud KMS. For
   * example: "kmsKeyName": "projects/kms_project_id/locations/region/keyRings/
   * key_region/cryptoKeys/key
   */
  kmsKeyName?: string;
  /**
   * The service account being used for the encryption request for the given
   * KMS key. If absent, the Compute Engine default service account is used. For
   * example: "kmsKeyServiceAccount": "name@project_id.iam.gserviceaccount.com/
   */
  kmsKeyServiceAccount?: string;
  /**
   * Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648
   * base64 to either encrypt or decrypt this resource. You can provide either
   * the rawKey or the rsaEncryptedKey. For example: "rawKey":
   * "SGVsbG8gZnJvbSBHb29nbGUgQ2xvdWQgUGxhdGZvcm0="
   */
  rawKey?: string;
  /**
   * Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
   * customer-supplied encryption key to either encrypt or decrypt this
   * resource. You can provide either the rawKey or the rsaEncryptedKey. For
   * example: "rsaEncryptedKey":
   * "ieCx/NcW06PcT7Ep1X6LUTc/hLvUDYyzSZPPVCVPTVEohpeHASqC8uw5TzyO9U+Fka9JFH
   * z0mBibXUInrC/jEk014kCK/NPjYgEMOyssZ4ZINPKxlUh2zn1bV+MCaTICrdmuSBTWlUUiFoD
   * D6PYznLwh8ZNdaheCeZ8ewEXgFQ8V+sDroLaN3Xs3MDTXQEMMoNUXMCZEIpg9Vtp9x2oe=="
   * The key must meet the following requirements before you can provide it to
   * Compute Engine: 1. The key is wrapped using a RSA public key certificate
   * provided by Google. 2. After being wrapped, the key must be encoded in RFC
   * 4648 base64 encoding. Gets the RSA public key certificate provided by
   * Google at:
   * https://cloud-certs.storage.googleapis.com/google-cloud-csek-ingress.pem
   */
  rsaEncryptedKey?: string;
  /**
   * [Output only] The RFC 4648 base64 encoded SHA-256 hash of the
   * customer-supplied encryption key that protects this resource.
   */
  sha256?: string;
}

export interface CustomerEncryptionKeyProtectedDisk {
  /**
   * Decrypts data associated with the disk with a customer-supplied encryption
   * key.
   */
  diskEncryptionKey?: CustomerEncryptionKey;
  /**
   * Specifies a valid partial or full URL to an existing Persistent Disk
   * resource. This field is only applicable for persistent disks. For example:
   * "source": "/compute/v1/projects/project_id/zones/zone/disks/ disk_name
   */
  source?: string;
}

/**
 * Deprecation status for a public resource.
 */
export interface DeprecationStatus {
  /**
   * An optional RFC3339 timestamp on or after which the state of this resource
   * is intended to change to DELETED. This is only informational and the status
   * will not change unless the client explicitly changes it.
   */
  deleted?: string;
  /**
   * An optional RFC3339 timestamp on or after which the state of this resource
   * is intended to change to DEPRECATED. This is only informational and the
   * status will not change unless the client explicitly changes it.
   */
  deprecated?: string;
  /**
   * An optional RFC3339 timestamp on or after which the state of this resource
   * is intended to change to OBSOLETE. This is only informational and the
   * status will not change unless the client explicitly changes it.
   */
  obsolete?: string;
  /**
   * The URL of the suggested replacement for a deprecated resource. The
   * suggested replacement resource must be the same kind of resource as the
   * deprecated resource.
   */
  replacement?: string;
  /**
   * The deprecation state of this resource. This can be ACTIVE, DEPRECATED,
   * OBSOLETE, or DELETED. Operations which communicate the end of life date for
   * an image, can use ACTIVE. Operations which create a new resource using a
   * DEPRECATED resource will return successfully, but with a warning indicating
   * the deprecated resource and recommending its replacement. Operations which
   * use OBSOLETE or DELETED resources will be rejected and result in an error.
   */
  state?:  | "ACTIVE" | "DELETED" | "DEPRECATED" | "OBSOLETE";
}

/**
 * Represents a Persistent Disk resource. Google Compute Engine has two Disk
 * resources: * [Zonal](/compute/docs/reference/rest/v1/disks) *
 * [Regional](/compute/docs/reference/rest/v1/regionDisks) Persistent disks are
 * required for running your VM instances. Create both boot and non-boot (data)
 * persistent disks. For more information, read Persistent Disks. For more
 * storage options, read Storage options. The disks resource represents a zonal
 * persistent disk. For more information, read Zonal persistent disks. The
 * regionDisks resource represents a regional persistent disk. For more
 * information, read Regional resources.
 */
export interface Disk {
  /**
   * The architecture of the disk. Valid values are ARM64 or X86_64.
   */
  architecture?:  | "ARCHITECTURE_UNSPECIFIED" | "ARM64" | "X86_64";
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * Encrypts the disk using a customer-supplied encryption key or a
   * customer-managed encryption key. Encryption keys do not protect access to
   * metadata of the disk. After you encrypt a disk with a customer-supplied
   * key, you must provide the same key if you use the disk later. For example,
   * to create a disk snapshot, to create a disk image, to create a machine
   * image, or to attach the disk to a virtual machine. After you encrypt a disk
   * with a customer-managed key, the diskEncryptionKey.kmsKeyName is set to a
   * key *version* name once the disk is created. The disk is encrypted with
   * this version of the key. In the response, diskEncryptionKey.kmsKeyName
   * appears in the following format: "diskEncryptionKey.kmsKeyName":
   * "projects/kms_project_id/locations/region/keyRings/
   * key_region/cryptoKeys/key /cryptoKeysVersions/version If you do not provide
   * an encryption key when creating the disk, then the disk is encrypted using
   * an automatically generated key and you don't need to provide a key to use
   * the disk later.
   */
  diskEncryptionKey?: CustomerEncryptionKey;
  /**
   * A list of features to enable on the guest operating system. Applicable
   * only for bootable images. Read Enabling guest operating system features to
   * see a list of available options.
   */
  guestOsFeatures?: GuestOsFeature[];
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of the resource. Always compute#disk for disks.
   */
  kind?: string;
  /**
   * A fingerprint for the labels being applied to this disk, which is
   * essentially a hash of the labels set used for optimistic locking. The
   * fingerprint is initially generated by Compute Engine and changes after
   * every request to modify or update labels. You must always provide an
   * up-to-date fingerprint hash in order to update or change labels, otherwise
   * the request will fail with error 412 conditionNotMet. To see the latest
   * fingerprint, make a get() request to retrieve a disk.
   */
  labelFingerprint?: Uint8Array;
  /**
   * Labels to apply to this disk. These can be later modified by the setLabels
   * method.
   */
  labels?: {
    [key: string]: string
  };
  /**
   * [Output Only] Last attach timestamp in RFC3339 text format.
   */
  lastAttachTimestamp?: string;
  /**
   * [Output Only] Last detach timestamp in RFC3339 text format.
   */
  lastDetachTimestamp?: string;
  /**
   * Integer license codes indicating which licenses are attached to this disk.
   */
  licenseCodes?: bigint[];
  /**
   * A list of publicly visible licenses. Reserved for Google's use.
   */
  licenses?: string[];
  /**
   * An opaque location hint used to place the disk close to other resources.
   * This field is for use by internal tools that use the public API.
   */
  locationHint?: string;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * Internal use only.
   */
  options?: string;
  /**
   * Input only. [Input Only] Additional params passed with the request, but
   * not persisted as part of resource payload.
   */
  params?: DiskParams;
  /**
   * Physical block size of the persistent disk, in bytes. If not present in a
   * request, a default value is used. The currently supported size is 4096,
   * other sizes may be added in the future. If an unsupported value is
   * requested, the error message will list the supported values for the
   * caller's project.
   */
  physicalBlockSizeBytes?: bigint;
  /**
   * Indicates how many IOPS to provision for the disk. This sets the number of
   * I/O operations per second that the disk can handle. Values must be between
   * 10,000 and 120,000. For more details, see the Extreme persistent disk
   * documentation.
   */
  provisionedIops?: bigint;
  /**
   * [Output Only] URL of the region where the disk resides. Only applicable
   * for regional resources. You must specify this field as part of the HTTP
   * request URL. It is not settable as a field in the request body.
   */
  region?: string;
  /**
   * URLs of the zones where the disk should be replicated to. Only applicable
   * for regional resources.
   */
  replicaZones?: string[];
  /**
   * Resource policies applied to this disk for automatic snapshot creations.
   */
  resourcePolicies?: string[];
  /**
   * [Output Only] Reserved for future use.
   */
  satisfiesPzs?: boolean;
  /**
   * [Output Only] Server-defined fully-qualified URL for this resource.
   */
  selfLink?: string;
  /**
   * Size, in GB, of the persistent disk. You can specify this field when
   * creating a persistent disk using the sourceImage, sourceSnapshot, or
   * sourceDisk parameter, or specify it alone to create an empty persistent
   * disk. If you specify this field along with a source, the value of sizeGb
   * must not be less than the size of the source. Acceptable values are 1 to
   * 65536, inclusive.
   */
  sizeGb?: bigint;
  /**
   * The source disk used to create this disk. You can provide this as a
   * partial or full URL to the resource. For example, the following are valid
   * values: - https://www.googleapis.com/compute/v1/projects/project/zones/zone
   * /disks/disk -
   * https://www.googleapis.com/compute/v1/projects/project/regions/region
   * /disks/disk - projects/project/zones/zone/disks/disk -
   * projects/project/regions/region/disks/disk - zones/zone/disks/disk -
   * regions/region/disks/disk
   */
  sourceDisk?: string;
  /**
   * [Output Only] The unique ID of the disk used to create this disk. This
   * value identifies the exact disk that was used to create this persistent
   * disk. For example, if you created the persistent disk from a disk that was
   * later deleted and recreated under the same name, the source disk ID would
   * identify the exact version of the disk that was used.
   */
  sourceDiskId?: string;
  /**
   * The source image used to create this disk. If the source image is deleted,
   * this field will not be set. To create a disk with one of the public
   * operating system images, specify the image by its family name. For example,
   * specify family/debian-9 to use the latest Debian 9 image:
   * projects/debian-cloud/global/images/family/debian-9 Alternatively, use a
   * specific version of a public operating system image:
   * projects/debian-cloud/global/images/debian-9-stretch-vYYYYMMDD To create a
   * disk with a custom image that you created, specify the image name in the
   * following format: global/images/my-custom-image You can also specify a
   * custom image by its image family, which returns the latest version of the
   * image in that family. Replace the image name with family/family-name:
   * global/images/family/my-image-family
   */
  sourceImage?: string;
  /**
   * The customer-supplied encryption key of the source image. Required if the
   * source image is protected by a customer-supplied encryption key.
   */
  sourceImageEncryptionKey?: CustomerEncryptionKey;
  /**
   * [Output Only] The ID value of the image used to create this disk. This
   * value identifies the exact image that was used to create this persistent
   * disk. For example, if you created the persistent disk from an image that
   * was later deleted and recreated under the same name, the source image ID
   * would identify the exact version of the image that was used.
   */
  sourceImageId?: string;
  /**
   * The source snapshot used to create this disk. You can provide this as a
   * partial or full URL to the resource. For example, the following are valid
   * values: - https://www.googleapis.com/compute/v1/projects/project
   * /global/snapshots/snapshot - projects/project/global/snapshots/snapshot -
   * global/snapshots/snapshot
   */
  sourceSnapshot?: string;
  /**
   * The customer-supplied encryption key of the source snapshot. Required if
   * the source snapshot is protected by a customer-supplied encryption key.
   */
  sourceSnapshotEncryptionKey?: CustomerEncryptionKey;
  /**
   * [Output Only] The unique ID of the snapshot used to create this disk. This
   * value identifies the exact snapshot that was used to create this persistent
   * disk. For example, if you created the persistent disk from a snapshot that
   * was later deleted and recreated under the same name, the source snapshot ID
   * would identify the exact version of the snapshot that was used.
   */
  sourceSnapshotId?: string;
  /**
   * The full Google Cloud Storage URI where the disk image is stored. This
   * file must be a gzip-compressed tarball whose name ends in .tar.gz or
   * virtual machine disk whose name ends in vmdk. Valid URIs may start with
   * gs:// or https://storage.googleapis.com/. This flag is not optimized for
   * creating multiple disks from a source storage object. To create many disks
   * from a source storage object, use gcloud compute images import instead.
   */
  sourceStorageObject?: string;
  /**
   * [Output Only] The status of disk creation. - CREATING: Disk is
   * provisioning. - RESTORING: Source data is being copied into the disk. -
   * FAILED: Disk creation failed. - READY: Disk is ready for use. - DELETING:
   * Disk is deleting.
   */
  status?:  | "CREATING" | "DELETING" | "FAILED" | "READY" | "RESTORING";
  /**
   * URL of the disk type resource describing which disk type to use to create
   * the disk. Provide this when creating the disk. For example:
   * projects/project /zones/zone/diskTypes/pd-ssd . See Persistent disk types.
   */
  type?: string;
  /**
   * [Output Only] Links to the users of the disk (attached instances) in form:
   * projects/project/zones/zone/instances/instance
   */
  users?: string[];
  /**
   * [Output Only] URL of the zone where the disk resides. You must specify
   * this field as part of the HTTP request URL. It is not settable as a field
   * in the request body.
   */
  zone?: string;
}

function serializeDisk(data: any): Disk {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
    labelFingerprint: data["labelFingerprint"] !== undefined ? encodeBase64(data["labelFingerprint"]) : undefined,
    licenseCodes: data["licenseCodes"] !== undefined ? data["licenseCodes"].map((item: any) => (String(item))) : undefined,
    physicalBlockSizeBytes: data["physicalBlockSizeBytes"] !== undefined ? String(data["physicalBlockSizeBytes"]) : undefined,
    provisionedIops: data["provisionedIops"] !== undefined ? String(data["provisionedIops"]) : undefined,
    sizeGb: data["sizeGb"] !== undefined ? String(data["sizeGb"]) : undefined,
  };
}

function deserializeDisk(data: any): Disk {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
    labelFingerprint: data["labelFingerprint"] !== undefined ? decodeBase64(data["labelFingerprint"] as string) : undefined,
    licenseCodes: data["licenseCodes"] !== undefined ? data["licenseCodes"].map((item: any) => (BigInt(item))) : undefined,
    physicalBlockSizeBytes: data["physicalBlockSizeBytes"] !== undefined ? BigInt(data["physicalBlockSizeBytes"]) : undefined,
    provisionedIops: data["provisionedIops"] !== undefined ? BigInt(data["provisionedIops"]) : undefined,
    sizeGb: data["sizeGb"] !== undefined ? BigInt(data["sizeGb"]) : undefined,
  };
}

export interface DiskAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of DisksScopedList resources.
   */
  items?: {
    [key: string]: DisksScopedList
  };
  /**
   * [Output Only] Type of resource. Always compute#diskAggregatedList for
   * aggregated lists of persistent disks.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeDiskAggregatedList(data: any): DiskAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeDisksScopedList(v)]))) : undefined,
  };
}

function deserializeDiskAggregatedList(data: any): DiskAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeDisksScopedList(v)]))) : undefined,
  };
}

/**
 * A specification of the desired way to instantiate a disk in the instance
 * template when its created from a source instance.
 */
export interface DiskInstantiationConfig {
  /**
   * Specifies whether the disk will be auto-deleted when the instance is
   * deleted (but not when the disk is detached from the instance).
   */
  autoDelete?: boolean;
  /**
   * The custom source image to be used to restore this disk when instantiating
   * this instance template.
   */
  customImage?: string;
  /**
   * Specifies the device name of the disk to which the configurations apply
   * to.
   */
  deviceName?: string;
  /**
   * Specifies whether to include the disk and what image to use. Possible
   * values are: - source-image: to use the same image that was used to create
   * the source instance's corresponding disk. Applicable to the boot disk and
   * additional read-write disks. - source-image-family: to use the same image
   * family that was used to create the source instance's corresponding disk.
   * Applicable to the boot disk and additional read-write disks. -
   * custom-image: to use a user-provided image url for disk creation.
   * Applicable to the boot disk and additional read-write disks. -
   * attach-read-only: to attach a read-only disk. Applicable to read-only
   * disks. - do-not-include: to exclude a disk from the template. Applicable to
   * additional read-write disks, local SSDs, and read-only disks.
   */
  instantiateFrom?:  | "ATTACH_READ_ONLY" | "BLANK" | "CUSTOM_IMAGE" | "DEFAULT" | "DO_NOT_INCLUDE" | "SOURCE_IMAGE" | "SOURCE_IMAGE_FAMILY";
}

/**
 * A list of Disk resources.
 */
export interface DiskList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of Disk resources.
   */
  items?: Disk[];
  /**
   * [Output Only] Type of resource. Always compute#diskList for lists of
   * disks.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeDiskList(data: any): DiskList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeDisk(item))) : undefined,
  };
}

function deserializeDiskList(data: any): DiskList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeDisk(item))) : undefined,
  };
}

export interface DiskMoveRequest {
  /**
   * The URL of the destination zone to move the disk. This can be a full or
   * partial URL. For example, the following are all valid URLs to a zone: -
   * https://www.googleapis.com/compute/v1/projects/project/zones/zone -
   * projects/project/zones/zone - zones/zone
   */
  destinationZone?: string;
  /**
   * The URL of the target disk to move. This can be a full or partial URL. For
   * example, the following are all valid URLs to a disk: -
   * https://www.googleapis.com/compute/v1/projects/project/zones/zone
   * /disks/disk - projects/project/zones/zone/disks/disk -
   * zones/zone/disks/disk
   */
  targetDisk?: string;
}

/**
 * Additional disk params.
 */
export interface DiskParams {
  /**
   * Resource manager tags to be bound to the disk. Tag keys and values have
   * the same definition as resource manager tags. Keys must be in the format
   * `tagKeys/{tag_key_id}`, and values are in the format `tagValues/456`. The
   * field is ignored (both PUT & PATCH) when empty.
   */
  resourceManagerTags?: {
    [key: string]: string
  };
}

/**
 * Additional options for Compute#disksAddResourcePolicies.
 */
export interface DisksAddResourcePoliciesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface DisksAddResourcePoliciesRequest {
  /**
   * Full or relative path to the resource policy to be added to this disk. You
   * can only specify one resource policy.
   */
  resourcePolicies?: string[];
}

/**
 * Additional options for Compute#disksAggregatedList.
 */
export interface DisksAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#disksCreateSnapshot.
 */
export interface DisksCreateSnapshotOptions {
  /**
   * [Input Only] Whether to attempt an application consistent snapshot by
   * informing the OS to prepare for the snapshot process.
   */
  guestFlush?: boolean;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#disksDelete.
 */
export interface DisksDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#disksGetIamPolicy.
 */
export interface DisksGetIamPolicyOptions {
  /**
   * Requested IAM Policy version.
   */
  optionsRequestedPolicyVersion?: number;
}

/**
 * Additional options for Compute#disksInsert.
 */
export interface DisksInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
  /**
   * Source image to restore onto a disk. This field is optional.
   */
  sourceImage?: string;
}

/**
 * Additional options for Compute#disksList.
 */
export interface DisksListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#disksRemoveResourcePolicies.
 */
export interface DisksRemoveResourcePoliciesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface DisksRemoveResourcePoliciesRequest {
  /**
   * Resource policies to be removed from this disk.
   */
  resourcePolicies?: string[];
}

/**
 * Additional options for Compute#disksResize.
 */
export interface DisksResizeOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface DisksResizeRequest {
  /**
   * The new size of the persistent disk, which is specified in GB.
   */
  sizeGb?: bigint;
}

function serializeDisksResizeRequest(data: any): DisksResizeRequest {
  return {
    ...data,
    sizeGb: data["sizeGb"] !== undefined ? String(data["sizeGb"]) : undefined,
  };
}

function deserializeDisksResizeRequest(data: any): DisksResizeRequest {
  return {
    ...data,
    sizeGb: data["sizeGb"] !== undefined ? BigInt(data["sizeGb"]) : undefined,
  };
}

export interface DisksScopedList {
  /**
   * [Output Only] A list of disks contained in this scope.
   */
  disks?: Disk[];
  /**
   * [Output Only] Informational warning which replaces the list of disks when
   * the list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeDisksScopedList(data: any): DisksScopedList {
  return {
    ...data,
    disks: data["disks"] !== undefined ? data["disks"].map((item: any) => (serializeDisk(item))) : undefined,
  };
}

function deserializeDisksScopedList(data: any): DisksScopedList {
  return {
    ...data,
    disks: data["disks"] !== undefined ? data["disks"].map((item: any) => (deserializeDisk(item))) : undefined,
  };
}

/**
 * Additional options for Compute#disksSetLabels.
 */
export interface DisksSetLabelsOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#disksUpdate.
 */
export interface DisksUpdateOptions {
  paths?: string;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
  /**
   * update_mask indicates fields to be updated as part of this request.
   */
  updateMask?: string /* FieldMask */;
}

function serializeDisksUpdateOptions(data: any): DisksUpdateOptions {
  return {
    ...data,
    updateMask: data["updateMask"] !== undefined ? data["updateMask"] : undefined,
  };
}

function deserializeDisksUpdateOptions(data: any): DisksUpdateOptions {
  return {
    ...data,
    updateMask: data["updateMask"] !== undefined ? data["updateMask"] : undefined,
  };
}

/**
 * Represents a Disk Type resource. Google Compute Engine has two Disk Type
 * resources: * [Regional](/compute/docs/reference/rest/v1/regionDiskTypes) *
 * [Zonal](/compute/docs/reference/rest/v1/diskTypes) You can choose from a
 * variety of disk types based on your needs. For more information, read Storage
 * options. The diskTypes resource represents disk types for a zonal persistent
 * disk. For more information, read Zonal persistent disks. The regionDiskTypes
 * resource represents disk types for a regional persistent disk. For more
 * information, read Regional persistent disks.
 */
export interface DiskType {
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * [Output Only] Server-defined default disk size in GB.
   */
  defaultDiskSizeGb?: bigint;
  /**
   * [Output Only] The deprecation status associated with this disk type.
   */
  deprecated?: DeprecationStatus;
  /**
   * [Output Only] An optional description of this resource.
   */
  description?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of the resource. Always compute#diskType for disk
   * types.
   */
  kind?: string;
  /**
   * [Output Only] Name of the resource.
   */
  name?: string;
  /**
   * [Output Only] URL of the region where the disk type resides. Only
   * applicable for regional resources. You must specify this field as part of
   * the HTTP request URL. It is not settable as a field in the request body.
   */
  region?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * [Output Only] An optional textual description of the valid disk size, such
   * as "10GB-10TB".
   */
  validDiskSize?: string;
  /**
   * [Output Only] URL of the zone where the disk type resides. You must
   * specify this field as part of the HTTP request URL. It is not settable as a
   * field in the request body.
   */
  zone?: string;
}

function serializeDiskType(data: any): DiskType {
  return {
    ...data,
    defaultDiskSizeGb: data["defaultDiskSizeGb"] !== undefined ? String(data["defaultDiskSizeGb"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeDiskType(data: any): DiskType {
  return {
    ...data,
    defaultDiskSizeGb: data["defaultDiskSizeGb"] !== undefined ? BigInt(data["defaultDiskSizeGb"]) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface DiskTypeAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of DiskTypesScopedList resources.
   */
  items?: {
    [key: string]: DiskTypesScopedList
  };
  /**
   * [Output Only] Type of resource. Always compute#diskTypeAggregatedList.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeDiskTypeAggregatedList(data: any): DiskTypeAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeDiskTypesScopedList(v)]))) : undefined,
  };
}

function deserializeDiskTypeAggregatedList(data: any): DiskTypeAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeDiskTypesScopedList(v)]))) : undefined,
  };
}

/**
 * Contains a list of disk types.
 */
export interface DiskTypeList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of DiskType resources.
   */
  items?: DiskType[];
  /**
   * [Output Only] Type of resource. Always compute#diskTypeList for disk
   * types.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeDiskTypeList(data: any): DiskTypeList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeDiskType(item))) : undefined,
  };
}

function deserializeDiskTypeList(data: any): DiskTypeList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeDiskType(item))) : undefined,
  };
}

/**
 * Additional options for Compute#diskTypesAggregatedList.
 */
export interface DiskTypesAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#diskTypesList.
 */
export interface DiskTypesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface DiskTypesScopedList {
  /**
   * [Output Only] A list of disk types contained in this scope.
   */
  diskTypes?: DiskType[];
  /**
   * [Output Only] Informational warning which replaces the list of disk types
   * when the list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeDiskTypesScopedList(data: any): DiskTypesScopedList {
  return {
    ...data,
    diskTypes: data["diskTypes"] !== undefined ? data["diskTypes"].map((item: any) => (serializeDiskType(item))) : undefined,
  };
}

function deserializeDiskTypesScopedList(data: any): DiskTypesScopedList {
  return {
    ...data,
    diskTypes: data["diskTypes"] !== undefined ? data["diskTypes"].map((item: any) => (deserializeDiskType(item))) : undefined,
  };
}

/**
 * A set of Display Device options
 */
export interface DisplayDevice {
  /**
   * Defines whether the instance has Display enabled.
   */
  enableDisplay?: boolean;
}

export interface DistributionPolicy {
  /**
   * The distribution shape to which the group converges either proactively or
   * on resize events (depending on the value set in
   * updatePolicy.instanceRedistributionType).
   */
  targetShape?:  | "ANY" | "BALANCED" | "EVEN";
  /**
   * Zones where the regional managed instance group will create and manage its
   * instances.
   */
  zones?: DistributionPolicyZoneConfiguration[];
}

export interface DistributionPolicyZoneConfiguration {
  /**
   * The URL of the zone. The zone must exist in the region where the managed
   * instance group is located.
   */
  zone?: string;
}

/**
 * A Duration represents a fixed-length span of time represented as a count of
 * seconds and fractions of seconds at nanosecond resolution. It is independent
 * of any calendar and concepts like "day" or "month". Range is approximately
 * 10,000 years.
 */
export interface Duration {
  /**
   * Span of time that's a fraction of a second at nanosecond resolution.
   * Durations less than one second are represented with a 0 `seconds` field and
   * a positive `nanos` field. Must be from 0 to 999,999,999 inclusive.
   */
  nanos?: number;
  /**
   * Span of time at a resolution of a second. Must be from 0 to
   * 315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min
   * * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
   */
  seconds?: bigint;
}

function serializeDuration(data: any): Duration {
  return {
    ...data,
    seconds: data["seconds"] !== undefined ? String(data["seconds"]) : undefined,
  };
}

function deserializeDuration(data: any): Duration {
  return {
    ...data,
    seconds: data["seconds"] !== undefined ? BigInt(data["seconds"]) : undefined,
  };
}

/**
 * Describes the cause of the error with structured details. Example of an
 * error when contacting the "pubsub.googleapis.com" API when it is not enabled:
 * { "reason": "API_DISABLED" "domain": "googleapis.com" "metadata": {
 * "resource": "projects/123", "service": "pubsub.googleapis.com" } } This
 * response indicates that the pubsub.googleapis.com API is not enabled. Example
 * of an error that is returned when attempting to create a Spanner instance in
 * a region that is out of stock: { "reason": "STOCKOUT" "domain":
 * "spanner.googleapis.com", "metadata": { "availableRegions":
 * "us-central1,us-east2" } }
 */
export interface ErrorInfo {
  /**
   * The logical grouping to which the "reason" belongs. The error domain is
   * typically the registered service name of the tool or product that generates
   * the error. Example: "pubsub.googleapis.com". If the error is generated by
   * some common infrastructure, the error domain must be a globally unique
   * value that identifies the infrastructure. For Google API infrastructure,
   * the error domain is "googleapis.com".
   */
  domain?: string;
  /**
   * Additional structured details about this error. Keys should match
   * /[a-zA-Z0-9-_]/ and be limited to 64 characters in length. When identifying
   * the current value of an exceeded limit, the units should be contained in
   * the key, not the value. For example, rather than {"instanceLimit":
   * "100/request"}, should be returned as, {"instanceLimitPerRequest": "100"},
   * if the client exceeds the number of instances that can be created in a
   * single (batch) request.
   */
  metadatas?: {
    [key: string]: string
  };
  /**
   * The reason of the error. This is a constant value that identifies the
   * proximate cause of the error. Error reasons are unique within a particular
   * domain of errors. This should be at most 63 characters and match a regular
   * expression of `A-Z+[A-Z0-9]`, which represents UPPER_SNAKE_CASE.
   */
  reason?: string;
}

export interface ExchangedPeeringRoute {
  /**
   * The destination range of the route.
   */
  destRange?: string;
  /**
   * True if the peering route has been imported from a peer. The actual import
   * happens if the field networkPeering.importCustomRoutes is true for this
   * network, and networkPeering.exportCustomRoutes is true for the peer
   * network, and the import does not result in a route conflict.
   */
  imported?: boolean;
  /**
   * The region of peering route next hop, only applies to dynamic routes.
   */
  nextHopRegion?: string;
  /**
   * The priority of the peering route.
   */
  priority?: number;
  /**
   * The type of the peering route.
   */
  type?:  | "DYNAMIC_PEERING_ROUTE" | "STATIC_PEERING_ROUTE" | "SUBNET_PEERING_ROUTE";
}

export interface ExchangedPeeringRoutesList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of ExchangedPeeringRoute resources.
   */
  items?: ExchangedPeeringRoute[];
  /**
   * [Output Only] Type of resource. Always compute#exchangedPeeringRoutesList
   * for exchanged peering routes lists.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

/**
 * Represents a textual expression in the Common Expression Language (CEL)
 * syntax. CEL is a C-like expression language. The syntax and semantics of CEL
 * are documented at https://github.com/google/cel-spec. Example (Comparison):
 * title: "Summary size limit" description: "Determines if a summary is less
 * than 100 chars" expression: "document.summary.size() < 100" Example
 * (Equality): title: "Requestor is owner" description: "Determines if requestor
 * is the document owner" expression: "document.owner ==
 * request.auth.claims.email" Example (Logic): title: "Public documents"
 * description: "Determine whether the document should be publicly visible"
 * expression: "document.type != 'private' && document.type != 'internal'"
 * Example (Data Manipulation): title: "Notification string" description:
 * "Create a notification string with a timestamp." expression: "'New message
 * received at ' + string(document.create_time)" The exact variables and
 * functions that may be referenced within an expression are determined by the
 * service that evaluates it. See the service documentation for additional
 * information.
 */
export interface Expr {
  /**
   * Optional. Description of the expression. This is a longer text which
   * describes the expression, e.g. when hovered over it in a UI.
   */
  description?: string;
  /**
   * Textual representation of an expression in Common Expression Language
   * syntax.
   */
  expression?: string;
  /**
   * Optional. String indicating the location of the expression for error
   * reporting, e.g. a file name and a position in the file.
   */
  location?: string;
  /**
   * Optional. Title for the expression, i.e. a short string describing its
   * purpose. This can be used e.g. in UIs which allow to enter the expression.
   */
  title?: string;
}

/**
 * Represents an external VPN gateway. External VPN gateway is the on-premises
 * VPN gateway(s) or another cloud provider's VPN gateway that connects to your
 * Google Cloud VPN gateway. To create a highly available VPN from Google Cloud
 * Platform to your VPN gateway or another cloud provider's VPN gateway, you
 * must create a external VPN gateway resource with information about the other
 * gateway. For more information about using external VPN gateways, see Creating
 * an HA VPN gateway and tunnel pair to a peer VPN.
 */
export interface ExternalVpnGateway {
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * A list of interfaces for this external VPN gateway. If your peer-side
   * gateway is an on-premises gateway and non-AWS cloud providers' gateway, at
   * most two interfaces can be provided for an external VPN gateway. If your
   * peer side is an AWS virtual private gateway, four interfaces should be
   * provided for an external VPN gateway.
   */
  interfaces?: ExternalVpnGatewayInterface[];
  /**
   * [Output Only] Type of the resource. Always compute#externalVpnGateway for
   * externalVpnGateways.
   */
  kind?: string;
  /**
   * A fingerprint for the labels being applied to this ExternalVpnGateway,
   * which is essentially a hash of the labels set used for optimistic locking.
   * The fingerprint is initially generated by Compute Engine and changes after
   * every request to modify or update labels. You must always provide an
   * up-to-date fingerprint hash in order to update or change labels, otherwise
   * the request will fail with error 412 conditionNotMet. To see the latest
   * fingerprint, make a get() request to retrieve an ExternalVpnGateway.
   */
  labelFingerprint?: Uint8Array;
  /**
   * Labels for this resource. These can only be added or modified by the
   * setLabels method. Each label key/value pair must comply with RFC1035. Label
   * values may be empty.
   */
  labels?: {
    [key: string]: string
  };
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * Indicates the user-supplied redundancy type of this external VPN gateway.
   */
  redundancyType?:  | "FOUR_IPS_REDUNDANCY" | "SINGLE_IP_INTERNALLY_REDUNDANT" | "TWO_IPS_REDUNDANCY";
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
}

function serializeExternalVpnGateway(data: any): ExternalVpnGateway {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
    labelFingerprint: data["labelFingerprint"] !== undefined ? encodeBase64(data["labelFingerprint"]) : undefined,
  };
}

function deserializeExternalVpnGateway(data: any): ExternalVpnGateway {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
    labelFingerprint: data["labelFingerprint"] !== undefined ? decodeBase64(data["labelFingerprint"] as string) : undefined,
  };
}

/**
 * The interface for the external VPN gateway.
 */
export interface ExternalVpnGatewayInterface {
  /**
   * The numeric ID of this interface. The allowed input values for this id for
   * different redundancy types of external VPN gateway: -
   * SINGLE_IP_INTERNALLY_REDUNDANT - 0 - TWO_IPS_REDUNDANCY - 0, 1 -
   * FOUR_IPS_REDUNDANCY - 0, 1, 2, 3
   */
  id?: number;
  /**
   * IP address of the interface in the external VPN gateway. Only IPv4 is
   * supported. This IP address can be either from your on-premise gateway or
   * another Cloud provider's VPN gateway, it cannot be an IP address from
   * Google Compute Engine.
   */
  ipAddress?: string;
}

/**
 * Response to the list request, and contains a list of externalVpnGateways.
 */
export interface ExternalVpnGatewayList {
  etag?: string;
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of ExternalVpnGateway resources.
   */
  items?: ExternalVpnGateway[];
  /**
   * [Output Only] Type of resource. Always compute#externalVpnGatewayList for
   * lists of externalVpnGateways.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeExternalVpnGatewayList(data: any): ExternalVpnGatewayList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeExternalVpnGateway(item))) : undefined,
  };
}

function deserializeExternalVpnGatewayList(data: any): ExternalVpnGatewayList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeExternalVpnGateway(item))) : undefined,
  };
}

/**
 * Additional options for Compute#externalVpnGatewaysDelete.
 */
export interface ExternalVpnGatewaysDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#externalVpnGatewaysInsert.
 */
export interface ExternalVpnGatewaysInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#externalVpnGatewaysList.
 */
export interface ExternalVpnGatewaysListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface FileContentBuffer {
  /**
   * The raw content in the secure keys file.
   */
  content?: Uint8Array;
  /**
   * The file type of source file.
   */
  fileType?:  | "BIN" | "UNDEFINED" | "X509";
}

function serializeFileContentBuffer(data: any): FileContentBuffer {
  return {
    ...data,
    content: data["content"] !== undefined ? encodeBase64(data["content"]) : undefined,
  };
}

function deserializeFileContentBuffer(data: any): FileContentBuffer {
  return {
    ...data,
    content: data["content"] !== undefined ? decodeBase64(data["content"] as string) : undefined,
  };
}

/**
 * Represents a Firewall Rule resource. Firewall rules allow or deny ingress
 * traffic to, and egress traffic from your instances. For more information,
 * read Firewall rules.
 */
export interface Firewall {
  /**
   * The list of ALLOW rules specified by this firewall. Each rule specifies a
   * protocol and port-range tuple that describes a permitted connection.
   */
  allowed?: {
    IPProtocol?: string;
    ports?: string[];
  }[];
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * The list of DENY rules specified by this firewall. Each rule specifies a
   * protocol and port-range tuple that describes a denied connection.
   */
  denied?: {
    IPProtocol?: string;
    ports?: string[];
  }[];
  /**
   * An optional description of this resource. Provide this field when you
   * create the resource.
   */
  description?: string;
  /**
   * If destination ranges are specified, the firewall rule applies only to
   * traffic that has destination IP address in these ranges. These ranges must
   * be expressed in CIDR format. Both IPv4 and IPv6 are supported.
   */
  destinationRanges?: string[];
  /**
   * Direction of traffic to which this firewall applies, either `INGRESS` or
   * `EGRESS`. The default is `INGRESS`. For `EGRESS` traffic, you cannot
   * specify the sourceTags fields.
   */
  direction?:  | "EGRESS" | "INGRESS";
  /**
   * Denotes whether the firewall rule is disabled. When set to true, the
   * firewall rule is not enforced and the network behaves as if it did not
   * exist. If this is unspecified, the firewall rule will be enabled.
   */
  disabled?: boolean;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of the resource. Always compute#firewall for firewall
   * rules.
   */
  kind?: string;
  /**
   * This field denotes the logging options for a particular firewall rule. If
   * logging is enabled, logs will be exported to Cloud Logging.
   */
  logConfig?: FirewallLogConfig;
  /**
   * Name of the resource; provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a
   * lowercase letter, and all following characters (except for the last
   * character) must be a dash, lowercase letter, or digit. The last character
   * must be a lowercase letter or digit.
   */
  name?: string;
  /**
   * URL of the network resource for this firewall rule. If not specified when
   * creating a firewall rule, the default network is used:
   * global/networks/default If you choose to specify this field, you can
   * specify the network as a full or partial URL. For example, the following
   * are all valid URLs: -
   * https://www.googleapis.com/compute/v1/projects/myproject/global/networks/my-network
   * - projects/myproject/global/networks/my-network - global/networks/default
   */
  network?: string;
  /**
   * Priority for this rule. This is an integer between `0` and `65535`, both
   * inclusive. The default value is `1000`. Relative priorities determine which
   * rule takes effect if multiple rules apply. Lower values indicate higher
   * priority. For example, a rule with priority `0` has higher precedence than
   * a rule with priority `1`. DENY rules take precedence over ALLOW rules if
   * they have equal priority. Note that VPC networks have implied rules with a
   * priority of `65535`. To avoid conflicts with the implied rules, use a
   * priority number less than `65535`.
   */
  priority?: number;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * If source ranges are specified, the firewall rule applies only to traffic
   * that has a source IP address in these ranges. These ranges must be
   * expressed in CIDR format. One or both of sourceRanges and sourceTags may be
   * set. If both fields are set, the rule applies to traffic that has a source
   * IP address within sourceRanges OR a source IP from a resource with a
   * matching tag listed in the sourceTags field. The connection does not need
   * to match both fields for the rule to apply. Both IPv4 and IPv6 are
   * supported.
   */
  sourceRanges?: string[];
  /**
   * If source service accounts are specified, the firewall rules apply only to
   * traffic originating from an instance with a service account in this list.
   * Source service accounts cannot be used to control traffic to an instance's
   * external IP address because service accounts are associated with an
   * instance, not an IP address. sourceRanges can be set at the same time as
   * sourceServiceAccounts. If both are set, the firewall applies to traffic
   * that has a source IP address within the sourceRanges OR a source IP that
   * belongs to an instance with service account listed in sourceServiceAccount.
   * The connection does not need to match both fields for the firewall to
   * apply. sourceServiceAccounts cannot be used at the same time as sourceTags
   * or targetTags.
   */
  sourceServiceAccounts?: string[];
  /**
   * If source tags are specified, the firewall rule applies only to traffic
   * with source IPs that match the primary network interfaces of VM instances
   * that have the tag and are in the same VPC network. Source tags cannot be
   * used to control traffic to an instance's external IP address, it only
   * applies to traffic between instances in the same virtual network. Because
   * tags are associated with instances, not IP addresses. One or both of
   * sourceRanges and sourceTags may be set. If both fields are set, the
   * firewall applies to traffic that has a source IP address within
   * sourceRanges OR a source IP from a resource with a matching tag listed in
   * the sourceTags field. The connection does not need to match both fields for
   * the firewall to apply.
   */
  sourceTags?: string[];
  /**
   * A list of service accounts indicating sets of instances located in the
   * network that may make network connections as specified in allowed[].
   * targetServiceAccounts cannot be used at the same time as targetTags or
   * sourceTags. If neither targetServiceAccounts nor targetTags are specified,
   * the firewall rule applies to all instances on the specified network.
   */
  targetServiceAccounts?: string[];
  /**
   * A list of tags that controls which instances the firewall rule applies to.
   * If targetTags are specified, then the firewall rule applies only to
   * instances in the VPC network that have one of those tags. If no targetTags
   * are specified, the firewall rule applies to all instances on the specified
   * network.
   */
  targetTags?: string[];
}

function serializeFirewall(data: any): Firewall {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeFirewall(data: any): Firewall {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

/**
 * Contains a list of firewalls.
 */
export interface FirewallList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of Firewall resources.
   */
  items?: Firewall[];
  /**
   * [Output Only] Type of resource. Always compute#firewallList for lists of
   * firewalls.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeFirewallList(data: any): FirewallList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeFirewall(item))) : undefined,
  };
}

function deserializeFirewallList(data: any): FirewallList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeFirewall(item))) : undefined,
  };
}

/**
 * The available logging options for a firewall rule.
 */
export interface FirewallLogConfig {
  /**
   * This field denotes whether to enable logging for a particular firewall
   * rule.
   */
  enable?: boolean;
  /**
   * This field can only be specified for a particular firewall rule if logging
   * is enabled for that rule. This field denotes whether to include or exclude
   * metadata for firewall logs.
   */
  metadata?:  | "EXCLUDE_ALL_METADATA" | "INCLUDE_ALL_METADATA";
}

/**
 * Additional options for Compute#firewallPoliciesAddAssociation.
 */
export interface FirewallPoliciesAddAssociationOptions {
  /**
   * Indicates whether or not to replace it if an association of the attachment
   * already exists. This is false by default, in which case an error will be
   * returned if an association already exists.
   */
  replaceExistingAssociation?: boolean;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#firewallPoliciesAddRule.
 */
export interface FirewallPoliciesAddRuleOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#firewallPoliciesCloneRules.
 */
export interface FirewallPoliciesCloneRulesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
  /**
   * The firewall policy from which to copy rules.
   */
  sourceFirewallPolicy?: string;
}

/**
 * Additional options for Compute#firewallPoliciesDelete.
 */
export interface FirewallPoliciesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#firewallPoliciesGetAssociation.
 */
export interface FirewallPoliciesGetAssociationOptions {
  /**
   * The name of the association to get from the firewall policy.
   */
  name?: string;
}

/**
 * Additional options for Compute#firewallPoliciesGetIamPolicy.
 */
export interface FirewallPoliciesGetIamPolicyOptions {
  /**
   * Requested IAM Policy version.
   */
  optionsRequestedPolicyVersion?: number;
}

/**
 * Additional options for Compute#firewallPoliciesGetRule.
 */
export interface FirewallPoliciesGetRuleOptions {
  /**
   * The priority of the rule to get from the firewall policy.
   */
  priority?: number;
}

/**
 * Additional options for Compute#firewallPoliciesInsert.
 */
export interface FirewallPoliciesInsertOptions {
  /**
   * Parent ID for this request. The ID can be either be "folders/[FOLDER_ID]"
   * if the parent is a folder or "organizations/[ORGANIZATION_ID]" if the
   * parent is an organization.
   */
  parentId?: string;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#firewallPoliciesListAssociations.
 */
export interface FirewallPoliciesListAssociationsOptions {
  /**
   * The target resource to list associations. It is an organization, or a
   * folder.
   */
  targetResource?: string;
}

export interface FirewallPoliciesListAssociationsResponse {
  /**
   * A list of associations.
   */
  associations?: FirewallPolicyAssociation[];
  /**
   * [Output Only] Type of firewallPolicy associations. Always
   * compute#FirewallPoliciesListAssociations for lists of firewallPolicy
   * associations.
   */
  kind?: string;
}

/**
 * Additional options for Compute#firewallPoliciesList.
 */
export interface FirewallPoliciesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Parent ID for this request. The ID can be either be "folders/[FOLDER_ID]"
   * if the parent is a folder or "organizations/[ORGANIZATION_ID]" if the
   * parent is an organization.
   */
  parentId?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#firewallPoliciesMove.
 */
export interface FirewallPoliciesMoveOptions {
  /**
   * The new parent of the firewall policy. The ID can be either be
   * "folders/[FOLDER_ID]" if the parent is a folder or
   * "organizations/[ORGANIZATION_ID]" if the parent is an organization.
   */
  parentId?: string;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#firewallPoliciesPatch.
 */
export interface FirewallPoliciesPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#firewallPoliciesPatchRule.
 */
export interface FirewallPoliciesPatchRuleOptions {
  /**
   * The priority of the rule to patch.
   */
  priority?: number;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#firewallPoliciesRemoveAssociation.
 */
export interface FirewallPoliciesRemoveAssociationOptions {
  /**
   * Name for the attachment that will be removed.
   */
  name?: string;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#firewallPoliciesRemoveRule.
 */
export interface FirewallPoliciesRemoveRuleOptions {
  /**
   * The priority of the rule to remove from the firewall policy.
   */
  priority?: number;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Represents a Firewall Policy resource.
 */
export interface FirewallPolicy {
  /**
   * A list of associations that belong to this firewall policy.
   */
  associations?: FirewallPolicyAssociation[];
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * Deprecated, please use short name instead. User-provided name of the
   * Organization firewall policy. The name should be unique in the organization
   * in which the firewall policy is created. This field is not applicable to
   * network firewall policies. This name must be set on creation and cannot be
   * changed. The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  displayName?: string;
  /**
   * Specifies a fingerprint for this resource, which is essentially a hash of
   * the metadata's contents and used for optimistic locking. The fingerprint is
   * initially generated by Compute Engine and changes after every request to
   * modify or update metadata. You must always provide an up-to-date
   * fingerprint hash in order to update or change metadata, otherwise the
   * request will fail with error 412 conditionNotMet. To see the latest
   * fingerprint, make get() request to the firewall policy.
   */
  fingerprint?: Uint8Array;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output only] Type of the resource. Always compute#firewallPolicyfor
   * firewall policies
   */
  kind?: string;
  /**
   * Name of the resource. For Organization Firewall Policies it's a [Output
   * Only] numeric ID allocated by Google Cloud which uniquely identifies the
   * Organization Firewall Policy.
   */
  name?: string;
  /**
   * [Output Only] The parent of the firewall policy. This field is not
   * applicable to network firewall policies.
   */
  parent?: string;
  /**
   * [Output Only] URL of the region where the regional firewall policy
   * resides. This field is not applicable to global firewall policies. You must
   * specify this field as part of the HTTP request URL. It is not settable as a
   * field in the request body.
   */
  region?: string;
  /**
   * A list of rules that belong to this policy. There must always be a default
   * rule (rule with priority 2147483647 and match "*"). If no rules are
   * provided when creating a firewall policy, a default rule with action
   * "allow" will be added.
   */
  rules?: FirewallPolicyRule[];
  /**
   * [Output Only] Total count of all firewall policy rule tuples. A firewall
   * policy can not exceed a set number of tuples.
   */
  ruleTupleCount?: number;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Server-defined URL for this resource with the resource id.
   */
  selfLinkWithId?: string;
  /**
   * User-provided name of the Organization firewall policy. The name should be
   * unique in the organization in which the firewall policy is created. This
   * field is not applicable to network firewall policies. This name must be set
   * on creation and cannot be changed. The name must be 1-63 characters long,
   * and comply with RFC1035. Specifically, the name must be 1-63 characters
   * long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which
   * means the first character must be a lowercase letter, and all following
   * characters must be a dash, lowercase letter, or digit, except the last
   * character, which cannot be a dash.
   */
  shortName?: string;
}

function serializeFirewallPolicy(data: any): FirewallPolicy {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeFirewallPolicy(data: any): FirewallPolicy {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface FirewallPolicyAssociation {
  /**
   * The target that the firewall policy is attached to.
   */
  attachmentTarget?: string;
  /**
   * [Output Only] Deprecated, please use short name instead. The display name
   * of the firewall policy of the association.
   */
  displayName?: string;
  /**
   * [Output Only] The firewall policy ID of the association.
   */
  firewallPolicyId?: string;
  /**
   * The name for an association.
   */
  name?: string;
  /**
   * [Output Only] The short name of the firewall policy of the association.
   */
  shortName?: string;
}

export interface FirewallPolicyList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of FirewallPolicy resources.
   */
  items?: FirewallPolicy[];
  /**
   * [Output Only] Type of resource. Always compute#firewallPolicyList for
   * listsof FirewallPolicies
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeFirewallPolicyList(data: any): FirewallPolicyList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeFirewallPolicy(item))) : undefined,
  };
}

function deserializeFirewallPolicyList(data: any): FirewallPolicyList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeFirewallPolicy(item))) : undefined,
  };
}

/**
 * Represents a rule that describes one or more match conditions along with the
 * action to be taken when traffic matches this condition (allow or deny).
 */
export interface FirewallPolicyRule {
  /**
   * The Action to perform when the client connection triggers the rule. Valid
   * actions are "allow", "deny" and "goto_next".
   */
  action?: string;
  /**
   * An optional description for this resource.
   */
  description?: string;
  /**
   * The direction in which this rule applies.
   */
  direction?:  | "EGRESS" | "INGRESS";
  /**
   * Denotes whether the firewall policy rule is disabled. When set to true,
   * the firewall policy rule is not enforced and traffic behaves as if it did
   * not exist. If this is unspecified, the firewall policy rule will be
   * enabled.
   */
  disabled?: boolean;
  /**
   * Denotes whether to enable logging for a particular rule. If logging is
   * enabled, logs will be exported to the configured export destination in
   * Stackdriver. Logs may be exported to BigQuery or Pub/Sub. Note: you cannot
   * enable logging on "goto_next" rules.
   */
  enableLogging?: boolean;
  /**
   * [Output only] Type of the resource. Always compute#firewallPolicyRule for
   * firewall policy rules
   */
  kind?: string;
  /**
   * A match condition that incoming traffic is evaluated against. If it
   * evaluates to true, the corresponding 'action' is enforced.
   */
  match?: FirewallPolicyRuleMatcher;
  /**
   * An integer indicating the priority of a rule in the list. The priority
   * must be a positive value between 0 and 2147483647. Rules are evaluated from
   * highest to lowest priority where 0 is the highest priority and 2147483647
   * is the lowest prority.
   */
  priority?: number;
  /**
   * An optional name for the rule. This field is not a unique identifier and
   * can be updated.
   */
  ruleName?: string;
  /**
   * [Output Only] Calculation of the complexity of a single firewall policy
   * rule.
   */
  ruleTupleCount?: number;
  /**
   * A list of network resource URLs to which this rule applies. This field
   * allows you to control which network's VMs get this rule. If this field is
   * left blank, all VMs within the organization will receive the rule.
   */
  targetResources?: string[];
  /**
   * A list of secure tags that controls which instances the firewall rule
   * applies to. If targetSecureTag are specified, then the firewall rule
   * applies only to instances in the VPC network that have one of those
   * EFFECTIVE secure tags, if all the target_secure_tag are in INEFFECTIVE
   * state, then this rule will be ignored. targetSecureTag may not be set at
   * the same time as targetServiceAccounts. If neither targetServiceAccounts
   * nor targetSecureTag are specified, the firewall rule applies to all
   * instances on the specified network. Maximum number of target label tags
   * allowed is 256.
   */
  targetSecureTags?: FirewallPolicyRuleSecureTag[];
  /**
   * A list of service accounts indicating the sets of instances that are
   * applied with this rule.
   */
  targetServiceAccounts?: string[];
}

/**
 * Represents a match condition that incoming traffic is evaluated against.
 * Exactly one field must be specified.
 */
export interface FirewallPolicyRuleMatcher {
  /**
   * CIDR IP address range. Maximum number of destination CIDR IP ranges
   * allowed is 5000.
   */
  destIpRanges?: string[];
  /**
   * Pairs of IP protocols and ports that the rule should match.
   */
  layer4Configs?: FirewallPolicyRuleMatcherLayer4Config[];
  /**
   * CIDR IP address range. Maximum number of source CIDR IP ranges allowed is
   * 5000.
   */
  srcIpRanges?: string[];
  /**
   * List of secure tag values, which should be matched at the source of the
   * traffic. For INGRESS rule, if all the srcSecureTag are INEFFECTIVE, and
   * there is no srcIpRange, this rule will be ignored. Maximum number of source
   * tag values allowed is 256.
   */
  srcSecureTags?: FirewallPolicyRuleSecureTag[];
}

export interface FirewallPolicyRuleMatcherLayer4Config {
  /**
   * The IP protocol to which this rule applies. The protocol type is required
   * when creating a firewall rule. This value can either be one of the
   * following well known protocol strings (tcp, udp, icmp, esp, ah, ipip,
   * sctp), or the IP protocol number.
   */
  ipProtocol?: string;
  /**
   * An optional list of ports to which this rule applies. This field is only
   * applicable for UDP or TCP protocol. Each entry must be either an integer or
   * a range. If not specified, this rule applies to connections through any
   * port. Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
   */
  ports?: string[];
}

export interface FirewallPolicyRuleSecureTag {
  /**
   * Name of the secure tag, created with TagManager's TagValue API.
   */
  name?: string;
  /**
   * [Output Only] State of the secure tag, either `EFFECTIVE` or
   * `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted or its
   * network is deleted.
   */
  state?:  | "EFFECTIVE" | "INEFFECTIVE";
}

/**
 * Additional options for Compute#firewallsDelete.
 */
export interface FirewallsDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#firewallsInsert.
 */
export interface FirewallsInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#firewallsList.
 */
export interface FirewallsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#firewallsPatch.
 */
export interface FirewallsPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#firewallsUpdate.
 */
export interface FirewallsUpdateOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Encapsulates numeric value that can be either absolute or relative.
 */
export interface FixedOrPercent {
  /**
   * [Output Only] Absolute value of VM instances calculated based on the
   * specific mode. - If the value is fixed, then the calculated value is equal
   * to the fixed value. - If the value is a percent, then the calculated value
   * is percent/100 * targetSize. For example, the calculated value of a 80% of
   * a managed instance group with 150 instances would be (80/100 * 150) = 120
   * VM instances. If there is a remainder, the number is rounded.
   */
  calculated?: number;
  /**
   * Specifies a fixed number of VM instances. This must be a positive integer.
   */
  fixed?: number;
  /**
   * Specifies a percentage of instances between 0 to 100%, inclusive. For
   * example, specify 80 for 80%.
   */
  percent?: number;
}

/**
 * Represents a Forwarding Rule resource. Forwarding rule resources in Google
 * Cloud can be either regional or global in scope: *
 * [Global](https://cloud.google.com/compute/docs/reference/rest/v1/globalForwardingRules)
 * *
 * [Regional](https://cloud.google.com/compute/docs/reference/rest/v1/forwardingRules)
 * A forwarding rule and its corresponding IP address represent the frontend
 * configuration of a Google Cloud Platform load balancer. Forwarding rules can
 * also reference target instances and Cloud VPN Classic gateways
 * (targetVpnGateway). For more information, read Forwarding rule concepts and
 * Using protocol forwarding.
 */
export interface ForwardingRule {
  /**
   * This field is used along with the backend_service field for internal load
   * balancing or with the target field for internal TargetInstance. If the
   * field is set to TRUE, clients can access ILB from all regions. Otherwise
   * only allows access from clients in the same region as the internal load
   * balancer.
   */
  allowGlobalAccess?: boolean;
  /**
   * This field can only be used: - If IPProtocol is one of TCP, UDP, or SCTP.
   * - By internal TCP/UDP load balancers, backend service-based network load
   * balancers, and internal and external protocol forwarding. Set this field to
   * true to allow packets addressed to any port or packets lacking destination
   * port information (for example, UDP fragments after the first fragment) to
   * be forwarded to the backends configured with this forwarding rule. The
   * ports, port_range, and allPorts fields are mutually exclusive.
   */
  allPorts?: boolean;
  /**
   * Identifies the backend service to which the forwarding rule sends traffic.
   * Required for Internal TCP/UDP Load Balancing and Network Load Balancing;
   * must be omitted for all other load balancer types.
   */
  backendService?: string;
  /**
   * [Output Only] The URL for the corresponding base Forwarding Rule. By base
   * Forwarding Rule, we mean the Forwarding Rule that has the same IP address,
   * protocol, and port settings with the current Forwarding Rule, but without
   * sourceIPRanges specified. Always empty if the current Forwarding Rule does
   * not have sourceIPRanges specified.
   */
  baseForwardingRule?: string;
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * Fingerprint of this resource. A hash of the contents stored in this
   * object. This field is used in optimistic locking. This field will be
   * ignored when inserting a ForwardingRule. Include the fingerprint in patch
   * request to ensure that you do not overwrite changes that were applied from
   * another concurrent request. To see the latest fingerprint, make a get()
   * request to retrieve a ForwardingRule.
   */
  fingerprint?: Uint8Array;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * IP address for which this forwarding rule accepts traffic. When a client
   * sends traffic to this IP address, the forwarding rule directs the traffic
   * to the referenced target or backendService. While creating a forwarding
   * rule, specifying an IPAddress is required under the following
   * circumstances: - When the target is set to targetGrpcProxy and
   * validateForProxyless is set to true, the IPAddress should be set to
   * 0.0.0.0. - When the target is a Private Service Connect Google APIs bundle,
   * you must specify an IPAddress. Otherwise, you can optionally specify an IP
   * address that references an existing static (reserved) IP address resource.
   * When omitted, Google Cloud assigns an ephemeral IP address. Use one of the
   * following formats to specify an IP address while creating a forwarding
   * rule: * IP address number, as in `100.1.2.3` * IPv6 address range, as in
   * `2600:1234::/96` * Full resource URL, as in
   * https://www.googleapis.com/compute/v1/projects/
   * project_id/regions/region/addresses/address-name * Partial URL or by name,
   * as in: - projects/project_id/regions/region/addresses/address-name -
   * regions/region/addresses/address-name - global/addresses/address-name -
   * address-name The forwarding rule's target or backendService, and in most
   * cases, also the loadBalancingScheme, determine the type of IP address that
   * you can use. For detailed information, see [IP address
   * specifications](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
   * When reading an IPAddress, the API always returns the IP address number.
   */
  IPAddress?: string;
  /**
   * The IP protocol to which this rule applies. For protocol forwarding, valid
   * options are TCP, UDP, ESP, AH, SCTP, ICMP and L3_DEFAULT. The valid IP
   * protocols are different for different load balancing products as described
   * in [Load balancing
   * features](https://cloud.google.com/load-balancing/docs/features#protocols_from_the_load_balancer_to_the_backends).
   */
  IPProtocol?:  | "AH" | "ESP" | "ICMP" | "L3_DEFAULT" | "SCTP" | "TCP" | "UDP";
  /**
   * The IP Version that will be used by this forwarding rule. Valid options
   * are IPV4 or IPV6.
   */
  ipVersion?:  | "IPV4" | "IPV6" | "UNSPECIFIED_VERSION";
  /**
   * Indicates whether or not this load balancer can be used as a collector for
   * packet mirroring. To prevent mirroring loops, instances behind this load
   * balancer will not have their traffic mirrored even if a PacketMirroring
   * rule applies to them. This can only be set to true for load balancers that
   * have their loadBalancingScheme set to INTERNAL.
   */
  isMirroringCollector?: boolean;
  /**
   * [Output Only] Type of the resource. Always compute#forwardingRule for
   * Forwarding Rule resources.
   */
  kind?: string;
  /**
   * A fingerprint for the labels being applied to this resource, which is
   * essentially a hash of the labels set used for optimistic locking. The
   * fingerprint is initially generated by Compute Engine and changes after
   * every request to modify or update labels. You must always provide an
   * up-to-date fingerprint hash in order to update or change labels, otherwise
   * the request will fail with error 412 conditionNotMet. To see the latest
   * fingerprint, make a get() request to retrieve a ForwardingRule.
   */
  labelFingerprint?: Uint8Array;
  /**
   * Labels for this resource. These can only be added or modified by the
   * setLabels method. Each label key/value pair must comply with RFC1035. Label
   * values may be empty.
   */
  labels?: {
    [key: string]: string
  };
  /**
   * Specifies the forwarding rule type. For more information about forwarding
   * rules, refer to Forwarding rule concepts.
   */
  loadBalancingScheme?:  | "EXTERNAL" | "EXTERNAL_MANAGED" | "INTERNAL" | "INTERNAL_MANAGED" | "INTERNAL_SELF_MANAGED" | "INVALID";
  /**
   * Opaque filter criteria used by load balancer to restrict routing
   * configuration to a limited set of xDS compliant clients. In their xDS
   * requests to load balancer, xDS clients present node metadata. When there is
   * a match, the relevant configuration is made available to those proxies.
   * Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by
   * the ForwardingRule are not visible to those proxies. For each
   * metadataFilter in this list, if its filterMatchCriteria is set to
   * MATCH_ANY, at least one of the filterLabels must match the corresponding
   * label provided in the metadata. If its filterMatchCriteria is set to
   * MATCH_ALL, then all of its filterLabels must match with corresponding
   * labels provided in the metadata. If multiple metadataFilters are specified,
   * all of them need to be satisfied in order to be considered a match.
   * metadataFilters specified here will be applifed before those specified in
   * the UrlMap that this ForwardingRule references. metadataFilters only
   * applies to Loadbalancers that have their loadBalancingScheme set to
   * INTERNAL_SELF_MANAGED.
   */
  metadataFilters?: MetadataFilter[];
  /**
   * Name of the resource; provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash. For Private Service Connect forwarding rules that forward traffic to
   * Google APIs, the forwarding rule name must be a 1-20 characters string with
   * lowercase letters and numbers and must start with a letter.
   */
  name?: string;
  /**
   * This field is not used for external load balancing. For Internal TCP/UDP
   * Load Balancing, this field identifies the network that the load balanced IP
   * should belong to for this Forwarding Rule. If this field is not specified,
   * the default network will be used. For Private Service Connect forwarding
   * rules that forward traffic to Google APIs, a network must be provided.
   */
  network?: string;
  /**
   * This signifies the networking tier used for configuring this load balancer
   * and can only take the following values: PREMIUM, STANDARD. For regional
   * ForwardingRule, the valid values are PREMIUM and STANDARD. For
   * GlobalForwardingRule, the valid value is PREMIUM. If this field is not
   * specified, it is assumed to be PREMIUM. If IPAddress is specified, this
   * value must be equal to the networkTier of the Address.
   */
  networkTier?:  | "FIXED_STANDARD" | "PREMIUM" | "STANDARD" | "STANDARD_OVERRIDES_FIXED_STANDARD";
  /**
   * This is used in PSC consumer ForwardingRule to control whether it should
   * try to auto-generate a DNS zone or not. Non-PSC forwarding rules do not use
   * this field.
   */
  noAutomateDnsZone?: boolean;
  /**
   * This field can only be used: - If IPProtocol is one of TCP, UDP, or SCTP.
   * - By backend service-based network load balancers, target pool-based
   * network load balancers, internal proxy load balancers, external proxy load
   * balancers, Traffic Director, external protocol forwarding, and Classic VPN.
   * Some products have restrictions on what ports can be used. See port
   * specifications for details. Only packets addressed to ports in the
   * specified range will be forwarded to the backends configured with this
   * forwarding rule. The ports, port_range, and allPorts fields are mutually
   * exclusive. For external forwarding rules, two or more forwarding rules
   * cannot use the same [IPAddress, IPProtocol] pair, and cannot have
   * overlapping portRanges. For internal forwarding rules within the same VPC
   * network, two or more forwarding rules cannot use the same [IPAddress,
   * IPProtocol] pair, and cannot have overlapping portRanges. @pattern:
   * \\d+(?:-\\d+)?
   */
  portRange?: string;
  /**
   * This field can only be used: - If IPProtocol is one of TCP, UDP, or SCTP.
   * - By internal TCP/UDP load balancers, backend service-based network load
   * balancers, and internal protocol forwarding. You can specify a list of up
   * to five ports by number, separated by commas. The ports can be contiguous
   * or discontiguous. Only packets addressed to these ports will be forwarded
   * to the backends configured with this forwarding rule. For external
   * forwarding rules, two or more forwarding rules cannot use the same
   * [IPAddress, IPProtocol] pair, and cannot share any values defined in ports.
   * For internal forwarding rules within the same VPC network, two or more
   * forwarding rules cannot use the same [IPAddress, IPProtocol] pair, and
   * cannot share any values defined in ports. The ports, port_range, and
   * allPorts fields are mutually exclusive. @pattern: \\d+(?:-\\d+)?
   */
  ports?: string[];
  /**
   * [Output Only] The PSC connection id of the PSC Forwarding Rule.
   */
  pscConnectionId?: bigint;
  pscConnectionStatus?:  | "ACCEPTED" | "CLOSED" | "NEEDS_ATTENTION" | "PENDING" | "REJECTED" | "STATUS_UNSPECIFIED";
  /**
   * [Output Only] URL of the region where the regional forwarding rule
   * resides. This field is not applicable to global forwarding rules. You must
   * specify this field as part of the HTTP request URL. It is not settable as a
   * field in the request body.
   */
  region?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * Service Directory resources to register this forwarding rule with.
   * Currently, only supports a single Service Directory resource.
   */
  serviceDirectoryRegistrations?: ForwardingRuleServiceDirectoryRegistration[];
  /**
   * An optional prefix to the service name for this Forwarding Rule. If
   * specified, the prefix is the first label of the fully qualified service
   * name. The label must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the label must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash. This field is only used for internal load balancing.
   */
  serviceLabel?: string;
  /**
   * [Output Only] The internal fully qualified service name for this
   * Forwarding Rule. This field is only used for internal load balancing.
   */
  serviceName?: string;
  /**
   * If not empty, this Forwarding Rule will only forward the traffic when the
   * source IP address matches one of the IP addresses or CIDR ranges set here.
   * Note that a Forwarding Rule can only have up to 64 source IP ranges, and
   * this field can only be used with a regional Forwarding Rule whose scheme is
   * EXTERNAL. Each source_ip_range entry should be either an IP address (for
   * example, 1.2.3.4) or a CIDR range (for example, 1.2.3.0/24).
   */
  sourceIpRanges?: string[];
  /**
   * This field identifies the subnetwork that the load balanced IP should
   * belong to for this Forwarding Rule, used in internal load balancing and
   * network load balancing with IPv6. If the network specified is in auto
   * subnet mode, this field is optional. However, a subnetwork must be
   * specified if the network is in custom subnet mode or when creating external
   * forwarding rule with IPv6.
   */
  subnetwork?: string;
  /**
   * The URL of the target resource to receive the matched traffic. For
   * regional forwarding rules, this target must be in the same region as the
   * forwarding rule. For global forwarding rules, this target must be a global
   * load balancing resource. The forwarded traffic must be of a type
   * appropriate to the target object. - For load balancers, see the "Target"
   * column in [Port
   * specifications](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
   * - For Private Service Connect forwarding rules that forward traffic to
   * Google APIs, provide the name of a supported Google API bundle: - vpc-sc -
   * APIs that support VPC Service Controls. - all-apis - All supported Google
   * APIs. - For Private Service Connect forwarding rules that forward traffic
   * to managed services, the target must be a service attachment.
   */
  target?: string;
}

function serializeForwardingRule(data: any): ForwardingRule {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
    labelFingerprint: data["labelFingerprint"] !== undefined ? encodeBase64(data["labelFingerprint"]) : undefined,
    pscConnectionId: data["pscConnectionId"] !== undefined ? String(data["pscConnectionId"]) : undefined,
  };
}

function deserializeForwardingRule(data: any): ForwardingRule {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
    labelFingerprint: data["labelFingerprint"] !== undefined ? decodeBase64(data["labelFingerprint"] as string) : undefined,
    pscConnectionId: data["pscConnectionId"] !== undefined ? BigInt(data["pscConnectionId"]) : undefined,
  };
}

export interface ForwardingRuleAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of ForwardingRulesScopedList resources.
   */
  items?: {
    [key: string]: ForwardingRulesScopedList
  };
  /**
   * [Output Only] Type of resource. Always
   * compute#forwardingRuleAggregatedList for lists of forwarding rules.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeForwardingRuleAggregatedList(data: any): ForwardingRuleAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeForwardingRulesScopedList(v)]))) : undefined,
  };
}

function deserializeForwardingRuleAggregatedList(data: any): ForwardingRuleAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeForwardingRulesScopedList(v)]))) : undefined,
  };
}

/**
 * Contains a list of ForwardingRule resources.
 */
export interface ForwardingRuleList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of ForwardingRule resources.
   */
  items?: ForwardingRule[];
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeForwardingRuleList(data: any): ForwardingRuleList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeForwardingRule(item))) : undefined,
  };
}

function deserializeForwardingRuleList(data: any): ForwardingRuleList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeForwardingRule(item))) : undefined,
  };
}

export interface ForwardingRuleReference {
  forwardingRule?: string;
}

/**
 * Additional options for Compute#forwardingRulesAggregatedList.
 */
export interface ForwardingRulesAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#forwardingRulesDelete.
 */
export interface ForwardingRulesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Describes the auto-registration of the Forwarding Rule to Service Directory.
 * The region and project of the Service Directory resource generated from this
 * registration will be the same as this Forwarding Rule.
 */
export interface ForwardingRuleServiceDirectoryRegistration {
  /**
   * Service Directory namespace to register the forwarding rule under.
   */
  namespace?: string;
  /**
   * Service Directory service to register the forwarding rule under.
   */
  service?: string;
  /**
   * [Optional] Service Directory region to register this global forwarding
   * rule under. Default to "us-central1". Only used for PSC for Google APIs.
   * All PSC for Google APIs Forwarding Rules on the same network should use the
   * same Service Directory region.
   */
  serviceDirectoryRegion?: string;
}

/**
 * Additional options for Compute#forwardingRulesInsert.
 */
export interface ForwardingRulesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#forwardingRulesList.
 */
export interface ForwardingRulesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#forwardingRulesPatch.
 */
export interface ForwardingRulesPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface ForwardingRulesScopedList {
  /**
   * A list of forwarding rules contained in this scope.
   */
  forwardingRules?: ForwardingRule[];
  /**
   * Informational warning which replaces the list of forwarding rules when the
   * list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeForwardingRulesScopedList(data: any): ForwardingRulesScopedList {
  return {
    ...data,
    forwardingRules: data["forwardingRules"] !== undefined ? data["forwardingRules"].map((item: any) => (serializeForwardingRule(item))) : undefined,
  };
}

function deserializeForwardingRulesScopedList(data: any): ForwardingRulesScopedList {
  return {
    ...data,
    forwardingRules: data["forwardingRules"] !== undefined ? data["forwardingRules"].map((item: any) => (deserializeForwardingRule(item))) : undefined,
  };
}

/**
 * Additional options for Compute#forwardingRulesSetLabels.
 */
export interface ForwardingRulesSetLabelsOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#forwardingRulesSetTarget.
 */
export interface ForwardingRulesSetTargetOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#globalAddressesDelete.
 */
export interface GlobalAddressesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#globalAddressesInsert.
 */
export interface GlobalAddressesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#globalAddressesList.
 */
export interface GlobalAddressesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#globalForwardingRulesDelete.
 */
export interface GlobalForwardingRulesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#globalForwardingRulesInsert.
 */
export interface GlobalForwardingRulesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#globalForwardingRulesList.
 */
export interface GlobalForwardingRulesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#globalForwardingRulesPatch.
 */
export interface GlobalForwardingRulesPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#globalForwardingRulesSetTarget.
 */
export interface GlobalForwardingRulesSetTargetOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface GlobalNetworkEndpointGroupsAttachEndpointsRequest {
  /**
   * The list of network endpoints to be attached.
   */
  networkEndpoints?: NetworkEndpoint[];
}

/**
 * Additional options for
 * Compute#globalNetworkEndpointGroupsAttachNetworkEndpoints.
 */
export interface GlobalNetworkEndpointGroupsAttachNetworkEndpointsOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#globalNetworkEndpointGroupsDelete.
 */
export interface GlobalNetworkEndpointGroupsDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface GlobalNetworkEndpointGroupsDetachEndpointsRequest {
  /**
   * The list of network endpoints to be detached.
   */
  networkEndpoints?: NetworkEndpoint[];
}

/**
 * Additional options for
 * Compute#globalNetworkEndpointGroupsDetachNetworkEndpoints.
 */
export interface GlobalNetworkEndpointGroupsDetachNetworkEndpointsOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#globalNetworkEndpointGroupsInsert.
 */
export interface GlobalNetworkEndpointGroupsInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for
 * Compute#globalNetworkEndpointGroupsListNetworkEndpoints.
 */
export interface GlobalNetworkEndpointGroupsListNetworkEndpointsOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#globalNetworkEndpointGroupsList.
 */
export interface GlobalNetworkEndpointGroupsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#globalOperationsAggregatedList.
 */
export interface GlobalOperationsAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#globalOperationsList.
 */
export interface GlobalOperationsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#globalOrganizationOperationsDelete.
 */
export interface GlobalOrganizationOperationsDeleteOptions {
  /**
   * Parent ID for this request.
   */
  parentId?: string;
}

/**
 * Additional options for Compute#globalOrganizationOperationsGet.
 */
export interface GlobalOrganizationOperationsGetOptions {
  /**
   * Parent ID for this request.
   */
  parentId?: string;
}

/**
 * Additional options for Compute#globalOrganizationOperationsList.
 */
export interface GlobalOrganizationOperationsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Parent ID for this request.
   */
  parentId?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface GlobalOrganizationSetPolicyRequest {
  /**
   * Flatten Policy to create a backward compatible wire-format. Deprecated.
   * Use 'policy' to specify bindings.
   */
  bindings?: Binding[];
  /**
   * Flatten Policy to create a backward compatible wire-format. Deprecated.
   * Use 'policy' to specify the etag.
   */
  etag?: Uint8Array;
  /**
   * REQUIRED: The complete policy to be applied to the 'resource'. The size of
   * the policy is limited to a few 10s of KB. An empty policy is in general a
   * valid policy but certain services (like Projects) might reject them.
   */
  policy?: Policy;
}

function serializeGlobalOrganizationSetPolicyRequest(data: any): GlobalOrganizationSetPolicyRequest {
  return {
    ...data,
    etag: data["etag"] !== undefined ? encodeBase64(data["etag"]) : undefined,
    policy: data["policy"] !== undefined ? serializePolicy(data["policy"]) : undefined,
  };
}

function deserializeGlobalOrganizationSetPolicyRequest(data: any): GlobalOrganizationSetPolicyRequest {
  return {
    ...data,
    etag: data["etag"] !== undefined ? decodeBase64(data["etag"] as string) : undefined,
    policy: data["policy"] !== undefined ? deserializePolicy(data["policy"]) : undefined,
  };
}

/**
 * Additional options for Compute#globalPublicDelegatedPrefixesDelete.
 */
export interface GlobalPublicDelegatedPrefixesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#globalPublicDelegatedPrefixesInsert.
 */
export interface GlobalPublicDelegatedPrefixesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#globalPublicDelegatedPrefixesList.
 */
export interface GlobalPublicDelegatedPrefixesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#globalPublicDelegatedPrefixesPatch.
 */
export interface GlobalPublicDelegatedPrefixesPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface GlobalSetLabelsRequest {
  /**
   * The fingerprint of the previous set of labels for this resource, used to
   * detect conflicts. The fingerprint is initially generated by Compute Engine
   * and changes after every request to modify or update labels. You must always
   * provide an up-to-date fingerprint hash when updating or changing labels,
   * otherwise the request will fail with error 412 conditionNotMet. Make a
   * get() request to the resource to get the latest fingerprint.
   */
  labelFingerprint?: Uint8Array;
  /**
   * A list of labels to apply for this resource. Each label must comply with
   * the requirements for labels. For example, "webserver-frontend": "images". A
   * label value can also be empty (e.g. "my-label": "").
   */
  labels?: {
    [key: string]: string
  };
}

function serializeGlobalSetLabelsRequest(data: any): GlobalSetLabelsRequest {
  return {
    ...data,
    labelFingerprint: data["labelFingerprint"] !== undefined ? encodeBase64(data["labelFingerprint"]) : undefined,
  };
}

function deserializeGlobalSetLabelsRequest(data: any): GlobalSetLabelsRequest {
  return {
    ...data,
    labelFingerprint: data["labelFingerprint"] !== undefined ? decodeBase64(data["labelFingerprint"] as string) : undefined,
  };
}

export interface GlobalSetPolicyRequest {
  /**
   * Flatten Policy to create a backward compatible wire-format. Deprecated.
   * Use 'policy' to specify bindings.
   */
  bindings?: Binding[];
  /**
   * Flatten Policy to create a backward compatible wire-format. Deprecated.
   * Use 'policy' to specify the etag.
   */
  etag?: Uint8Array;
  /**
   * REQUIRED: The complete policy to be applied to the 'resource'. The size of
   * the policy is limited to a few 10s of KB. An empty policy is in general a
   * valid policy but certain services (like Projects) might reject them.
   */
  policy?: Policy;
}

function serializeGlobalSetPolicyRequest(data: any): GlobalSetPolicyRequest {
  return {
    ...data,
    etag: data["etag"] !== undefined ? encodeBase64(data["etag"]) : undefined,
    policy: data["policy"] !== undefined ? serializePolicy(data["policy"]) : undefined,
  };
}

function deserializeGlobalSetPolicyRequest(data: any): GlobalSetPolicyRequest {
  return {
    ...data,
    etag: data["etag"] !== undefined ? decodeBase64(data["etag"] as string) : undefined,
    policy: data["policy"] !== undefined ? deserializePolicy(data["policy"]) : undefined,
  };
}

export interface GRPCHealthCheck {
  /**
   * The gRPC service name for the health check. This field is optional. The
   * value of grpc_service_name has the following meanings by convention: -
   * Empty service_name means the overall status of all services at the backend.
   * - Non-empty service_name means the health of that gRPC service, as defined
   * by the owner of the service. The grpc_service_name can only be ASCII.
   */
  grpcServiceName?: string;
  /**
   * The TCP port number to which the health check prober sends packets. Valid
   * values are 1 through 65535.
   */
  port?: number;
  /**
   * Not supported.
   */
  portName?: string;
  /**
   * Specifies how a port is selected for health checking. Can be one of the
   * following values: USE_FIXED_PORT: Specifies a port number explicitly using
   * the port field in the health check. Supported by backend services for
   * pass-through load balancers and backend services for proxy load balancers.
   * Not supported by target pools. The health check supports all backends
   * supported by the backend service provided the backend can be health
   * checked. For example, GCE_VM_IP network endpoint groups, GCE_VM_IP_PORT
   * network endpoint groups, and instance group backends. USE_NAMED_PORT: Not
   * supported. USE_SERVING_PORT: Provides an indirect method of specifying the
   * health check port by referring to the backend service. Only supported by
   * backend services for proxy load balancers. Not supported by target pools.
   * Not supported by backend services for pass-through load balancers. Supports
   * all backends that can be health checked; for example, GCE_VM_IP_PORT
   * network endpoint groups and instance group backends. For GCE_VM_IP_PORT
   * network endpoint group backends, the health check uses the port number
   * specified for each endpoint in the network endpoint group. For instance
   * group backends, the health check uses the port number determined by looking
   * up the backend service's named port in the instance group's list of named
   * ports.
   */
  portSpecification?:  | "USE_FIXED_PORT" | "USE_NAMED_PORT" | "USE_SERVING_PORT";
}

/**
 * A guest attributes entry.
 */
export interface GuestAttributes {
  /**
   * [Output Only] Type of the resource. Always compute#guestAttributes for
   * guest attributes entry.
   */
  kind?: string;
  /**
   * The path to be queried. This can be the default namespace ('') or a nested
   * namespace ('\/') or a specified key ('\/\').
   */
  queryPath?: string;
  /**
   * [Output Only] The value of the requested queried path.
   */
  queryValue?: GuestAttributesValue;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * The key to search for.
   */
  variableKey?: string;
  /**
   * [Output Only] The value found for the requested key.
   */
  variableValue?: string;
}

/**
 * A guest attributes namespace/key/value entry.
 */
export interface GuestAttributesEntry {
  /**
   * Key for the guest attribute entry.
   */
  key?: string;
  /**
   * Namespace for the guest attribute entry.
   */
  namespace?: string;
  /**
   * Value for the guest attribute entry.
   */
  value?: string;
}

/**
 * Array of guest attribute namespace/key/value tuples.
 */
export interface GuestAttributesValue {
  items?: GuestAttributesEntry[];
}

/**
 * Guest OS features.
 */
export interface GuestOsFeature {
  /**
   * The ID of a supported feature. To add multiple values, use commas to
   * separate values. Set to one or more of the following values: -
   * VIRTIO_SCSI_MULTIQUEUE - WINDOWS - MULTI_IP_SUBNET - UEFI_COMPATIBLE -
   * GVNIC - SEV_CAPABLE - SUSPEND_RESUME_COMPATIBLE - SEV_SNP_CAPABLE -
   * TDX_CAPABLE For more information, see Enabling guest operating system
   * features.
   */
  type?:  | "FEATURE_TYPE_UNSPECIFIED" | "GVNIC" | "MULTI_IP_SUBNET" | "SECURE_BOOT" | "SEV_CAPABLE" | "SEV_SNP_CAPABLE" | "UEFI_COMPATIBLE" | "VIRTIO_SCSI_MULTIQUEUE" | "WINDOWS";
}

/**
 * Represents a Health Check resource. Google Compute Engine has two Health
 * Check resources: * [Global](/compute/docs/reference/rest/v1/healthChecks) *
 * [Regional](/compute/docs/reference/rest/v1/regionHealthChecks) Internal
 * HTTP(S) load balancers must use regional health checks
 * (`compute.v1.regionHealthChecks`). Traffic Director must use global health
 * checks (`compute.v1.HealthChecks`). Internal TCP/UDP load balancers can use
 * either regional or global health checks (`compute.v1.regionHealthChecks` or
 * `compute.v1.HealthChecks`). External HTTP(S), TCP proxy, and SSL proxy load
 * balancers as well as managed instance group auto-healing must use global
 * health checks (`compute.v1.HealthChecks`). Backend service-based network load
 * balancers must use regional health checks (`compute.v1.regionHealthChecks`).
 * Target pool-based network load balancers must use legacy HTTP health checks
 * (`compute.v1.httpHealthChecks`). For more information, see Health checks
 * overview.
 */
export interface HealthCheck {
  /**
   * How often (in seconds) to send a health check. The default value is 5
   * seconds.
   */
  checkIntervalSec?: number;
  /**
   * [Output Only] Creation timestamp in 3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  grpcHealthCheck?: GRPCHealthCheck;
  /**
   * A so-far unhealthy instance will be marked healthy after this many
   * consecutive successes. The default value is 2.
   */
  healthyThreshold?: number;
  http2HealthCheck?: HTTP2HealthCheck;
  httpHealthCheck?: HTTPHealthCheck;
  httpsHealthCheck?: HTTPSHealthCheck;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * Type of the resource.
   */
  kind?: string;
  /**
   * Configure logging on this health check.
   */
  logConfig?: HealthCheckLogConfig;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035. For
   * example, a name that is 1-63 characters long, matches the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?`, and otherwise complies with
   * RFC1035. This regular expression describes a name where the first character
   * is a lowercase letter, and all following characters are a dash, lowercase
   * letter, or digit, except the last character, which isn't a dash.
   */
  name?: string;
  /**
   * [Output Only] Region where the health check resides. Not applicable to
   * global health checks.
   */
  region?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  sslHealthCheck?: SSLHealthCheck;
  tcpHealthCheck?: TCPHealthCheck;
  /**
   * How long (in seconds) to wait before claiming failure. The default value
   * is 5 seconds. It is invalid for timeoutSec to have greater value than
   * checkIntervalSec.
   */
  timeoutSec?: number;
  /**
   * Specifies the type of the healthCheck, either TCP, SSL, HTTP, HTTPS, HTTP2
   * or GRPC. Exactly one of the protocol-specific health check fields must be
   * specified, which must match type field.
   */
  type?:  | "GRPC" | "HTTP" | "HTTP2" | "HTTPS" | "INVALID" | "SSL" | "TCP";
  /**
   * A so-far healthy instance will be marked unhealthy after this many
   * consecutive failures. The default value is 2.
   */
  unhealthyThreshold?: number;
}

function serializeHealthCheck(data: any): HealthCheck {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeHealthCheck(data: any): HealthCheck {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

/**
 * Contains a list of HealthCheck resources.
 */
export interface HealthCheckList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of HealthCheck resources.
   */
  items?: HealthCheck[];
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeHealthCheckList(data: any): HealthCheckList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeHealthCheck(item))) : undefined,
  };
}

function deserializeHealthCheckList(data: any): HealthCheckList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeHealthCheck(item))) : undefined,
  };
}

/**
 * Configuration of logging on a health check. If logging is enabled, logs will
 * be exported to Stackdriver.
 */
export interface HealthCheckLogConfig {
  /**
   * Indicates whether or not to export logs. This is false by default, which
   * means no health check logging will be done.
   */
  enable?: boolean;
}

/**
 * A full or valid partial URL to a health check. For example, the following
 * are valid URLs: -
 * https://www.googleapis.com/compute/beta/projects/project-id/global/httpHealthChecks/health-check
 * - projects/project-id/global/httpHealthChecks/health-check -
 * global/httpHealthChecks/health-check
 */
export interface HealthCheckReference {
  healthCheck?: string;
}

export interface HealthChecksAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of HealthChecksScopedList resources.
   */
  items?: {
    [key: string]: HealthChecksScopedList
  };
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeHealthChecksAggregatedList(data: any): HealthChecksAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeHealthChecksScopedList(v)]))) : undefined,
  };
}

function deserializeHealthChecksAggregatedList(data: any): HealthChecksAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeHealthChecksScopedList(v)]))) : undefined,
  };
}

/**
 * Additional options for Compute#healthChecksAggregatedList.
 */
export interface HealthChecksAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#healthChecksDelete.
 */
export interface HealthChecksDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Represents a Health-Check as a Service resource.
 */
export interface HealthCheckService {
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * Fingerprint of this resource. A hash of the contents stored in this
   * object. This field is used in optimistic locking. This field will be
   * ignored when inserting a HealthCheckService. An up-to-date fingerprint must
   * be provided in order to patch/update the HealthCheckService; Otherwise, the
   * request will fail with error 412 conditionNotMet. To see the latest
   * fingerprint, make a get() request to retrieve the HealthCheckService.
   */
  fingerprint?: Uint8Array;
  /**
   * A list of URLs to the HealthCheck resources. Must have at least one
   * HealthCheck, and not more than 10 for regional HealthCheckService, and not
   * more than 1 for global HealthCheckService. HealthCheck resources must have
   * portSpecification=USE_SERVING_PORT or portSpecification=USE_FIXED_PORT. For
   * regional HealthCheckService, the HealthCheck must be regional and in the
   * same region. For global HealthCheckService, HealthCheck must be global. Mix
   * of regional and global HealthChecks is not supported. Multiple regional
   * HealthChecks must belong to the same region. Regional HealthChecks must
   * belong to the same region as zones of NetworkEndpointGroups. For global
   * HealthCheckService using global INTERNET_IP_PORT NetworkEndpointGroups, the
   * global HealthChecks must specify sourceRegions, and HealthChecks that
   * specify sourceRegions can only be used with global INTERNET_IP_PORT
   * NetworkEndpointGroups.
   */
  healthChecks?: string[];
  /**
   * Optional. Policy for how the results from multiple health checks for the
   * same endpoint are aggregated. Defaults to NO_AGGREGATION if unspecified. -
   * NO_AGGREGATION. An EndpointHealth message is returned for each pair in the
   * health check service. - AND. If any health check of an endpoint reports
   * UNHEALTHY, then UNHEALTHY is the HealthState of the endpoint. If all health
   * checks report HEALTHY, the HealthState of the endpoint is HEALTHY. . This
   * is only allowed with regional HealthCheckService.
   */
  healthStatusAggregationPolicy?:  | "AND" | "NO_AGGREGATION";
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output only] Type of the resource. Always compute#healthCheckServicefor
   * health check services.
   */
  kind?: string;
  /**
   * Name of the resource. The name must be 1-63 characters long, and comply
   * with RFC1035. Specifically, the name must be 1-63 characters long and match
   * the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first
   * character must be a lowercase letter, and all following characters must be
   * a dash, lowercase letter, or digit, except the last character, which cannot
   * be a dash.
   */
  name?: string;
  /**
   * A list of URLs to the NetworkEndpointGroup resources. Must not have more
   * than 100. For regional HealthCheckService, NEGs must be in zones in the
   * region of the HealthCheckService. For global HealthCheckServices, the
   * NetworkEndpointGroups must be global INTERNET_IP_PORT.
   */
  networkEndpointGroups?: string[];
  /**
   * A list of URLs to the NotificationEndpoint resources. Must not have more
   * than 10. A list of endpoints for receiving notifications of change in
   * health status. For regional HealthCheckService, NotificationEndpoint must
   * be regional and in the same region. For global HealthCheckService,
   * NotificationEndpoint must be global.
   */
  notificationEndpoints?: string[];
  /**
   * [Output Only] URL of the region where the health check service resides.
   * This field is not applicable to global health check services. You must
   * specify this field as part of the HTTP request URL. It is not settable as a
   * field in the request body.
   */
  region?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
}

function serializeHealthCheckService(data: any): HealthCheckService {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeHealthCheckService(data: any): HealthCheckService {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

/**
 * A full or valid partial URL to a health check service. For example, the
 * following are valid URLs: -
 * https://www.googleapis.com/compute/beta/projects/project-id/regions/us-west1/healthCheckServices/health-check-service
 * -
 * projects/project-id/regions/us-west1/healthCheckServices/health-check-service
 * - regions/us-west1/healthCheckServices/health-check-service
 */
export interface HealthCheckServiceReference {
  healthCheckService?: string;
}

export interface HealthCheckServicesList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of HealthCheckService resources.
   */
  items?: HealthCheckService[];
  /**
   * [Output Only] Type of the resource. Always compute#healthCheckServicesList
   * for lists of HealthCheckServices.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeHealthCheckServicesList(data: any): HealthCheckServicesList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeHealthCheckService(item))) : undefined,
  };
}

function deserializeHealthCheckServicesList(data: any): HealthCheckServicesList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeHealthCheckService(item))) : undefined,
  };
}

/**
 * Additional options for Compute#healthChecksInsert.
 */
export interface HealthChecksInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#healthChecksList.
 */
export interface HealthChecksListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#healthChecksPatch.
 */
export interface HealthChecksPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface HealthChecksScopedList {
  /**
   * A list of HealthChecks contained in this scope.
   */
  healthChecks?: HealthCheck[];
  /**
   * Informational warning which replaces the list of backend services when the
   * list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeHealthChecksScopedList(data: any): HealthChecksScopedList {
  return {
    ...data,
    healthChecks: data["healthChecks"] !== undefined ? data["healthChecks"].map((item: any) => (serializeHealthCheck(item))) : undefined,
  };
}

function deserializeHealthChecksScopedList(data: any): HealthChecksScopedList {
  return {
    ...data,
    healthChecks: data["healthChecks"] !== undefined ? data["healthChecks"].map((item: any) => (deserializeHealthCheck(item))) : undefined,
  };
}

/**
 * Additional options for Compute#healthChecksUpdate.
 */
export interface HealthChecksUpdateOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface HealthStatus {
  /**
   * Metadata defined as annotations for network endpoint.
   */
  annotations?: {
    [key: string]: string
  };
  /**
   * URL of the forwarding rule associated with the health status of the
   * instance.
   */
  forwardingRule?: string;
  /**
   * A forwarding rule IP address assigned to this instance.
   */
  forwardingRuleIp?: string;
  /**
   * Health state of the instance.
   */
  healthState?:  | "HEALTHY" | "UNHEALTHY";
  /**
   * URL of the instance resource.
   */
  instance?: string;
  /**
   * For target pool based Network Load Balancing, it indicates the forwarding
   * rule's IP address assigned to this instance. For other types of load
   * balancing, the field indicates VM internal ip.
   */
  ipAddress?: string;
  /**
   * The named port of the instance group, not necessarily the port that is
   * health-checked.
   */
  port?: number;
  weight?: string;
  weightError?:  | "INVALID_WEIGHT" | "MISSING_WEIGHT" | "UNAVAILABLE_WEIGHT" | "WEIGHT_NONE";
}

export interface HealthStatusForNetworkEndpoint {
  /**
   * URL of the backend service associated with the health state of the network
   * endpoint.
   */
  backendService?: BackendServiceReference;
  /**
   * URL of the forwarding rule associated with the health state of the network
   * endpoint.
   */
  forwardingRule?: ForwardingRuleReference;
  /**
   * URL of the health check associated with the health state of the network
   * endpoint.
   */
  healthCheck?: HealthCheckReference;
  /**
   * URL of the health check service associated with the health state of the
   * network endpoint.
   */
  healthCheckService?: HealthCheckServiceReference;
  /**
   * Health state of the network endpoint determined based on the health checks
   * configured.
   */
  healthState?:  | "DRAINING" | "HEALTHY" | "UNHEALTHY" | "UNKNOWN";
}

/**
 * Provides links to documentation or for performing an out of band action. For
 * example, if a quota check failed with an error indicating the calling project
 * hasn't enabled the accessed service, this can contain a URL pointing directly
 * to the right place in the developer console to flip the bit.
 */
export interface Help {
  /**
   * URL(s) pointing to additional information on handling the current error.
   */
  links?: HelpLink[];
}

/**
 * Describes a URL link.
 */
export interface HelpLink {
  /**
   * Describes what the link offers.
   */
  description?: string;
  /**
   * The URL of the link.
   */
  url?: string;
}

/**
 * UrlMaps A host-matching rule for a URL. If matched, will use the named
 * PathMatcher to select the BackendService.
 */
export interface HostRule {
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * The list of host patterns to match. They must be valid hostnames with
   * optional port numbers in the format host:port. * matches any string of
   * ([a-z0-9-.]*). In that case, * must be the first character, and if followed
   * by anything, the immediate following character must be either - or .. *
   * based matching is not supported when the URL map is bound to a target gRPC
   * proxy that has the validateForProxyless field set to true.
   */
  hosts?: string[];
  /**
   * The name of the PathMatcher to use to match the path portion of the URL if
   * the hostRule matches the URL's host portion.
   */
  pathMatcher?: string;
}

export interface HTTP2HealthCheck {
  /**
   * The value of the host header in the HTTP/2 health check request. If left
   * empty (default value), the host header is set to the destination IP address
   * to which health check packets are sent. The destination IP address depends
   * on the type of load balancer. For details, see:
   * https://cloud.google.com/load-balancing/docs/health-check-concepts#hc-packet-dest
   */
  host?: string;
  /**
   * The TCP port number to which the health check prober sends packets. The
   * default value is 443. Valid values are 1 through 65535.
   */
  port?: number;
  /**
   * Not supported.
   */
  portName?: string;
  /**
   * Specifies how a port is selected for health checking. Can be one of the
   * following values: USE_FIXED_PORT: Specifies a port number explicitly using
   * the port field in the health check. Supported by backend services for
   * pass-through load balancers and backend services for proxy load balancers.
   * Not supported by target pools. The health check supports all backends
   * supported by the backend service provided the backend can be health
   * checked. For example, GCE_VM_IP network endpoint groups, GCE_VM_IP_PORT
   * network endpoint groups, and instance group backends. USE_NAMED_PORT: Not
   * supported. USE_SERVING_PORT: Provides an indirect method of specifying the
   * health check port by referring to the backend service. Only supported by
   * backend services for proxy load balancers. Not supported by target pools.
   * Not supported by backend services for pass-through load balancers. Supports
   * all backends that can be health checked; for example, GCE_VM_IP_PORT
   * network endpoint groups and instance group backends. For GCE_VM_IP_PORT
   * network endpoint group backends, the health check uses the port number
   * specified for each endpoint in the network endpoint group. For instance
   * group backends, the health check uses the port number determined by looking
   * up the backend service's named port in the instance group's list of named
   * ports.
   */
  portSpecification?:  | "USE_FIXED_PORT" | "USE_NAMED_PORT" | "USE_SERVING_PORT";
  /**
   * Specifies the type of proxy header to append before sending data to the
   * backend, either NONE or PROXY_V1. The default is NONE.
   */
  proxyHeader?:  | "NONE" | "PROXY_V1";
  /**
   * The request path of the HTTP/2 health check request. The default value is
   * /.
   */
  requestPath?: string;
  /**
   * Creates a content-based HTTP/2 health check. In addition to the required
   * HTTP 200 (OK) status code, you can configure the health check to pass only
   * when the backend sends this specific ASCII response string within the first
   * 1024 bytes of the HTTP response body. For details, see:
   * https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-http
   */
  response?: string;
}

/**
 * Specification for how requests are aborted as part of fault injection.
 */
export interface HttpFaultAbort {
  /**
   * The HTTP status code used to abort the request. The value must be from 200
   * to 599 inclusive. For gRPC protocol, the gRPC status code is mapped to HTTP
   * status code according to this mapping table. HTTP status 200 is mapped to
   * gRPC status UNKNOWN. Injecting an OK status is currently not supported by
   * Traffic Director.
   */
  httpStatus?: number;
  /**
   * The percentage of traffic for connections, operations, or requests that is
   * aborted as part of fault injection. The value must be from 0.0 to 100.0
   * inclusive.
   */
  percentage?: number;
}

/**
 * Specifies the delay introduced by the load balancer before forwarding the
 * request to the backend service as part of fault injection.
 */
export interface HttpFaultDelay {
  /**
   * Specifies the value of the fixed delay interval.
   */
  fixedDelay?: Duration;
  /**
   * The percentage of traffic for connections, operations, or requests for
   * which a delay is introduced as part of fault injection. The value must be
   * from 0.0 to 100.0 inclusive.
   */
  percentage?: number;
}

function serializeHttpFaultDelay(data: any): HttpFaultDelay {
  return {
    ...data,
    fixedDelay: data["fixedDelay"] !== undefined ? serializeDuration(data["fixedDelay"]) : undefined,
  };
}

function deserializeHttpFaultDelay(data: any): HttpFaultDelay {
  return {
    ...data,
    fixedDelay: data["fixedDelay"] !== undefined ? deserializeDuration(data["fixedDelay"]) : undefined,
  };
}

/**
 * The specification for fault injection introduced into traffic to test the
 * resiliency of clients to backend service failure. As part of fault injection,
 * when clients send requests to a backend service, delays can be introduced by
 * the load balancer on a percentage of requests before sending those request to
 * the backend service. Similarly requests from clients can be aborted by the
 * load balancer for a percentage of requests.
 */
export interface HttpFaultInjection {
  /**
   * The specification for how client requests are aborted as part of fault
   * injection.
   */
  abort?: HttpFaultAbort;
  /**
   * The specification for how client requests are delayed as part of fault
   * injection, before being sent to a backend service.
   */
  delay?: HttpFaultDelay;
}

function serializeHttpFaultInjection(data: any): HttpFaultInjection {
  return {
    ...data,
    delay: data["delay"] !== undefined ? serializeHttpFaultDelay(data["delay"]) : undefined,
  };
}

function deserializeHttpFaultInjection(data: any): HttpFaultInjection {
  return {
    ...data,
    delay: data["delay"] !== undefined ? deserializeHttpFaultDelay(data["delay"]) : undefined,
  };
}

/**
 * The request and response header transformations that take effect before the
 * request is passed along to the selected backendService.
 */
export interface HttpHeaderAction {
  /**
   * Headers to add to a matching request before forwarding the request to the
   * backendService.
   */
  requestHeadersToAdd?: HttpHeaderOption[];
  /**
   * A list of header names for headers that need to be removed from the
   * request before forwarding the request to the backendService.
   */
  requestHeadersToRemove?: string[];
  /**
   * Headers to add the response before sending the response back to the
   * client.
   */
  responseHeadersToAdd?: HttpHeaderOption[];
  /**
   * A list of header names for headers that need to be removed from the
   * response before sending the response back to the client.
   */
  responseHeadersToRemove?: string[];
}

/**
 * matchRule criteria for request header matches.
 */
export interface HttpHeaderMatch {
  /**
   * The value should exactly match contents of exactMatch. Only one of
   * exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
   * rangeMatch must be set.
   */
  exactMatch?: string;
  /**
   * The name of the HTTP header to match. For matching against the HTTP
   * request's authority, use a headerMatch with the header name ":authority".
   * For matching a request's method, use the headerName ":method". When the URL
   * map is bound to a target gRPC proxy that has the validateForProxyless field
   * set to true, only non-binary user-specified custom metadata and the
   * `content-type` header are supported. The following transport-level headers
   * cannot be used in header matching rules: `:authority`, `:method`, `:path`,
   * `:scheme`, `user-agent`, `accept-encoding`, `content-encoding`,
   * `grpc-accept-encoding`, `grpc-encoding`, `grpc-previous-rpc-attempts`,
   * `grpc-tags-bin`, `grpc-timeout` and `grpc-trace-bin`.
   */
  headerName?: string;
  /**
   * If set to false, the headerMatch is considered a match if the preceding
   * match criteria are met. If set to true, the headerMatch is considered a
   * match if the preceding match criteria are NOT met. The default setting is
   * false.
   */
  invertMatch?: boolean;
  /**
   * The value of the header must start with the contents of prefixMatch. Only
   * one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
   * rangeMatch must be set.
   */
  prefixMatch?: string;
  /**
   * A header with the contents of headerName must exist. The match takes place
   * whether or not the request's header has a value. Only one of exactMatch,
   * prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be
   * set.
   */
  presentMatch?: boolean;
  /**
   * The header value must be an integer and its value must be in the range
   * specified in rangeMatch. If the header does not contain an integer, number
   * or is empty, the match fails. For example for a range [-5, 0] - -3 will
   * match. - 0 will not match. - 0.25 will not match. - -3someString will not
   * match. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch,
   * presentMatch or rangeMatch must be set. rangeMatch is not supported for
   * load balancers that have loadBalancingScheme set to EXTERNAL.
   */
  rangeMatch?: Int64RangeMatch;
  /**
   * The value of the header must match the regular expression specified in
   * regexMatch. For more information about regular expression syntax, see
   * Syntax. For matching against a port specified in the HTTP request, use a
   * headerMatch with headerName set to PORT and a regular expression that
   * satisfies the RFC2616 Host header's port specifier. Only one of exactMatch,
   * prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be
   * set. Regular expressions can only be used when the loadBalancingScheme is
   * set to INTERNAL_SELF_MANAGED.
   */
  regexMatch?: string;
  /**
   * The value of the header must end with the contents of suffixMatch. Only
   * one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
   * rangeMatch must be set.
   */
  suffixMatch?: string;
}

function serializeHttpHeaderMatch(data: any): HttpHeaderMatch {
  return {
    ...data,
    rangeMatch: data["rangeMatch"] !== undefined ? serializeInt64RangeMatch(data["rangeMatch"]) : undefined,
  };
}

function deserializeHttpHeaderMatch(data: any): HttpHeaderMatch {
  return {
    ...data,
    rangeMatch: data["rangeMatch"] !== undefined ? deserializeInt64RangeMatch(data["rangeMatch"]) : undefined,
  };
}

/**
 * Specification determining how headers are added to requests or responses.
 */
export interface HttpHeaderOption {
  /**
   * The name of the header.
   */
  headerName?: string;
  /**
   * The value of the header to add.
   */
  headerValue?: string;
  /**
   * If false, headerValue is appended to any values that already exist for the
   * header. If true, headerValue is set for the header, discarding any values
   * that were set for that header. The default value is false.
   */
  replace?: boolean;
}

/**
 * Represents a legacy HTTP Health Check resource. Legacy HTTP health checks
 * are now only required by target pool-based network load balancers. For all
 * other load balancers, including backend service-based network load balancers,
 * and for managed instance group auto-healing, you must use modern (non-legacy)
 * health checks. For more information, see Health checks overview .
 */
export interface HttpHealthCheck {
  /**
   * How often (in seconds) to send a health check. The default value is 5
   * seconds.
   */
  checkIntervalSec?: number;
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * A so-far unhealthy instance will be marked healthy after this many
   * consecutive successes. The default value is 2.
   */
  healthyThreshold?: number;
  /**
   * The value of the host header in the HTTP health check request. If left
   * empty (default value), the public IP on behalf of which this health check
   * is performed will be used.
   */
  host?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of the resource. Always compute#httpHealthCheck for
   * HTTP health checks.
   */
  kind?: string;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * The TCP port number for the HTTP health check request. The default value
   * is 80.
   */
  port?: number;
  /**
   * The request path of the HTTP health check request. The default value is /.
   * This field does not support query parameters. Must comply with RFC3986.
   */
  requestPath?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * How long (in seconds) to wait before claiming failure. The default value
   * is 5 seconds. It is invalid for timeoutSec to have greater value than
   * checkIntervalSec.
   */
  timeoutSec?: number;
  /**
   * A so-far healthy instance will be marked unhealthy after this many
   * consecutive failures. The default value is 2.
   */
  unhealthyThreshold?: number;
}

function serializeHttpHealthCheck(data: any): HttpHealthCheck {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeHttpHealthCheck(data: any): HttpHealthCheck {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface HTTPHealthCheck {
  /**
   * The value of the host header in the HTTP health check request. If left
   * empty (default value), the host header is set to the destination IP address
   * to which health check packets are sent. The destination IP address depends
   * on the type of load balancer. For details, see:
   * https://cloud.google.com/load-balancing/docs/health-check-concepts#hc-packet-dest
   */
  host?: string;
  /**
   * The TCP port number to which the health check prober sends packets. The
   * default value is 80. Valid values are 1 through 65535.
   */
  port?: number;
  /**
   * Not supported.
   */
  portName?: string;
  /**
   * Specifies how a port is selected for health checking. Can be one of the
   * following values: USE_FIXED_PORT: Specifies a port number explicitly using
   * the port field in the health check. Supported by backend services for
   * pass-through load balancers and backend services for proxy load balancers.
   * Also supported in legacy HTTP health checks for target pools. The health
   * check supports all backends supported by the backend service provided the
   * backend can be health checked. For example, GCE_VM_IP network endpoint
   * groups, GCE_VM_IP_PORT network endpoint groups, and instance group
   * backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT: Provides an
   * indirect method of specifying the health check port by referring to the
   * backend service. Only supported by backend services for proxy load
   * balancers. Not supported by target pools. Not supported by backend services
   * for pass-through load balancers. Supports all backends that can be health
   * checked; for example, GCE_VM_IP_PORT network endpoint groups and instance
   * group backends. For GCE_VM_IP_PORT network endpoint group backends, the
   * health check uses the port number specified for each endpoint in the
   * network endpoint group. For instance group backends, the health check uses
   * the port number determined by looking up the backend service's named port
   * in the instance group's list of named ports.
   */
  portSpecification?:  | "USE_FIXED_PORT" | "USE_NAMED_PORT" | "USE_SERVING_PORT";
  /**
   * Specifies the type of proxy header to append before sending data to the
   * backend, either NONE or PROXY_V1. The default is NONE.
   */
  proxyHeader?:  | "NONE" | "PROXY_V1";
  /**
   * The request path of the HTTP health check request. The default value is /.
   */
  requestPath?: string;
  /**
   * Creates a content-based HTTP health check. In addition to the required
   * HTTP 200 (OK) status code, you can configure the health check to pass only
   * when the backend sends this specific ASCII response string within the first
   * 1024 bytes of the HTTP response body. For details, see:
   * https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-http
   */
  response?: string;
}

/**
 * Contains a list of HttpHealthCheck resources.
 */
export interface HttpHealthCheckList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of HttpHealthCheck resources.
   */
  items?: HttpHealthCheck[];
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeHttpHealthCheckList(data: any): HttpHealthCheckList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeHttpHealthCheck(item))) : undefined,
  };
}

function deserializeHttpHealthCheckList(data: any): HttpHealthCheckList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeHttpHealthCheck(item))) : undefined,
  };
}

/**
 * Additional options for Compute#httpHealthChecksDelete.
 */
export interface HttpHealthChecksDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#httpHealthChecksInsert.
 */
export interface HttpHealthChecksInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#httpHealthChecksList.
 */
export interface HttpHealthChecksListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#httpHealthChecksPatch.
 */
export interface HttpHealthChecksPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#httpHealthChecksUpdate.
 */
export interface HttpHealthChecksUpdateOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * HttpRouteRuleMatch criteria for a request's query parameter.
 */
export interface HttpQueryParameterMatch {
  /**
   * The queryParameterMatch matches if the value of the parameter exactly
   * matches the contents of exactMatch. Only one of presentMatch, exactMatch,
   * or regexMatch must be set.
   */
  exactMatch?: string;
  /**
   * The name of the query parameter to match. The query parameter must exist
   * in the request, in the absence of which the request match fails.
   */
  name?: string;
  /**
   * Specifies that the queryParameterMatch matches if the request contains the
   * query parameter, irrespective of whether the parameter has a value or not.
   * Only one of presentMatch, exactMatch, or regexMatch must be set.
   */
  presentMatch?: boolean;
  /**
   * The queryParameterMatch matches if the value of the parameter matches the
   * regular expression specified by regexMatch. For more information about
   * regular expression syntax, see Syntax. Only one of presentMatch,
   * exactMatch, or regexMatch must be set. Regular expressions can only be used
   * when the loadBalancingScheme is set to INTERNAL_SELF_MANAGED.
   */
  regexMatch?: string;
}

/**
 * Specifies settings for an HTTP redirect.
 */
export interface HttpRedirectAction {
  /**
   * The host that is used in the redirect response instead of the one that was
   * supplied in the request. The value must be from 1 to 255 characters.
   */
  hostRedirect?: string;
  /**
   * If set to true, the URL scheme in the redirected request is set to HTTPS.
   * If set to false, the URL scheme of the redirected request remains the same
   * as that of the request. This must only be set for URL maps used in
   * TargetHttpProxys. Setting this true for TargetHttpsProxy is not permitted.
   * The default is set to false.
   */
  httpsRedirect?: boolean;
  /**
   * The path that is used in the redirect response instead of the one that was
   * supplied in the request. pathRedirect cannot be supplied together with
   * prefixRedirect. Supply one alone or neither. If neither is supplied, the
   * path of the original request is used for the redirect. The value must be
   * from 1 to 1024 characters.
   */
  pathRedirect?: string;
  /**
   * The prefix that replaces the prefixMatch specified in the
   * HttpRouteRuleMatch, retaining the remaining portion of the URL before
   * redirecting the request. prefixRedirect cannot be supplied together with
   * pathRedirect. Supply one alone or neither. If neither is supplied, the path
   * of the original request is used for the redirect. The value must be from 1
   * to 1024 characters.
   */
  prefixRedirect?: string;
  /**
   * The HTTP Status code to use for this RedirectAction. Supported values are:
   * - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to
   * 301. - FOUND, which corresponds to 302. - SEE_OTHER which corresponds to
   * 303. - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the
   * request method is retained. - PERMANENT_REDIRECT, which corresponds to 308.
   * In this case, the request method is retained.
   */
  redirectResponseCode?:  | "FOUND" | "MOVED_PERMANENTLY_DEFAULT" | "PERMANENT_REDIRECT" | "SEE_OTHER" | "TEMPORARY_REDIRECT";
  /**
   * If set to true, any accompanying query portion of the original URL is
   * removed before redirecting the request. If set to false, the query portion
   * of the original URL is retained. The default is set to false.
   */
  stripQuery?: boolean;
}

/**
 * The retry policy associates with HttpRouteRule
 */
export interface HttpRetryPolicy {
  /**
   * Specifies the allowed number retries. This number must be > 0. If not
   * specified, defaults to 1.
   */
  numRetries?: number;
  /**
   * Specifies a non-zero timeout per retry attempt. If not specified, will use
   * the timeout set in the HttpRouteAction field. If timeout in the
   * HttpRouteAction field is not set, this field uses the largest timeout among
   * all backend services associated with the route. Not supported when the URL
   * map is bound to a target gRPC proxy that has the validateForProxyless field
   * set to true.
   */
  perTryTimeout?: Duration;
  /**
   * Specifies one or more conditions when this retry policy applies. Valid
   * values are: - 5xx: retry is attempted if the instance or endpoint responds
   * with any 5xx response code, or if the instance or endpoint does not respond
   * at all. For example, disconnects, reset, read timeout, connection failure,
   * and refused streams. - gateway-error: Similar to 5xx, but only applies to
   * response codes 502, 503 or 504. - connect-failure: a retry is attempted on
   * failures connecting to the instance or endpoint. For example, connection
   * timeouts. - retriable-4xx: a retry is attempted if the instance or endpoint
   * responds with a 4xx response code. The only error that you can retry is
   * error code 409. - refused-stream: a retry is attempted if the instance or
   * endpoint resets the stream with a REFUSED_STREAM error code. This reset
   * type indicates that it is safe to retry. - cancelled: a retry is attempted
   * if the gRPC status code in the response header is set to cancelled. -
   * deadline-exceeded: a retry is attempted if the gRPC status code in the
   * response header is set to deadline-exceeded. - internal: a retry is
   * attempted if the gRPC status code in the response header is set to
   * internal. - resource-exhausted: a retry is attempted if the gRPC status
   * code in the response header is set to resource-exhausted. - unavailable: a
   * retry is attempted if the gRPC status code in the response header is set to
   * unavailable. Only the following codes are supported when the URL map is
   * bound to target gRPC proxy that has validateForProxyless field set to true.
   * - cancelled - deadline-exceeded - internal - resource-exhausted -
   * unavailable
   */
  retryConditions?: string[];
}

function serializeHttpRetryPolicy(data: any): HttpRetryPolicy {
  return {
    ...data,
    perTryTimeout: data["perTryTimeout"] !== undefined ? serializeDuration(data["perTryTimeout"]) : undefined,
  };
}

function deserializeHttpRetryPolicy(data: any): HttpRetryPolicy {
  return {
    ...data,
    perTryTimeout: data["perTryTimeout"] !== undefined ? deserializeDuration(data["perTryTimeout"]) : undefined,
  };
}

export interface HttpRouteAction {
  /**
   * The specification for allowing client-side cross-origin requests. For more
   * information about the W3C recommendation for cross-origin resource sharing
   * (CORS), see Fetch API Living Standard. Not supported when the URL map is
   * bound to a target gRPC proxy.
   */
  corsPolicy?: CorsPolicy;
  /**
   * The specification for fault injection introduced into traffic to test the
   * resiliency of clients to backend service failure. As part of fault
   * injection, when clients send requests to a backend service, delays can be
   * introduced by a load balancer on a percentage of requests before sending
   * those requests to the backend service. Similarly requests from clients can
   * be aborted by the load balancer for a percentage of requests. timeout and
   * retry_policy is ignored by clients that are configured with a
   * fault_injection_policy if: 1. The traffic is generated by fault injection
   * AND 2. The fault injection is not a delay fault injection. Fault injection
   * is not supported with the global external HTTP(S) load balancer (classic).
   * To see which load balancers support fault injection, see Load balancing:
   * Routing and traffic management features.
   */
  faultInjectionPolicy?: HttpFaultInjection;
  /**
   * Specifies the maximum duration (timeout) for streams on the selected
   * route. Unlike the timeout field where the timeout duration starts from the
   * time the request has been fully processed (known as *end-of-stream*), the
   * duration in this field is computed from the beginning of the stream until
   * the response has been processed, including all retries. A stream that does
   * not complete in this duration is closed. If not specified, this field uses
   * the maximum maxStreamDuration value among all backend services associated
   * with the route. This field is only allowed if the Url map is used with
   * backend services with loadBalancingScheme set to INTERNAL_SELF_MANAGED.
   */
  maxStreamDuration?: Duration;
  /**
   * Specifies the policy on how requests intended for the route's backends are
   * shadowed to a separate mirrored backend service. The load balancer does not
   * wait for responses from the shadow service. Before sending traffic to the
   * shadow service, the host / authority header is suffixed with -shadow. Not
   * supported when the URL map is bound to a target gRPC proxy that has the
   * validateForProxyless field set to true.
   */
  requestMirrorPolicy?: RequestMirrorPolicy;
  /**
   * Specifies the retry policy associated with this route.
   */
  retryPolicy?: HttpRetryPolicy;
  /**
   * Specifies the timeout for the selected route. Timeout is computed from the
   * time the request has been fully processed (known as *end-of-stream*) up
   * until the response has been processed. Timeout includes all retries. If not
   * specified, this field uses the largest timeout among all backend services
   * associated with the route. Not supported when the URL map is bound to a
   * target gRPC proxy that has validateForProxyless field set to true.
   */
  timeout?: Duration;
  /**
   * The spec to modify the URL of the request, before forwarding the request
   * to the matched service. urlRewrite is the only action supported in UrlMaps
   * for external HTTP(S) load balancers. Not supported when the URL map is
   * bound to a target gRPC proxy that has the validateForProxyless field set to
   * true.
   */
  urlRewrite?: UrlRewrite;
  /**
   * A list of weighted backend services to send traffic to when a route match
   * occurs. The weights determine the fraction of traffic that flows to their
   * corresponding backend service. If all traffic needs to go to a single
   * backend service, there must be one weightedBackendService with weight set
   * to a non-zero number. After a backend service is identified and before
   * forwarding the request to the backend service, advanced routing actions
   * such as URL rewrites and header transformations are applied depending on
   * additional settings specified in this HttpRouteAction.
   */
  weightedBackendServices?: WeightedBackendService[];
}

function serializeHttpRouteAction(data: any): HttpRouteAction {
  return {
    ...data,
    faultInjectionPolicy: data["faultInjectionPolicy"] !== undefined ? serializeHttpFaultInjection(data["faultInjectionPolicy"]) : undefined,
    maxStreamDuration: data["maxStreamDuration"] !== undefined ? serializeDuration(data["maxStreamDuration"]) : undefined,
    retryPolicy: data["retryPolicy"] !== undefined ? serializeHttpRetryPolicy(data["retryPolicy"]) : undefined,
    timeout: data["timeout"] !== undefined ? serializeDuration(data["timeout"]) : undefined,
  };
}

function deserializeHttpRouteAction(data: any): HttpRouteAction {
  return {
    ...data,
    faultInjectionPolicy: data["faultInjectionPolicy"] !== undefined ? deserializeHttpFaultInjection(data["faultInjectionPolicy"]) : undefined,
    maxStreamDuration: data["maxStreamDuration"] !== undefined ? deserializeDuration(data["maxStreamDuration"]) : undefined,
    retryPolicy: data["retryPolicy"] !== undefined ? deserializeHttpRetryPolicy(data["retryPolicy"]) : undefined,
    timeout: data["timeout"] !== undefined ? deserializeDuration(data["timeout"]) : undefined,
  };
}

/**
 * The HttpRouteRule setting specifies how to match an HTTP request and the
 * corresponding routing action that load balancing proxies perform.
 */
export interface HttpRouteRule {
  /**
   * The short description conveying the intent of this routeRule. The
   * description can have a maximum length of 1024 characters.
   */
  description?: string;
  /**
   * Specifies changes to request and response headers that need to take effect
   * for the selected backendService. The headerAction value specified here is
   * applied before the matching pathMatchers[].headerAction and after
   * pathMatchers[].routeRules[].routeAction.weightedBackendService.backendServiceWeightAction[].headerAction
   * HeaderAction is not supported for load balancers that have their
   * loadBalancingScheme set to EXTERNAL. Not supported when the URL map is
   * bound to a target gRPC proxy that has validateForProxyless field set to
   * true.
   */
  headerAction?: HttpHeaderAction;
  /**
   * The list of criteria for matching attributes of a request to this
   * routeRule. This list has OR semantics: the request matches this routeRule
   * when any of the matchRules are satisfied. However predicates within a given
   * matchRule have AND semantics. All predicates within a matchRule must match
   * for the request to match the rule.
   */
  matchRules?: HttpRouteRuleMatch[];
  /**
   * For routeRules within a given pathMatcher, priority determines the order
   * in which a load balancer interprets routeRules. RouteRules are evaluated in
   * order of priority, from the lowest to highest number. The priority of a
   * rule decreases as its number increases (1, 2, 3, N+1). The first rule that
   * matches the request is applied. You cannot configure two or more routeRules
   * with the same priority. Priority for each rule must be set to a number from
   * 0 to 2147483647 inclusive. Priority numbers can have gaps, which enable you
   * to add or remove rules in the future without affecting the rest of the
   * rules. For example, 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority
   * numbers to which you could add rules numbered from 6 to 8, 10 to 11, and 13
   * to 15 in the future without any impact on existing rules.
   */
  priority?: number;
  /**
   * In response to a matching matchRule, the load balancer performs advanced
   * routing actions, such as URL rewrites and header transformations, before
   * forwarding the request to the selected backend. If routeAction specifies
   * any weightedBackendServices, service must not be set. Conversely if service
   * is set, routeAction cannot contain any weightedBackendServices. Only one of
   * urlRedirect, service or routeAction.weightedBackendService must be set. URL
   * maps for Classic external HTTP(S) load balancers only support the
   * urlRewrite action within a route rule's routeAction.
   */
  routeAction?: HttpRouteAction;
  /**
   * The full or partial URL of the backend service resource to which traffic
   * is directed if this rule is matched. If routeAction is also specified,
   * advanced routing actions, such as URL rewrites, take effect before sending
   * the request to the backend. However, if service is specified, routeAction
   * cannot contain any weightedBackendServices. Conversely, if routeAction
   * specifies any weightedBackendServices, service must not be specified. Only
   * one of urlRedirect, service or routeAction.weightedBackendService must be
   * set.
   */
  service?: string;
  /**
   * When this rule is matched, the request is redirected to a URL specified by
   * urlRedirect. If urlRedirect is specified, service or routeAction must not
   * be set. Not supported when the URL map is bound to a target gRPC proxy.
   */
  urlRedirect?: HttpRedirectAction;
}

function serializeHttpRouteRule(data: any): HttpRouteRule {
  return {
    ...data,
    matchRules: data["matchRules"] !== undefined ? data["matchRules"].map((item: any) => (serializeHttpRouteRuleMatch(item))) : undefined,
    routeAction: data["routeAction"] !== undefined ? serializeHttpRouteAction(data["routeAction"]) : undefined,
  };
}

function deserializeHttpRouteRule(data: any): HttpRouteRule {
  return {
    ...data,
    matchRules: data["matchRules"] !== undefined ? data["matchRules"].map((item: any) => (deserializeHttpRouteRuleMatch(item))) : undefined,
    routeAction: data["routeAction"] !== undefined ? deserializeHttpRouteAction(data["routeAction"]) : undefined,
  };
}

/**
 * HttpRouteRuleMatch specifies a set of criteria for matching requests to an
 * HttpRouteRule. All specified criteria must be satisfied for a match to occur.
 */
export interface HttpRouteRuleMatch {
  /**
   * For satisfying the matchRule condition, the path of the request must
   * exactly match the value specified in fullPathMatch after removing any query
   * parameters and anchor that may be part of the original URL. fullPathMatch
   * must be from 1 to 1024 characters. Only one of prefixMatch, fullPathMatch
   * or regexMatch must be specified.
   */
  fullPathMatch?: string;
  /**
   * Specifies a list of header match criteria, all of which must match
   * corresponding headers in the request.
   */
  headerMatches?: HttpHeaderMatch[];
  /**
   * Specifies that prefixMatch and fullPathMatch matches are case sensitive.
   * The default value is false. ignoreCase must not be used with regexMatch.
   * Not supported when the URL map is bound to a target gRPC proxy.
   */
  ignoreCase?: boolean;
  /**
   * Opaque filter criteria used by the load balancer to restrict routing
   * configuration to a limited set of xDS compliant clients. In their xDS
   * requests to the load balancer, xDS clients present node metadata. When
   * there is a match, the relevant routing configuration is made available to
   * those proxies. For each metadataFilter in this list, if its
   * filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels
   * must match the corresponding label provided in the metadata. If its
   * filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must
   * match with corresponding labels provided in the metadata. If multiple
   * metadata filters are specified, all of them need to be satisfied in order
   * to be considered a match. metadataFilters specified here is applied after
   * those specified in ForwardingRule that refers to the UrlMap this
   * HttpRouteRuleMatch belongs to. metadataFilters only applies to load
   * balancers that have loadBalancingScheme set to INTERNAL_SELF_MANAGED. Not
   * supported when the URL map is bound to a target gRPC proxy that has
   * validateForProxyless field set to true.
   */
  metadataFilters?: MetadataFilter[];
  /**
   * For satisfying the matchRule condition, the request's path must begin with
   * the specified prefixMatch. prefixMatch must begin with a /. The value must
   * be from 1 to 1024 characters. Only one of prefixMatch, fullPathMatch or
   * regexMatch must be specified.
   */
  prefixMatch?: string;
  /**
   * Specifies a list of query parameter match criteria, all of which must
   * match corresponding query parameters in the request. Not supported when the
   * URL map is bound to a target gRPC proxy.
   */
  queryParameterMatches?: HttpQueryParameterMatch[];
  /**
   * For satisfying the matchRule condition, the path of the request must
   * satisfy the regular expression specified in regexMatch after removing any
   * query parameters and anchor supplied with the original URL. For more
   * information about regular expression syntax, see Syntax. Only one of
   * prefixMatch, fullPathMatch or regexMatch must be specified. Regular
   * expressions can only be used when the loadBalancingScheme is set to
   * INTERNAL_SELF_MANAGED.
   */
  regexMatch?: string;
}

function serializeHttpRouteRuleMatch(data: any): HttpRouteRuleMatch {
  return {
    ...data,
    headerMatches: data["headerMatches"] !== undefined ? data["headerMatches"].map((item: any) => (serializeHttpHeaderMatch(item))) : undefined,
  };
}

function deserializeHttpRouteRuleMatch(data: any): HttpRouteRuleMatch {
  return {
    ...data,
    headerMatches: data["headerMatches"] !== undefined ? data["headerMatches"].map((item: any) => (deserializeHttpHeaderMatch(item))) : undefined,
  };
}

/**
 * Represents a legacy HTTPS Health Check resource. Legacy HTTPS health checks
 * have been deprecated. If you are using a target pool-based network load
 * balancer, you must use a legacy HTTP (not HTTPS) health check. For all other
 * load balancers, including backend service-based network load balancers, and
 * for managed instance group auto-healing, you must use modern (non-legacy)
 * health checks. For more information, see Health checks overview .
 */
export interface HttpsHealthCheck {
  /**
   * How often (in seconds) to send a health check. The default value is 5
   * seconds.
   */
  checkIntervalSec?: number;
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * A so-far unhealthy instance will be marked healthy after this many
   * consecutive successes. The default value is 2.
   */
  healthyThreshold?: number;
  /**
   * The value of the host header in the HTTPS health check request. If left
   * empty (default value), the public IP on behalf of which this health check
   * is performed will be used.
   */
  host?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * Type of the resource.
   */
  kind?: string;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * The TCP port number for the HTTPS health check request. The default value
   * is 443.
   */
  port?: number;
  /**
   * The request path of the HTTPS health check request. The default value is
   * "/". Must comply with RFC3986.
   */
  requestPath?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * How long (in seconds) to wait before claiming failure. The default value
   * is 5 seconds. It is invalid for timeoutSec to have a greater value than
   * checkIntervalSec.
   */
  timeoutSec?: number;
  /**
   * A so-far healthy instance will be marked unhealthy after this many
   * consecutive failures. The default value is 2.
   */
  unhealthyThreshold?: number;
}

function serializeHttpsHealthCheck(data: any): HttpsHealthCheck {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeHttpsHealthCheck(data: any): HttpsHealthCheck {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface HTTPSHealthCheck {
  /**
   * The value of the host header in the HTTPS health check request. If left
   * empty (default value), the host header is set to the destination IP address
   * to which health check packets are sent. The destination IP address depends
   * on the type of load balancer. For details, see:
   * https://cloud.google.com/load-balancing/docs/health-check-concepts#hc-packet-dest
   */
  host?: string;
  /**
   * The TCP port number to which the health check prober sends packets. The
   * default value is 443. Valid values are 1 through 65535.
   */
  port?: number;
  /**
   * Not supported.
   */
  portName?: string;
  /**
   * Specifies how a port is selected for health checking. Can be one of the
   * following values: USE_FIXED_PORT: Specifies a port number explicitly using
   * the port field in the health check. Supported by backend services for
   * pass-through load balancers and backend services for proxy load balancers.
   * Not supported by target pools. The health check supports all backends
   * supported by the backend service provided the backend can be health
   * checked. For example, GCE_VM_IP network endpoint groups, GCE_VM_IP_PORT
   * network endpoint groups, and instance group backends. USE_NAMED_PORT: Not
   * supported. USE_SERVING_PORT: Provides an indirect method of specifying the
   * health check port by referring to the backend service. Only supported by
   * backend services for proxy load balancers. Not supported by target pools.
   * Not supported by backend services for pass-through load balancers. Supports
   * all backends that can be health checked; for example, GCE_VM_IP_PORT
   * network endpoint groups and instance group backends. For GCE_VM_IP_PORT
   * network endpoint group backends, the health check uses the port number
   * specified for each endpoint in the network endpoint group. For instance
   * group backends, the health check uses the port number determined by looking
   * up the backend service's named port in the instance group's list of named
   * ports.
   */
  portSpecification?:  | "USE_FIXED_PORT" | "USE_NAMED_PORT" | "USE_SERVING_PORT";
  /**
   * Specifies the type of proxy header to append before sending data to the
   * backend, either NONE or PROXY_V1. The default is NONE.
   */
  proxyHeader?:  | "NONE" | "PROXY_V1";
  /**
   * The request path of the HTTPS health check request. The default value is
   * /.
   */
  requestPath?: string;
  /**
   * Creates a content-based HTTPS health check. In addition to the required
   * HTTP 200 (OK) status code, you can configure the health check to pass only
   * when the backend sends this specific ASCII response string within the first
   * 1024 bytes of the HTTP response body. For details, see:
   * https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-http
   */
  response?: string;
}

/**
 * Contains a list of HttpsHealthCheck resources.
 */
export interface HttpsHealthCheckList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of HttpsHealthCheck resources.
   */
  items?: HttpsHealthCheck[];
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeHttpsHealthCheckList(data: any): HttpsHealthCheckList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeHttpsHealthCheck(item))) : undefined,
  };
}

function deserializeHttpsHealthCheckList(data: any): HttpsHealthCheckList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeHttpsHealthCheck(item))) : undefined,
  };
}

/**
 * Additional options for Compute#httpsHealthChecksDelete.
 */
export interface HttpsHealthChecksDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#httpsHealthChecksInsert.
 */
export interface HttpsHealthChecksInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#httpsHealthChecksList.
 */
export interface HttpsHealthChecksListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#httpsHealthChecksPatch.
 */
export interface HttpsHealthChecksPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#httpsHealthChecksUpdate.
 */
export interface HttpsHealthChecksUpdateOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Represents an Image resource. You can use images to create boot disks for
 * your VM instances. For more information, read Images.
 */
export interface Image {
  /**
   * The architecture of the image. Valid values are ARM64 or X86_64.
   */
  architecture?:  | "ARCHITECTURE_UNSPECIFIED" | "ARM64" | "X86_64";
  /**
   * Size of the image tar.gz archive stored in Google Cloud Storage (in
   * bytes).
   */
  archiveSizeBytes?: bigint;
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * The deprecation status associated with this image.
   */
  deprecated?: DeprecationStatus;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * Size of the image when restored onto a persistent disk (in GB).
   */
  diskSizeGb?: bigint;
  /**
   * The name of the image family to which this image belongs. The image family
   * name can be from a publicly managed image family provided by Compute
   * Engine, or from a custom image family you create. For example,
   * centos-stream-9 is a publicly available image family. For more information,
   * see Image family best practices. When creating disks, you can specify an
   * image family instead of a specific image name. The image family always
   * returns its latest image that is not deprecated. The name of the image
   * family must comply with RFC1035.
   */
  family?: string;
  /**
   * A list of features to enable on the guest operating system. Applicable
   * only for bootable images. To see a list of available options, see the
   * guestOSfeatures[].type parameter.
   */
  guestOsFeatures?: GuestOsFeature[];
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * Encrypts the image using a customer-supplied encryption key. After you
   * encrypt an image with a customer-supplied key, you must provide the same
   * key if you use the image later (e.g. to create a disk from the image).
   * Customer-supplied encryption keys do not protect access to metadata of the
   * disk. If you do not provide an encryption key when creating the image, then
   * the disk will be encrypted using an automatically generated key and you do
   * not need to provide a key to use the image later.
   */
  imageEncryptionKey?: CustomerEncryptionKey;
  /**
   * [Output Only] Type of the resource. Always compute#image for images.
   */
  kind?: string;
  /**
   * A fingerprint for the labels being applied to this image, which is
   * essentially a hash of the labels used for optimistic locking. The
   * fingerprint is initially generated by Compute Engine and changes after
   * every request to modify or update labels. You must always provide an
   * up-to-date fingerprint hash in order to update or change labels, otherwise
   * the request will fail with error 412 conditionNotMet. To see the latest
   * fingerprint, make a get() request to retrieve an image.
   */
  labelFingerprint?: Uint8Array;
  /**
   * Labels to apply to this image. These can be later modified by the
   * setLabels method.
   */
  labels?: {
    [key: string]: string
  };
  /**
   * Integer license codes indicating which licenses are attached to this
   * image.
   */
  licenseCodes?: bigint[];
  /**
   * Any applicable license URI.
   */
  licenses?: string[];
  /**
   * Name of the resource; provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * The parameters of the raw disk image.
   */
  rawDisk?: {
    containerType?:  | "TAR";
    sha1Checksum?: string;
    source?: string;
  };
  /**
   * [Output Only] Reserved for future use.
   */
  satisfiesPzs?: boolean;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * Set the secure boot keys of shielded instance.
   */
  shieldedInstanceInitialState?: InitialStateConfig;
  /**
   * URL of the source disk used to create this image. For example, the
   * following are valid values: -
   * https://www.googleapis.com/compute/v1/projects/project/zones/zone
   * /disks/disk - projects/project/zones/zone/disks/disk -
   * zones/zone/disks/disk In order to create an image, you must provide the
   * full or partial URL of one of the following: - The rawDisk.source URL - The
   * sourceDisk URL - The sourceImage URL - The sourceSnapshot URL
   */
  sourceDisk?: string;
  /**
   * The customer-supplied encryption key of the source disk. Required if the
   * source disk is protected by a customer-supplied encryption key.
   */
  sourceDiskEncryptionKey?: CustomerEncryptionKey;
  /**
   * [Output Only] The ID value of the disk used to create this image. This
   * value may be used to determine whether the image was taken from the current
   * or a previous instance of a given disk name.
   */
  sourceDiskId?: string;
  /**
   * URL of the source image used to create this image. The following are valid
   * formats for the URL: -
   * https://www.googleapis.com/compute/v1/projects/project_id/global/
   * images/image_name - projects/project_id/global/images/image_name In order
   * to create an image, you must provide the full or partial URL of one of the
   * following: - The rawDisk.source URL - The sourceDisk URL - The sourceImage
   * URL - The sourceSnapshot URL
   */
  sourceImage?: string;
  /**
   * The customer-supplied encryption key of the source image. Required if the
   * source image is protected by a customer-supplied encryption key.
   */
  sourceImageEncryptionKey?: CustomerEncryptionKey;
  /**
   * [Output Only] The ID value of the image used to create this image. This
   * value may be used to determine whether the image was taken from the current
   * or a previous instance of a given image name.
   */
  sourceImageId?: string;
  /**
   * URL of the source snapshot used to create this image. The following are
   * valid formats for the URL: -
   * https://www.googleapis.com/compute/v1/projects/project_id/global/
   * snapshots/snapshot_name -
   * projects/project_id/global/snapshots/snapshot_name In order to create an
   * image, you must provide the full or partial URL of one of the following: -
   * The rawDisk.source URL - The sourceDisk URL - The sourceImage URL - The
   * sourceSnapshot URL
   */
  sourceSnapshot?: string;
  /**
   * The customer-supplied encryption key of the source snapshot. Required if
   * the source snapshot is protected by a customer-supplied encryption key.
   */
  sourceSnapshotEncryptionKey?: CustomerEncryptionKey;
  /**
   * [Output Only] The ID value of the snapshot used to create this image. This
   * value may be used to determine whether the snapshot was taken from the
   * current or a previous instance of a given snapshot name.
   */
  sourceSnapshotId?: string;
  /**
   * The type of the image used to create this disk. The default and only valid
   * value is RAW.
   */
  sourceType?:  | "RAW";
  /**
   * [Output Only] The status of the image. An image can be used to create
   * other resources, such as instances, only after the image has been
   * successfully created and the status is set to READY. Possible values are
   * FAILED, PENDING, or READY.
   */
  status?:  | "DELETING" | "FAILED" | "PENDING" | "READY";
  /**
   * Cloud Storage bucket storage location of the image (regional or
   * multi-regional).
   */
  storageLocations?: string[];
}

function serializeImage(data: any): Image {
  return {
    ...data,
    archiveSizeBytes: data["archiveSizeBytes"] !== undefined ? String(data["archiveSizeBytes"]) : undefined,
    diskSizeGb: data["diskSizeGb"] !== undefined ? String(data["diskSizeGb"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
    labelFingerprint: data["labelFingerprint"] !== undefined ? encodeBase64(data["labelFingerprint"]) : undefined,
    licenseCodes: data["licenseCodes"] !== undefined ? data["licenseCodes"].map((item: any) => (String(item))) : undefined,
    shieldedInstanceInitialState: data["shieldedInstanceInitialState"] !== undefined ? serializeInitialStateConfig(data["shieldedInstanceInitialState"]) : undefined,
  };
}

function deserializeImage(data: any): Image {
  return {
    ...data,
    archiveSizeBytes: data["archiveSizeBytes"] !== undefined ? BigInt(data["archiveSizeBytes"]) : undefined,
    diskSizeGb: data["diskSizeGb"] !== undefined ? BigInt(data["diskSizeGb"]) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
    labelFingerprint: data["labelFingerprint"] !== undefined ? decodeBase64(data["labelFingerprint"] as string) : undefined,
    licenseCodes: data["licenseCodes"] !== undefined ? data["licenseCodes"].map((item: any) => (BigInt(item))) : undefined,
    shieldedInstanceInitialState: data["shieldedInstanceInitialState"] !== undefined ? deserializeInitialStateConfig(data["shieldedInstanceInitialState"]) : undefined,
  };
}

export interface ImageFamilyView {
  /**
   * The latest image that is part of the specified image family in the
   * requested location, and that is not deprecated.
   */
  image?: Image;
}

function serializeImageFamilyView(data: any): ImageFamilyView {
  return {
    ...data,
    image: data["image"] !== undefined ? serializeImage(data["image"]) : undefined,
  };
}

function deserializeImageFamilyView(data: any): ImageFamilyView {
  return {
    ...data,
    image: data["image"] !== undefined ? deserializeImage(data["image"]) : undefined,
  };
}

/**
 * Contains a list of images.
 */
export interface ImageList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of Image resources.
   */
  items?: Image[];
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeImageList(data: any): ImageList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeImage(item))) : undefined,
  };
}

function deserializeImageList(data: any): ImageList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeImage(item))) : undefined,
  };
}

/**
 * Additional options for Compute#imagesDelete.
 */
export interface ImagesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#imagesDeprecate.
 */
export interface ImagesDeprecateOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#imagesGetIamPolicy.
 */
export interface ImagesGetIamPolicyOptions {
  /**
   * Requested IAM Policy version.
   */
  optionsRequestedPolicyVersion?: number;
}

/**
 * Additional options for Compute#imagesInsert.
 */
export interface ImagesInsertOptions {
  /**
   * Force image creation if true.
   */
  forceCreate?: boolean;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#imagesList.
 */
export interface ImagesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#imagesPatch.
 */
export interface ImagesPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Initial State for shielded instance, these are public keys which are safe to
 * store in public
 */
export interface InitialStateConfig {
  /**
   * The Key Database (db).
   */
  dbs?: FileContentBuffer[];
  /**
   * The forbidden key database (dbx).
   */
  dbxs?: FileContentBuffer[];
  /**
   * The Key Exchange Key (KEK).
   */
  keks?: FileContentBuffer[];
  /**
   * The Platform Key (PK).
   */
  pk?: FileContentBuffer;
}

function serializeInitialStateConfig(data: any): InitialStateConfig {
  return {
    ...data,
    dbs: data["dbs"] !== undefined ? data["dbs"].map((item: any) => (serializeFileContentBuffer(item))) : undefined,
    dbxs: data["dbxs"] !== undefined ? data["dbxs"].map((item: any) => (serializeFileContentBuffer(item))) : undefined,
    keks: data["keks"] !== undefined ? data["keks"].map((item: any) => (serializeFileContentBuffer(item))) : undefined,
    pk: data["pk"] !== undefined ? serializeFileContentBuffer(data["pk"]) : undefined,
  };
}

function deserializeInitialStateConfig(data: any): InitialStateConfig {
  return {
    ...data,
    dbs: data["dbs"] !== undefined ? data["dbs"].map((item: any) => (deserializeFileContentBuffer(item))) : undefined,
    dbxs: data["dbxs"] !== undefined ? data["dbxs"].map((item: any) => (deserializeFileContentBuffer(item))) : undefined,
    keks: data["keks"] !== undefined ? data["keks"].map((item: any) => (deserializeFileContentBuffer(item))) : undefined,
    pk: data["pk"] !== undefined ? deserializeFileContentBuffer(data["pk"]) : undefined,
  };
}

/**
 * Represents an Instance resource. An instance is a virtual machine that is
 * hosted on Google Cloud Platform. For more information, read Virtual Machine
 * Instances.
 */
export interface Instance {
  /**
   * Controls for advanced machine-related behavior features.
   */
  advancedMachineFeatures?: AdvancedMachineFeatures;
  /**
   * Allows this instance to send and receive packets with non-matching
   * destination or source IPs. This is required if you plan to use this
   * instance to forward routes. For more information, see Enabling IP
   * Forwarding .
   */
  canIpForward?: boolean;
  confidentialInstanceConfig?: ConfidentialInstanceConfig;
  /**
   * [Output Only] The CPU platform used by this instance.
   */
  cpuPlatform?: string;
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * Whether the resource should be protected against deletion.
   */
  deletionProtection?: boolean;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * Array of disks associated with this instance. Persistent disks must be
   * created before you can assign them.
   */
  disks?: AttachedDisk[];
  /**
   * Enables display device for the instance.
   */
  displayDevice?: DisplayDevice;
  /**
   * Specifies a fingerprint for this resource, which is essentially a hash of
   * the instance's contents and used for optimistic locking. The fingerprint is
   * initially generated by Compute Engine and changes after every request to
   * modify or update the instance. You must always provide an up-to-date
   * fingerprint hash in order to update the instance. To see the latest
   * fingerprint, make get() request to the instance.
   */
  fingerprint?: Uint8Array;
  /**
   * A list of the type and count of accelerator cards attached to the
   * instance.
   */
  guestAccelerators?: AcceleratorConfig[];
  /**
   * Specifies the hostname of the instance. The specified hostname must be
   * RFC1035 compliant. If hostname is not specified, the default hostname is
   * [INSTANCE_NAME].c.[PROJECT_ID].internal when using the global DNS, and
   * [INSTANCE_NAME].[ZONE].c.[PROJECT_ID].internal when using zonal DNS.
   */
  hostname?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * KeyRevocationActionType of the instance. Supported options are "STOP" and
   * "NONE". The default value is "NONE" if it is not specified.
   */
  keyRevocationActionType?:  | "KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED" | "NONE" | "STOP";
  /**
   * [Output Only] Type of the resource. Always compute#instance for instances.
   */
  kind?: string;
  /**
   * A fingerprint for this request, which is essentially a hash of the label's
   * contents and used for optimistic locking. The fingerprint is initially
   * generated by Compute Engine and changes after every request to modify or
   * update labels. You must always provide an up-to-date fingerprint hash in
   * order to update or change labels. To see the latest fingerprint, make get()
   * request to the instance.
   */
  labelFingerprint?: Uint8Array;
  /**
   * Labels to apply to this instance. These can be later modified by the
   * setLabels method.
   */
  labels?: {
    [key: string]: string
  };
  /**
   * [Output Only] Last start timestamp in RFC3339 text format.
   */
  lastStartTimestamp?: string;
  /**
   * [Output Only] Last stop timestamp in RFC3339 text format.
   */
  lastStopTimestamp?: string;
  /**
   * [Output Only] Last suspended timestamp in RFC3339 text format.
   */
  lastSuspendedTimestamp?: string;
  /**
   * Full or partial URL of the machine type resource to use for this instance,
   * in the format: zones/zone/machineTypes/machine-type. This is provided by
   * the client when the instance is created. For example, the following is a
   * valid partial url to a predefined machine type:
   * zones/us-central1-f/machineTypes/n1-standard-1 To create a custom machine
   * type, provide a URL to a machine type in the following format, where CPUS
   * is 1 or an even number up to 32 (2, 4, 6, ... 24, etc), and MEMORY is the
   * total memory for this instance. Memory must be a multiple of 256 MB and
   * must be supplied in MB (e.g. 5 GB of memory is 5120 MB):
   * zones/zone/machineTypes/custom-CPUS-MEMORY For example:
   * zones/us-central1-f/machineTypes/custom-4-5120 For a full list of
   * restrictions, read the Specifications for custom machine types.
   */
  machineType?: string;
  /**
   * The metadata key/value pairs assigned to this instance. This includes
   * custom metadata and predefined keys.
   */
  metadata?: Metadata;
  /**
   * Specifies a minimum CPU platform for the VM instance. Applicable values
   * are the friendly names of CPU platforms, such as minCpuPlatform: "Intel
   * Haswell" or minCpuPlatform: "Intel Sandy Bridge".
   */
  minCpuPlatform?: string;
  /**
   * The name of the resource, provided by the client when initially creating
   * the resource. The resource name must be 1-63 characters long, and comply
   * with RFC1035. Specifically, the name must be 1-63 characters long and match
   * the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first
   * character must be a lowercase letter, and all following characters must be
   * a dash, lowercase letter, or digit, except the last character, which cannot
   * be a dash.
   */
  name?: string;
  /**
   * An array of network configurations for this instance. These specify how
   * interfaces are configured to interact with other network services, such as
   * connecting to the internet. Multiple interfaces are supported per instance.
   */
  networkInterfaces?: NetworkInterface[];
  networkPerformanceConfig?: NetworkPerformanceConfig;
  /**
   * Input only. [Input Only] Additional params passed with the request, but
   * not persisted as part of resource payload.
   */
  params?: InstanceParams;
  /**
   * The private IPv6 google access type for the VM. If not specified, use
   * INHERIT_FROM_SUBNETWORK as default.
   */
  privateIpv6GoogleAccess?:  | "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE" | "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE" | "INHERIT_FROM_SUBNETWORK";
  /**
   * Specifies the reservations that this instance can consume from.
   */
  reservationAffinity?: ReservationAffinity;
  /**
   * Resource policies applied to this instance.
   */
  resourcePolicies?: string[];
  /**
   * [Output Only] Specifies values set for instance attributes as compared to
   * the values requested by user in the corresponding input only field.
   */
  resourceStatus?: ResourceStatus;
  /**
   * [Output Only] Reserved for future use.
   */
  satisfiesPzs?: boolean;
  /**
   * Sets the scheduling options for this instance.
   */
  scheduling?: Scheduling;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * A list of service accounts, with their specified scopes, authorized for
   * this instance. Only one service account per VM instance is supported.
   * Service accounts generate access tokens that can be accessed through the
   * metadata server and used to authenticate applications on the instance. See
   * Service Accounts for more information.
   */
  serviceAccounts?: ServiceAccount[];
  shieldedInstanceConfig?: ShieldedInstanceConfig;
  shieldedInstanceIntegrityPolicy?: ShieldedInstanceIntegrityPolicy;
  /**
   * Source machine image
   */
  sourceMachineImage?: string;
  /**
   * Source machine image encryption key when creating an instance from a
   * machine image.
   */
  sourceMachineImageEncryptionKey?: CustomerEncryptionKey;
  /**
   * [Output Only] Whether a VM has been restricted for start because Compute
   * Engine has detected suspicious activity.
   */
  startRestricted?: boolean;
  /**
   * [Output Only] The status of the instance. One of the following values:
   * PROVISIONING, STAGING, RUNNING, STOPPING, SUSPENDING, SUSPENDED, REPAIRING,
   * and TERMINATED. For more information about the status of the instance, see
   * Instance life cycle.
   */
  status?:  | "DEPROVISIONING" | "PROVISIONING" | "REPAIRING" | "RUNNING" | "STAGING" | "STOPPED" | "STOPPING" | "SUSPENDED" | "SUSPENDING" | "TERMINATED";
  /**
   * [Output Only] An optional, human-readable explanation of the status.
   */
  statusMessage?: string;
  /**
   * Tags to apply to this instance. Tags are used to identify valid sources or
   * targets for network firewalls and are specified by the client during
   * instance creation. The tags can be later modified by the setTags method.
   * Each tag within the list must comply with RFC1035. Multiple tags can be
   * specified via the 'tags.items' field.
   */
  tags?: Tags;
  /**
   * [Output Only] URL of the zone where the instance resides. You must specify
   * this field as part of the HTTP request URL. It is not settable as a field
   * in the request body.
   */
  zone?: string;
}

function serializeInstance(data: any): Instance {
  return {
    ...data,
    disks: data["disks"] !== undefined ? data["disks"].map((item: any) => (serializeAttachedDisk(item))) : undefined,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
    labelFingerprint: data["labelFingerprint"] !== undefined ? encodeBase64(data["labelFingerprint"]) : undefined,
    metadata: data["metadata"] !== undefined ? serializeMetadata(data["metadata"]) : undefined,
    networkInterfaces: data["networkInterfaces"] !== undefined ? data["networkInterfaces"].map((item: any) => (serializeNetworkInterface(item))) : undefined,
    tags: data["tags"] !== undefined ? serializeTags(data["tags"]) : undefined,
  };
}

function deserializeInstance(data: any): Instance {
  return {
    ...data,
    disks: data["disks"] !== undefined ? data["disks"].map((item: any) => (deserializeAttachedDisk(item))) : undefined,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
    labelFingerprint: data["labelFingerprint"] !== undefined ? decodeBase64(data["labelFingerprint"] as string) : undefined,
    metadata: data["metadata"] !== undefined ? deserializeMetadata(data["metadata"]) : undefined,
    networkInterfaces: data["networkInterfaces"] !== undefined ? data["networkInterfaces"].map((item: any) => (deserializeNetworkInterface(item))) : undefined,
    tags: data["tags"] !== undefined ? deserializeTags(data["tags"]) : undefined,
  };
}

export interface InstanceAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * An object that contains a list of instances scoped by zone.
   */
  items?: {
    [key: string]: InstancesScopedList
  };
  /**
   * [Output Only] Type of resource. Always compute#instanceAggregatedList for
   * aggregated lists of Instance resources.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeInstanceAggregatedList(data: any): InstanceAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeInstancesScopedList(v)]))) : undefined,
  };
}

function deserializeInstanceAggregatedList(data: any): InstanceAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeInstancesScopedList(v)]))) : undefined,
  };
}

export interface InstanceConsumptionData {
  /**
   * Resources consumed by the instance.
   */
  consumptionInfo?: InstanceConsumptionInfo;
  /**
   * Server-defined URL for the instance.
   */
  instance?: string;
}

export interface InstanceConsumptionInfo {
  /**
   * The number of virtual CPUs that are available to the instance.
   */
  guestCpus?: number;
  /**
   * The amount of local SSD storage available to the instance, defined in GiB.
   */
  localSsdGb?: number;
  /**
   * The amount of physical memory available to the instance, defined in MiB.
   */
  memoryMb?: number;
  /**
   * The minimal guaranteed number of virtual CPUs that are reserved.
   */
  minNodeCpus?: number;
}

/**
 * Represents an Instance Group resource. Instance Groups can be used to
 * configure a target for load balancing. Instance groups can either be managed
 * or unmanaged. To create managed instance groups, use the instanceGroupManager
 * or regionInstanceGroupManager resource instead. Use zonal unmanaged instance
 * groups if you need to apply load balancing to groups of heterogeneous
 * instances or if you need to manage the instances yourself. You cannot create
 * regional unmanaged instance groups. For more information, read Instance
 * groups.
 */
export interface InstanceGroup {
  /**
   * [Output Only] The creation timestamp for this instance group in RFC3339
   * text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * [Output Only] The fingerprint of the named ports. The system uses this
   * fingerprint to detect conflicts when multiple users change the named ports
   * concurrently.
   */
  fingerprint?: Uint8Array;
  /**
   * [Output Only] A unique identifier for this instance group, generated by
   * the server.
   */
  id?: bigint;
  /**
   * [Output Only] The resource type, which is always compute#instanceGroup for
   * instance groups.
   */
  kind?: string;
  /**
   * The name of the instance group. The name must be 1-63 characters long, and
   * comply with RFC1035.
   */
  name?: string;
  /**
   * Assigns a name to a port number. For example: {name: "http", port: 80}
   * This allows the system to reference ports by the assigned name instead of a
   * port number. Named ports can also contain multiple ports. For example:
   * [{name: "app1", port: 8080}, {name: "app1", port: 8081}, {name: "app2",
   * port: 8082}] Named ports apply to all instances in this instance group.
   */
  namedPorts?: NamedPort[];
  /**
   * [Output Only] The URL of the network to which all instances in the
   * instance group belong. If your instance has multiple network interfaces,
   * then the network and subnetwork fields only refer to the network and subnet
   * used by your primary interface (nic0).
   */
  network?: string;
  /**
   * [Output Only] The URL of the region where the instance group is located
   * (for regional resources).
   */
  region?: string;
  /**
   * [Output Only] The URL for this instance group. The server generates this
   * URL.
   */
  selfLink?: string;
  /**
   * [Output Only] The total number of instances in the instance group.
   */
  size?: number;
  /**
   * [Output Only] The URL of the subnetwork to which all instances in the
   * instance group belong. If your instance has multiple network interfaces,
   * then the network and subnetwork fields only refer to the network and subnet
   * used by your primary interface (nic0).
   */
  subnetwork?: string;
  /**
   * [Output Only] The URL of the zone where the instance group is located (for
   * zonal resources).
   */
  zone?: string;
}

function serializeInstanceGroup(data: any): InstanceGroup {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeInstanceGroup(data: any): InstanceGroup {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface InstanceGroupAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of InstanceGroupsScopedList resources.
   */
  items?: {
    [key: string]: InstanceGroupsScopedList
  };
  /**
   * [Output Only] The resource type, which is always
   * compute#instanceGroupAggregatedList for aggregated lists of instance
   * groups.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeInstanceGroupAggregatedList(data: any): InstanceGroupAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeInstanceGroupsScopedList(v)]))) : undefined,
  };
}

function deserializeInstanceGroupAggregatedList(data: any): InstanceGroupAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeInstanceGroupsScopedList(v)]))) : undefined,
  };
}

/**
 * A list of InstanceGroup resources.
 */
export interface InstanceGroupList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of InstanceGroup resources.
   */
  items?: InstanceGroup[];
  /**
   * [Output Only] The resource type, which is always compute#instanceGroupList
   * for instance group lists.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeInstanceGroupList(data: any): InstanceGroupList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeInstanceGroup(item))) : undefined,
  };
}

function deserializeInstanceGroupList(data: any): InstanceGroupList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeInstanceGroup(item))) : undefined,
  };
}

/**
 * Represents a Managed Instance Group resource. An instance group is a
 * collection of VM instances that you can manage as a single entity. For more
 * information, read Instance groups. For zonal Managed Instance Group, use the
 * instanceGroupManagers resource. For regional Managed Instance Group, use the
 * regionInstanceGroupManagers resource.
 */
export interface InstanceGroupManager {
  /**
   * The autohealing policy for this managed instance group. You can specify
   * only one value.
   */
  autoHealingPolicies?: InstanceGroupManagerAutoHealingPolicy[];
  /**
   * The base instance name to use for instances in this group. The value must
   * be 1-58 characters long. Instances are named by appending a hyphen and a
   * random four-character string to the base instance name. The base instance
   * name must comply with RFC1035.
   */
  baseInstanceName?: string;
  /**
   * [Output Only] The creation timestamp for this managed instance group in
   * RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * [Output Only] The list of instance actions and the number of instances in
   * this managed instance group that are scheduled for each of those actions.
   */
  currentActions?: InstanceGroupManagerActionsSummary;
  /**
   * An optional description of this resource.
   */
  description?: string;
  /**
   * Policy specifying the intended distribution of managed instances across
   * zones in a regional managed instance group.
   */
  distributionPolicy?: DistributionPolicy;
  /**
   * Fingerprint of this resource. This field may be used in optimistic
   * locking. It will be ignored when inserting an InstanceGroupManager. An
   * up-to-date fingerprint must be provided in order to update the
   * InstanceGroupManager, otherwise the request will fail with error 412
   * conditionNotMet. To see the latest fingerprint, make a get() request to
   * retrieve an InstanceGroupManager.
   */
  fingerprint?: Uint8Array;
  /**
   * [Output Only] A unique identifier for this resource type. The server
   * generates this identifier.
   */
  id?: bigint;
  /**
   * [Output Only] The URL of the Instance Group resource.
   */
  instanceGroup?: string;
  /**
   * The URL of the instance template that is specified for this managed
   * instance group. The group uses this template to create all new instances in
   * the managed instance group. The templates for existing instances in the
   * group do not change unless you run recreateInstances, run
   * applyUpdatesToInstances, or set the group's updatePolicy.type to PROACTIVE.
   */
  instanceTemplate?: string;
  /**
   * [Output Only] The resource type, which is always
   * compute#instanceGroupManager for managed instance groups.
   */
  kind?: string;
  /**
   * Pagination behavior of the listManagedInstances API method for this
   * managed instance group.
   */
  listManagedInstancesResults?:  | "PAGELESS" | "PAGINATED";
  /**
   * The name of the managed instance group. The name must be 1-63 characters
   * long, and comply with RFC1035.
   */
  name?: string;
  /**
   * Named ports configured for the Instance Groups complementary to this
   * Instance Group Manager.
   */
  namedPorts?: NamedPort[];
  /**
   * [Output Only] The URL of the region where the managed instance group
   * resides (for regional resources).
   */
  region?: string;
  /**
   * [Output Only] The URL for this managed instance group. The server defines
   * this URL.
   */
  selfLink?: string;
  /**
   * Stateful configuration for this Instanced Group Manager
   */
  statefulPolicy?: StatefulPolicy;
  /**
   * [Output Only] The status of this managed instance group.
   */
  status?: InstanceGroupManagerStatus;
  /**
   * The URLs for all TargetPool resources to which instances in the
   * instanceGroup field are added. The target pools automatically apply to all
   * of the instances in the managed instance group.
   */
  targetPools?: string[];
  /**
   * The target number of running instances for this managed instance group.
   * You can reduce this number by using the instanceGroupManager
   * deleteInstances or abandonInstances methods. Resizing the group also
   * changes this number.
   */
  targetSize?: number;
  /**
   * The update policy for this managed instance group.
   */
  updatePolicy?: InstanceGroupManagerUpdatePolicy;
  /**
   * Specifies the instance templates used by this managed instance group to
   * create instances. Each version is defined by an instanceTemplate and a
   * name. Every version can appear at most once per instance group. This field
   * overrides the top-level instanceTemplate field. Read more about the
   * relationships between these fields. Exactly one version must leave the
   * targetSize field unset. That version will be applied to all remaining
   * instances. For more information, read about canary updates.
   */
  versions?: InstanceGroupManagerVersion[];
  /**
   * [Output Only] The URL of a zone where the managed instance group is
   * located (for zonal resources).
   */
  zone?: string;
}

function serializeInstanceGroupManager(data: any): InstanceGroupManager {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeInstanceGroupManager(data: any): InstanceGroupManager {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface InstanceGroupManagerActionsSummary {
  /**
   * [Output Only] The total number of instances in the managed instance group
   * that are scheduled to be abandoned. Abandoning an instance removes it from
   * the managed instance group without deleting it.
   */
  abandoning?: number;
  /**
   * [Output Only] The number of instances in the managed instance group that
   * are scheduled to be created or are currently being created. If the group
   * fails to create any of these instances, it tries again until it creates the
   * instance successfully. If you have disabled creation retries, this field
   * will not be populated; instead, the creatingWithoutRetries field will be
   * populated.
   */
  creating?: number;
  /**
   * [Output Only] The number of instances that the managed instance group will
   * attempt to create. The group attempts to create each instance only once. If
   * the group fails to create any of these instances, it decreases the group's
   * targetSize value accordingly.
   */
  creatingWithoutRetries?: number;
  /**
   * [Output Only] The number of instances in the managed instance group that
   * are scheduled to be deleted or are currently being deleted.
   */
  deleting?: number;
  /**
   * [Output Only] The number of instances in the managed instance group that
   * are running and have no scheduled actions.
   */
  none?: number;
  /**
   * [Output Only] The number of instances in the managed instance group that
   * are scheduled to be recreated or are currently being being recreated.
   * Recreating an instance deletes the existing root persistent disk and
   * creates a new disk from the image that is defined in the instance template.
   */
  recreating?: number;
  /**
   * [Output Only] The number of instances in the managed instance group that
   * are being reconfigured with properties that do not require a restart or a
   * recreate action. For example, setting or removing target pools for the
   * instance.
   */
  refreshing?: number;
  /**
   * [Output Only] The number of instances in the managed instance group that
   * are scheduled to be restarted or are currently being restarted.
   */
  restarting?: number;
  /**
   * [Output Only] The number of instances in the managed instance group that
   * are scheduled to be resumed or are currently being resumed.
   */
  resuming?: number;
  /**
   * [Output Only] The number of instances in the managed instance group that
   * are scheduled to be started or are currently being started.
   */
  starting?: number;
  /**
   * [Output Only] The number of instances in the managed instance group that
   * are scheduled to be stopped or are currently being stopped.
   */
  stopping?: number;
  /**
   * [Output Only] The number of instances in the managed instance group that
   * are scheduled to be suspended or are currently being suspended.
   */
  suspending?: number;
  /**
   * [Output Only] The number of instances in the managed instance group that
   * are being verified. See the managedInstances[].currentAction property in
   * the listManagedInstances method documentation.
   */
  verifying?: number;
}

export interface InstanceGroupManagerAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of InstanceGroupManagersScopedList resources.
   */
  items?: {
    [key: string]: InstanceGroupManagersScopedList
  };
  /**
   * [Output Only] The resource type, which is always
   * compute#instanceGroupManagerAggregatedList for an aggregated list of
   * managed instance groups.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeInstanceGroupManagerAggregatedList(data: any): InstanceGroupManagerAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeInstanceGroupManagersScopedList(v)]))) : undefined,
  };
}

function deserializeInstanceGroupManagerAggregatedList(data: any): InstanceGroupManagerAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeInstanceGroupManagersScopedList(v)]))) : undefined,
  };
}

export interface InstanceGroupManagerAutoHealingPolicy {
  /**
   * The URL for the health check that signals autohealing.
   */
  healthCheck?: string;
  /**
   * The number of seconds that the managed instance group waits before it
   * applies autohealing policies to new instances or recently recreated
   * instances. This initial delay allows instances to initialize and run their
   * startup scripts before the instance group determines that they are
   * UNHEALTHY. This prevents the managed instance group from recreating its
   * instances prematurely. This value must be from range [0, 3600].
   */
  initialDelaySec?: number;
}

/**
 * [Output Only] A list of managed instance groups.
 */
export interface InstanceGroupManagerList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of InstanceGroupManager resources.
   */
  items?: InstanceGroupManager[];
  /**
   * [Output Only] The resource type, which is always
   * compute#instanceGroupManagerList for a list of managed instance groups.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeInstanceGroupManagerList(data: any): InstanceGroupManagerList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeInstanceGroupManager(item))) : undefined,
  };
}

function deserializeInstanceGroupManagerList(data: any): InstanceGroupManagerList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeInstanceGroupManager(item))) : undefined,
  };
}

/**
 * Additional options for Compute#instanceGroupManagersAbandonInstances.
 */
export interface InstanceGroupManagersAbandonInstancesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface InstanceGroupManagersAbandonInstancesRequest {
  /**
   * The URLs of one or more instances to abandon. This can be a full URL or a
   * partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
   */
  instances?: string[];
}

/**
 * Additional options for Compute#instanceGroupManagersAggregatedList.
 */
export interface InstanceGroupManagersAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * InstanceGroupManagers.applyUpdatesToInstances
 */
export interface InstanceGroupManagersApplyUpdatesRequest {
  /**
   * Flag to update all instances instead of specified list of instances. If
   * the flag is set to true then the instances may not be specified in the
   * request.
   */
  allInstances?: boolean;
  /**
   * The list of URLs of one or more instances for which you want to apply
   * updates. Each URL can be a full URL or a partial URL, such as
   * zones/[ZONE]/instances/[INSTANCE_NAME].
   */
  instances?: string[];
  /**
   * The minimal action that you want to perform on each instance during the
   * update: - REPLACE: At minimum, delete the instance and create it again. -
   * RESTART: Stop the instance and start it again. - REFRESH: Do not stop the
   * instance. - NONE: Do not disrupt the instance at all. By default, the
   * minimum action is NONE. If your update requires a more disruptive action
   * than you set with this flag, the necessary action is performed to execute
   * the update.
   */
  minimalAction?:  | "NONE" | "REFRESH" | "REPLACE" | "RESTART";
  /**
   * The most disruptive action that you want to perform on each instance
   * during the update: - REPLACE: Delete the instance and create it again. -
   * RESTART: Stop the instance and start it again. - REFRESH: Do not stop the
   * instance. - NONE: Do not disrupt the instance at all. By default, the most
   * disruptive allowed action is REPLACE. If your update requires a more
   * disruptive action than you set with this flag, the update request will
   * fail.
   */
  mostDisruptiveAllowedAction?:  | "NONE" | "REFRESH" | "REPLACE" | "RESTART";
}

/**
 * Additional options for Compute#instanceGroupManagersCreateInstances.
 */
export interface InstanceGroupManagersCreateInstancesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * InstanceGroupManagers.createInstances
 */
export interface InstanceGroupManagersCreateInstancesRequest {
  /**
   * [Required] List of specifications of per-instance configs.
   */
  instances?: PerInstanceConfig[];
}

function serializeInstanceGroupManagersCreateInstancesRequest(data: any): InstanceGroupManagersCreateInstancesRequest {
  return {
    ...data,
    instances: data["instances"] !== undefined ? data["instances"].map((item: any) => (serializePerInstanceConfig(item))) : undefined,
  };
}

function deserializeInstanceGroupManagersCreateInstancesRequest(data: any): InstanceGroupManagersCreateInstancesRequest {
  return {
    ...data,
    instances: data["instances"] !== undefined ? data["instances"].map((item: any) => (deserializePerInstanceConfig(item))) : undefined,
  };
}

/**
 * Additional options for Compute#instanceGroupManagersDeleteInstances.
 */
export interface InstanceGroupManagersDeleteInstancesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface InstanceGroupManagersDeleteInstancesRequest {
  /**
   * The URLs of one or more instances to delete. This can be a full URL or a
   * partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
   */
  instances?: string[];
  /**
   * Specifies whether the request should proceed despite the inclusion of
   * instances that are not members of the group or that are already in the
   * process of being deleted or abandoned. If this field is set to `false` and
   * such an instance is specified in the request, the operation fails. The
   * operation always fails if the request contains a malformed instance URL or
   * a reference to an instance that exists in a zone or region other than the
   * group's zone or region.
   */
  skipInstancesOnValidationError?: boolean;
}

/**
 * Additional options for Compute#instanceGroupManagersDelete.
 */
export interface InstanceGroupManagersDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * InstanceGroupManagers.deletePerInstanceConfigs
 */
export interface InstanceGroupManagersDeletePerInstanceConfigsReq {
  /**
   * The list of instance names for which we want to delete per-instance
   * configs on this managed instance group.
   */
  names?: string[];
}

/**
 * Additional options for Compute#instanceGroupManagersInsert.
 */
export interface InstanceGroupManagersInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instanceGroupManagersListErrors.
 */
export interface InstanceGroupManagersListErrorsOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface InstanceGroupManagersListErrorsResponse {
  /**
   * [Output Only] The list of errors of the managed instance group.
   */
  items?: InstanceManagedByIgmError[];
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
}

/**
 * Additional options for Compute#instanceGroupManagersListManagedInstances.
 */
export interface InstanceGroupManagersListManagedInstancesOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface InstanceGroupManagersListManagedInstancesResponse {
  /**
   * [Output Only] The list of instances in the managed instance group.
   */
  managedInstances?: ManagedInstance[];
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
}

function serializeInstanceGroupManagersListManagedInstancesResponse(data: any): InstanceGroupManagersListManagedInstancesResponse {
  return {
    ...data,
    managedInstances: data["managedInstances"] !== undefined ? data["managedInstances"].map((item: any) => (serializeManagedInstance(item))) : undefined,
  };
}

function deserializeInstanceGroupManagersListManagedInstancesResponse(data: any): InstanceGroupManagersListManagedInstancesResponse {
  return {
    ...data,
    managedInstances: data["managedInstances"] !== undefined ? data["managedInstances"].map((item: any) => (deserializeManagedInstance(item))) : undefined,
  };
}

/**
 * Additional options for Compute#instanceGroupManagersList.
 */
export interface InstanceGroupManagersListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#instanceGroupManagersListPerInstanceConfigs.
 */
export interface InstanceGroupManagersListPerInstanceConfigsOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface InstanceGroupManagersListPerInstanceConfigsResp {
  /**
   * [Output Only] The list of PerInstanceConfig.
   */
  items?: PerInstanceConfig[];
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeInstanceGroupManagersListPerInstanceConfigsResp(data: any): InstanceGroupManagersListPerInstanceConfigsResp {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializePerInstanceConfig(item))) : undefined,
  };
}

function deserializeInstanceGroupManagersListPerInstanceConfigsResp(data: any): InstanceGroupManagersListPerInstanceConfigsResp {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializePerInstanceConfig(item))) : undefined,
  };
}

/**
 * Additional options for Compute#instanceGroupManagersPatch.
 */
export interface InstanceGroupManagersPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instanceGroupManagersPatchPerInstanceConfigs.
 */
export interface InstanceGroupManagersPatchPerInstanceConfigsOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * InstanceGroupManagers.patchPerInstanceConfigs
 */
export interface InstanceGroupManagersPatchPerInstanceConfigsReq {
  /**
   * The list of per-instance configurations to insert or patch on this managed
   * instance group.
   */
  perInstanceConfigs?: PerInstanceConfig[];
}

function serializeInstanceGroupManagersPatchPerInstanceConfigsReq(data: any): InstanceGroupManagersPatchPerInstanceConfigsReq {
  return {
    ...data,
    perInstanceConfigs: data["perInstanceConfigs"] !== undefined ? data["perInstanceConfigs"].map((item: any) => (serializePerInstanceConfig(item))) : undefined,
  };
}

function deserializeInstanceGroupManagersPatchPerInstanceConfigsReq(data: any): InstanceGroupManagersPatchPerInstanceConfigsReq {
  return {
    ...data,
    perInstanceConfigs: data["perInstanceConfigs"] !== undefined ? data["perInstanceConfigs"].map((item: any) => (deserializePerInstanceConfig(item))) : undefined,
  };
}

/**
 * Additional options for Compute#instanceGroupManagersRecreateInstances.
 */
export interface InstanceGroupManagersRecreateInstancesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface InstanceGroupManagersRecreateInstancesRequest {
  /**
   * The URLs of one or more instances to recreate. This can be a full URL or a
   * partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
   */
  instances?: string[];
}

/**
 * Additional options for Compute#instanceGroupManagersResize.
 */
export interface InstanceGroupManagersResizeOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
  /**
   * The number of running instances that the managed instance group should
   * maintain at any given time. The group automatically adds or removes
   * instances to maintain the number of instances specified by this parameter.
   */
  size: number;
}

export interface InstanceGroupManagersScopedList {
  /**
   * [Output Only] The list of managed instance groups that are contained in
   * the specified project and zone.
   */
  instanceGroupManagers?: InstanceGroupManager[];
  /**
   * [Output Only] The warning that replaces the list of managed instance
   * groups when the list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeInstanceGroupManagersScopedList(data: any): InstanceGroupManagersScopedList {
  return {
    ...data,
    instanceGroupManagers: data["instanceGroupManagers"] !== undefined ? data["instanceGroupManagers"].map((item: any) => (serializeInstanceGroupManager(item))) : undefined,
  };
}

function deserializeInstanceGroupManagersScopedList(data: any): InstanceGroupManagersScopedList {
  return {
    ...data,
    instanceGroupManagers: data["instanceGroupManagers"] !== undefined ? data["instanceGroupManagers"].map((item: any) => (deserializeInstanceGroupManager(item))) : undefined,
  };
}

/**
 * Additional options for Compute#instanceGroupManagersSetInstanceTemplate.
 */
export interface InstanceGroupManagersSetInstanceTemplateOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface InstanceGroupManagersSetInstanceTemplateRequest {
  /**
   * The URL of the instance template that is specified for this managed
   * instance group. The group uses this template to create all new instances in
   * the managed instance group. The templates for existing instances in the
   * group do not change unless you run recreateInstances, run
   * applyUpdatesToInstances, or set the group's updatePolicy.type to PROACTIVE.
   */
  instanceTemplate?: string;
}

/**
 * Additional options for Compute#instanceGroupManagersSetTargetPools.
 */
export interface InstanceGroupManagersSetTargetPoolsOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface InstanceGroupManagersSetTargetPoolsRequest {
  /**
   * The fingerprint of the target pools information. Use this optional
   * property to prevent conflicts when multiple users change the target pools
   * settings concurrently. Obtain the fingerprint with the
   * instanceGroupManagers.get method. Then, include the fingerprint in your
   * request to ensure that you do not overwrite changes that were applied from
   * another concurrent request.
   */
  fingerprint?: Uint8Array;
  /**
   * The list of target pool URLs that instances in this managed instance group
   * belong to. The managed instance group applies these target pools to all of
   * the instances in the group. Existing instances and new instances in the
   * group all receive these target pool settings.
   */
  targetPools?: string[];
}

function serializeInstanceGroupManagersSetTargetPoolsRequest(data: any): InstanceGroupManagersSetTargetPoolsRequest {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
  };
}

function deserializeInstanceGroupManagersSetTargetPoolsRequest(data: any): InstanceGroupManagersSetTargetPoolsRequest {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
  };
}

export interface InstanceGroupManagerStatus {
  /**
   * [Output Only] The URL of the Autoscaler that targets this instance group
   * manager.
   */
  autoscaler?: string;
  /**
   * [Output Only] A bit indicating whether the managed instance group is in a
   * stable state. A stable state means that: none of the instances in the
   * managed instance group is currently undergoing any type of change (for
   * example, creation, restart, or deletion); no future changes are scheduled
   * for instances in the managed instance group; and the managed instance group
   * itself is not being modified.
   */
  isStable?: boolean;
  /**
   * [Output Only] Stateful status of the given Instance Group Manager.
   */
  stateful?: InstanceGroupManagerStatusStateful;
  /**
   * [Output Only] A status of consistency of Instances' versions with their
   * target version specified by version field on Instance Group Manager.
   */
  versionTarget?: InstanceGroupManagerStatusVersionTarget;
}

export interface InstanceGroupManagerStatusStateful {
  /**
   * [Output Only] A bit indicating whether the managed instance group has
   * stateful configuration, that is, if you have configured any items in a
   * stateful policy or in per-instance configs. The group might report that it
   * has no stateful configuration even when there is still some preserved state
   * on a managed instance, for example, if you have deleted all PICs but not
   * yet applied those deletions.
   */
  hasStatefulConfig?: boolean;
  /**
   * [Output Only] Status of per-instance configurations on the instance.
   */
  perInstanceConfigs?: InstanceGroupManagerStatusStatefulPerInstanceConfigs;
}

export interface InstanceGroupManagerStatusStatefulPerInstanceConfigs {
  /**
   * A bit indicating if all of the group's per-instance configurations (listed
   * in the output of a listPerInstanceConfigs API call) have status EFFECTIVE
   * or there are no per-instance-configs.
   */
  allEffective?: boolean;
}

export interface InstanceGroupManagerStatusVersionTarget {
  /**
   * [Output Only] A bit indicating whether version target has been reached in
   * this managed instance group, i.e. all instances are in their target
   * version. Instances' target version are specified by version field on
   * Instance Group Manager.
   */
  isReached?: boolean;
}

/**
 * Additional options for
 * Compute#instanceGroupManagersUpdatePerInstanceConfigs.
 */
export interface InstanceGroupManagersUpdatePerInstanceConfigsOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * InstanceGroupManagers.updatePerInstanceConfigs
 */
export interface InstanceGroupManagersUpdatePerInstanceConfigsReq {
  /**
   * The list of per-instance configurations to insert or patch on this managed
   * instance group.
   */
  perInstanceConfigs?: PerInstanceConfig[];
}

function serializeInstanceGroupManagersUpdatePerInstanceConfigsReq(data: any): InstanceGroupManagersUpdatePerInstanceConfigsReq {
  return {
    ...data,
    perInstanceConfigs: data["perInstanceConfigs"] !== undefined ? data["perInstanceConfigs"].map((item: any) => (serializePerInstanceConfig(item))) : undefined,
  };
}

function deserializeInstanceGroupManagersUpdatePerInstanceConfigsReq(data: any): InstanceGroupManagersUpdatePerInstanceConfigsReq {
  return {
    ...data,
    perInstanceConfigs: data["perInstanceConfigs"] !== undefined ? data["perInstanceConfigs"].map((item: any) => (deserializePerInstanceConfig(item))) : undefined,
  };
}

export interface InstanceGroupManagerUpdatePolicy {
  /**
   * The instance redistribution policy for regional managed instance groups.
   * Valid values are: - PROACTIVE (default): The group attempts to maintain an
   * even distribution of VM instances across zones in the region. - NONE: For
   * non-autoscaled groups, proactive redistribution is disabled.
   */
  instanceRedistributionType?:  | "NONE" | "PROACTIVE";
  /**
   * The maximum number of instances that can be created above the specified
   * targetSize during the update process. This value can be either a fixed
   * number or, if the group has 10 or more instances, a percentage. If you set
   * a percentage, the number of instances is rounded if necessary. The default
   * value for maxSurge is a fixed value equal to the number of zones in which
   * the managed instance group operates. At least one of either maxSurge or
   * maxUnavailable must be greater than 0. Learn more about maxSurge.
   */
  maxSurge?: FixedOrPercent;
  /**
   * The maximum number of instances that can be unavailable during the update
   * process. An instance is considered available if all of the following
   * conditions are satisfied: - The instance's status is RUNNING. - If there is
   * a health check on the instance group, the instance's health check status
   * must be HEALTHY at least once. If there is no health check on the group,
   * then the instance only needs to have a status of RUNNING to be considered
   * available. This value can be either a fixed number or, if the group has 10
   * or more instances, a percentage. If you set a percentage, the number of
   * instances is rounded if necessary. The default value for maxUnavailable is
   * a fixed value equal to the number of zones in which the managed instance
   * group operates. At least one of either maxSurge or maxUnavailable must be
   * greater than 0. Learn more about maxUnavailable.
   */
  maxUnavailable?: FixedOrPercent;
  /**
   * Minimal action to be taken on an instance. Use this option to minimize
   * disruption as much as possible or to apply a more disruptive action than is
   * necessary. - To limit disruption as much as possible, set the minimal
   * action to REFRESH. If your update requires a more disruptive action,
   * Compute Engine performs the necessary action to execute the update. - To
   * apply a more disruptive action than is strictly necessary, set the minimal
   * action to RESTART or REPLACE. For example, Compute Engine does not need to
   * restart a VM to change its metadata. But if your application reads instance
   * metadata only when a VM is restarted, you can set the minimal action to
   * RESTART in order to pick up metadata changes.
   */
  minimalAction?:  | "NONE" | "REFRESH" | "REPLACE" | "RESTART";
  /**
   * Most disruptive action that is allowed to be taken on an instance. You can
   * specify either NONE to forbid any actions, REFRESH to allow actions that do
   * not need instance restart, RESTART to allow actions that can be applied
   * without instance replacing or REPLACE to allow all possible actions. If the
   * Updater determines that the minimal update action needed is more disruptive
   * than most disruptive allowed action you specify it will not perform the
   * update at all.
   */
  mostDisruptiveAllowedAction?:  | "NONE" | "REFRESH" | "REPLACE" | "RESTART";
  /**
   * What action should be used to replace instances. See
   * minimal_action.REPLACE
   */
  replacementMethod?:  | "RECREATE" | "SUBSTITUTE";
  /**
   * The type of update process. You can specify either PROACTIVE so that the
   * instance group manager proactively executes actions in order to bring
   * instances to their target versions or OPPORTUNISTIC so that no action is
   * proactively executed but the update will be performed as part of other
   * actions (for example, resizes or recreateInstances calls).
   */
  type?:  | "OPPORTUNISTIC" | "PROACTIVE";
}

export interface InstanceGroupManagerVersion {
  /**
   * The URL of the instance template that is specified for this managed
   * instance group. The group uses this template to create new instances in the
   * managed instance group until the `targetSize` for this version is reached.
   * The templates for existing instances in the group do not change unless you
   * run recreateInstances, run applyUpdatesToInstances, or set the group's
   * updatePolicy.type to PROACTIVE; in those cases, existing instances are
   * updated until the `targetSize` for this version is reached.
   */
  instanceTemplate?: string;
  /**
   * Name of the version. Unique among all versions in the scope of this
   * managed instance group.
   */
  name?: string;
  /**
   * Specifies the intended number of instances to be created from the
   * instanceTemplate. The final number of instances created from the template
   * will be equal to: - If expressed as a fixed number, the minimum of either
   * targetSize.fixed or instanceGroupManager.targetSize is used. - if expressed
   * as a percent, the targetSize would be (targetSize.percent/100 *
   * InstanceGroupManager.targetSize) If there is a remainder, the number is
   * rounded. If unset, this version will update any remaining instances not
   * updated by another version. Read Starting a canary update for more
   * information.
   */
  targetSize?: FixedOrPercent;
}

/**
 * Additional options for Compute#instanceGroupsAddInstances.
 */
export interface InstanceGroupsAddInstancesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface InstanceGroupsAddInstancesRequest {
  /**
   * The list of instances to add to the instance group.
   */
  instances?: InstanceReference[];
}

/**
 * Additional options for Compute#instanceGroupsAggregatedList.
 */
export interface InstanceGroupsAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#instanceGroupsDelete.
 */
export interface InstanceGroupsDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instanceGroupsInsert.
 */
export interface InstanceGroupsInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface InstanceGroupsListInstances {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of InstanceWithNamedPorts resources.
   */
  items?: InstanceWithNamedPorts[];
  /**
   * [Output Only] The resource type, which is always
   * compute#instanceGroupsListInstances for the list of instances in the
   * specified instance group.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

/**
 * Additional options for Compute#instanceGroupsListInstances.
 */
export interface InstanceGroupsListInstancesOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface InstanceGroupsListInstancesRequest {
  /**
   * A filter for the state of the instances in the instance group. Valid
   * options are ALL or RUNNING. If you do not specify this parameter the list
   * includes all instances regardless of their state.
   */
  instanceState?:  | "ALL" | "RUNNING";
}

/**
 * Additional options for Compute#instanceGroupsList.
 */
export interface InstanceGroupsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#instanceGroupsRemoveInstances.
 */
export interface InstanceGroupsRemoveInstancesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface InstanceGroupsRemoveInstancesRequest {
  /**
   * The list of instances to remove from the instance group.
   */
  instances?: InstanceReference[];
}

export interface InstanceGroupsScopedList {
  /**
   * [Output Only] The list of instance groups that are contained in this
   * scope.
   */
  instanceGroups?: InstanceGroup[];
  /**
   * [Output Only] An informational warning that replaces the list of instance
   * groups when the list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeInstanceGroupsScopedList(data: any): InstanceGroupsScopedList {
  return {
    ...data,
    instanceGroups: data["instanceGroups"] !== undefined ? data["instanceGroups"].map((item: any) => (serializeInstanceGroup(item))) : undefined,
  };
}

function deserializeInstanceGroupsScopedList(data: any): InstanceGroupsScopedList {
  return {
    ...data,
    instanceGroups: data["instanceGroups"] !== undefined ? data["instanceGroups"].map((item: any) => (deserializeInstanceGroup(item))) : undefined,
  };
}

/**
 * Additional options for Compute#instanceGroupsSetNamedPorts.
 */
export interface InstanceGroupsSetNamedPortsOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface InstanceGroupsSetNamedPortsRequest {
  /**
   * The fingerprint of the named ports information for this instance group.
   * Use this optional property to prevent conflicts when multiple users change
   * the named ports settings concurrently. Obtain the fingerprint with the
   * instanceGroups.get method. Then, include the fingerprint in your request to
   * ensure that you do not overwrite changes that were applied from another
   * concurrent request. A request with an incorrect fingerprint will fail with
   * error 412 conditionNotMet.
   */
  fingerprint?: Uint8Array;
  /**
   * The list of named ports to set for this instance group.
   */
  namedPorts?: NamedPort[];
}

function serializeInstanceGroupsSetNamedPortsRequest(data: any): InstanceGroupsSetNamedPortsRequest {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
  };
}

function deserializeInstanceGroupsSetNamedPortsRequest(data: any): InstanceGroupsSetNamedPortsRequest {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
  };
}

/**
 * Contains a list of instances.
 */
export interface InstanceList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of Instance resources.
   */
  items?: Instance[];
  /**
   * [Output Only] Type of resource. Always compute#instanceList for lists of
   * Instance resources.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeInstanceList(data: any): InstanceList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeInstance(item))) : undefined,
  };
}

function deserializeInstanceList(data: any): InstanceList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeInstance(item))) : undefined,
  };
}

/**
 * Contains a list of instance referrers.
 */
export interface InstanceListReferrers {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of Reference resources.
   */
  items?: Reference[];
  /**
   * [Output Only] Type of resource. Always compute#instanceListReferrers for
   * lists of Instance referrers.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

export interface InstanceManagedByIgmError {
  /**
   * [Output Only] Contents of the error.
   */
  error?: InstanceManagedByIgmErrorManagedInstanceError;
  /**
   * [Output Only] Details of the instance action that triggered this error.
   * May be null, if the error was not caused by an action on an instance. This
   * field is optional.
   */
  instanceActionDetails?: InstanceManagedByIgmErrorInstanceActionDetails;
  /**
   * [Output Only] The time that this error occurred. This value is in RFC3339
   * text format.
   */
  timestamp?: string;
}

export interface InstanceManagedByIgmErrorInstanceActionDetails {
  /**
   * [Output Only] Action that managed instance group was executing on the
   * instance when the error occurred. Possible values:
   */
  action?:  | "ABANDONING" | "CREATING" | "CREATING_WITHOUT_RETRIES" | "DELETING" | "NONE" | "RECREATING" | "REFRESHING" | "RESTARTING" | "RESUMING" | "STARTING" | "STOPPING" | "SUSPENDING" | "VERIFYING";
  /**
   * [Output Only] The URL of the instance. The URL can be set even if the
   * instance has not yet been created.
   */
  instance?: string;
  /**
   * [Output Only] Version this instance was created from, or was being created
   * from, but the creation failed. Corresponds to one of the versions that were
   * set on the Instance Group Manager resource at the time this instance was
   * being created.
   */
  version?: ManagedInstanceVersion;
}

export interface InstanceManagedByIgmErrorManagedInstanceError {
  /**
   * [Output Only] Error code.
   */
  code?: string;
  /**
   * [Output Only] Error message.
   */
  message?: string;
}

export interface InstanceMoveRequest {
  /**
   * The URL of the destination zone to move the instance. This can be a full
   * or partial URL. For example, the following are all valid URLs to a zone: -
   * https://www.googleapis.com/compute/v1/projects/project/zones/zone -
   * projects/project/zones/zone - zones/zone
   */
  destinationZone?: string;
  /**
   * The URL of the target instance to move. This can be a full or partial URL.
   * For example, the following are all valid URLs to an instance: -
   * https://www.googleapis.com/compute/v1/projects/project/zones/zone
   * /instances/instance - projects/project/zones/zone/instances/instance -
   * zones/zone/instances/instance
   */
  targetInstance?: string;
}

/**
 * Additional instance params.
 */
export interface InstanceParams {
  /**
   * Resource manager tags to be bound to the instance. Tag keys and values
   * have the same definition as resource manager tags. Keys must be in the
   * format `tagKeys/{tag_key_id}`, and values are in the format
   * `tagValues/456`. The field is ignored (both PUT & PATCH) when empty.
   */
  resourceManagerTags?: {
    [key: string]: string
  };
}

export interface InstanceProperties {
  /**
   * Controls for advanced machine-related behavior features. Note that for
   * MachineImage, this is not supported yet.
   */
  advancedMachineFeatures?: AdvancedMachineFeatures;
  /**
   * Enables instances created based on these properties to send packets with
   * source IP addresses other than their own and receive packets with
   * destination IP addresses other than their own. If these instances will be
   * used as an IP gateway or it will be set as the next-hop in a Route
   * resource, specify true. If unsure, leave this set to false. See the Enable
   * IP forwarding documentation for more information.
   */
  canIpForward?: boolean;
  /**
   * Specifies the Confidential Instance options. Note that for MachineImage,
   * this is not supported yet.
   */
  confidentialInstanceConfig?: ConfidentialInstanceConfig;
  /**
   * An optional text description for the instances that are created from these
   * properties.
   */
  description?: string;
  /**
   * An array of disks that are associated with the instances that are created
   * from these properties.
   */
  disks?: AttachedDisk[];
  /**
   * A list of guest accelerator cards' type and count to use for instances
   * created from these properties.
   */
  guestAccelerators?: AcceleratorConfig[];
  /**
   * KeyRevocationActionType of the instance. Supported options are "STOP" and
   * "NONE". The default value is "NONE" if it is not specified.
   */
  keyRevocationActionType?:  | "KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED" | "NONE" | "STOP";
  /**
   * Labels to apply to instances that are created from these properties.
   */
  labels?: {
    [key: string]: string
  };
  /**
   * The machine type to use for instances that are created from these
   * properties.
   */
  machineType?: string;
  /**
   * The metadata key/value pairs to assign to instances that are created from
   * these properties. These pairs can consist of custom metadata or predefined
   * keys. See Project and instance metadata for more information.
   */
  metadata?: Metadata;
  /**
   * Minimum cpu/platform to be used by instances. The instance may be
   * scheduled on the specified or newer cpu/platform. Applicable values are the
   * friendly names of CPU platforms, such as minCpuPlatform: "Intel Haswell" or
   * minCpuPlatform: "Intel Sandy Bridge". For more information, read Specifying
   * a Minimum CPU Platform.
   */
  minCpuPlatform?: string;
  /**
   * An array of network access configurations for this interface.
   */
  networkInterfaces?: NetworkInterface[];
  /**
   * Note that for MachineImage, this is not supported yet.
   */
  networkPerformanceConfig?: NetworkPerformanceConfig;
  /**
   * The private IPv6 google access type for VMs. If not specified, use
   * INHERIT_FROM_SUBNETWORK as default. Note that for MachineImage, this is not
   * supported yet.
   */
  privateIpv6GoogleAccess?:  | "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE" | "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE" | "INHERIT_FROM_SUBNETWORK";
  /**
   * Specifies the reservations that instances can consume from. Note that for
   * MachineImage, this is not supported yet.
   */
  reservationAffinity?: ReservationAffinity;
  /**
   * Resource manager tags to be bound to the instance. Tag keys and values
   * have the same definition as resource manager tags. Keys must be in the
   * format `tagKeys/{tag_key_id}`, and values are in the format
   * `tagValues/456`. The field is ignored (both PUT & PATCH) when empty.
   */
  resourceManagerTags?: {
    [key: string]: string
  };
  /**
   * Resource policies (names, not URLs) applied to instances created from
   * these properties. Note that for MachineImage, this is not supported yet.
   */
  resourcePolicies?: string[];
  /**
   * Specifies the scheduling options for the instances that are created from
   * these properties.
   */
  scheduling?: Scheduling;
  /**
   * A list of service accounts with specified scopes. Access tokens for these
   * service accounts are available to the instances that are created from these
   * properties. Use metadata queries to obtain the access tokens for these
   * instances.
   */
  serviceAccounts?: ServiceAccount[];
  /**
   * Note that for MachineImage, this is not supported yet.
   */
  shieldedInstanceConfig?: ShieldedInstanceConfig;
  /**
   * A list of tags to apply to the instances that are created from these
   * properties. The tags identify valid sources or targets for network
   * firewalls. The setTags method can modify this list of tags. Each tag within
   * the list must comply with RFC1035.
   */
  tags?: Tags;
}

function serializeInstanceProperties(data: any): InstanceProperties {
  return {
    ...data,
    disks: data["disks"] !== undefined ? data["disks"].map((item: any) => (serializeAttachedDisk(item))) : undefined,
    metadata: data["metadata"] !== undefined ? serializeMetadata(data["metadata"]) : undefined,
    networkInterfaces: data["networkInterfaces"] !== undefined ? data["networkInterfaces"].map((item: any) => (serializeNetworkInterface(item))) : undefined,
    tags: data["tags"] !== undefined ? serializeTags(data["tags"]) : undefined,
  };
}

function deserializeInstanceProperties(data: any): InstanceProperties {
  return {
    ...data,
    disks: data["disks"] !== undefined ? data["disks"].map((item: any) => (deserializeAttachedDisk(item))) : undefined,
    metadata: data["metadata"] !== undefined ? deserializeMetadata(data["metadata"]) : undefined,
    networkInterfaces: data["networkInterfaces"] !== undefined ? data["networkInterfaces"].map((item: any) => (deserializeNetworkInterface(item))) : undefined,
    tags: data["tags"] !== undefined ? deserializeTags(data["tags"]) : undefined,
  };
}

export interface InstanceReference {
  /**
   * The URL for a specific instance. @required
   * compute.instancegroups.addInstances/removeInstances
   */
  instance?: string;
}

/**
 * Additional options for Compute#instancesAddAccessConfig.
 */
export interface InstancesAddAccessConfigOptions {
  /**
   * The name of the network interface to add to this instance.
   */
  networkInterface: string;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instancesAddResourcePolicies.
 */
export interface InstancesAddResourcePoliciesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface InstancesAddResourcePoliciesRequest {
  /**
   * Resource policies to be added to this instance.
   */
  resourcePolicies?: string[];
}

/**
 * Additional options for Compute#instancesAggregatedList.
 */
export interface InstancesAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#instancesAttachDisk.
 */
export interface InstancesAttachDiskOptions {
  /**
   * Whether to force attach the regional disk even if it's currently attached
   * to another instance. If you try to force attach a zonal disk to an
   * instance, you will receive an error.
   */
  forceAttach?: boolean;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instancesBulkInsert.
 */
export interface InstancesBulkInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instancesDeleteAccessConfig.
 */
export interface InstancesDeleteAccessConfigOptions {
  /**
   * The name of the access config to delete.
   */
  accessConfig: string;
  /**
   * The name of the network interface.
   */
  networkInterface: string;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instancesDelete.
 */
export interface InstancesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instancesDetachDisk.
 */
export interface InstancesDetachDiskOptions {
  /**
   * The device name of the disk to detach. Make a get() request on the
   * instance to view currently attached disks and device names.
   */
  deviceName: string;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instancesGetEffectiveFirewalls.
 */
export interface InstancesGetEffectiveFirewallsOptions {
  /**
   * The name of the network interface to get the effective firewalls.
   */
  networkInterface: string;
}

export interface InstancesGetEffectiveFirewallsResponse {
  /**
   * Effective firewalls from firewall policies.
   */
  firewallPolicys?: InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy[];
  /**
   * Effective firewalls on the instance.
   */
  firewalls?: Firewall[];
}

function serializeInstancesGetEffectiveFirewallsResponse(data: any): InstancesGetEffectiveFirewallsResponse {
  return {
    ...data,
    firewalls: data["firewalls"] !== undefined ? data["firewalls"].map((item: any) => (serializeFirewall(item))) : undefined,
  };
}

function deserializeInstancesGetEffectiveFirewallsResponse(data: any): InstancesGetEffectiveFirewallsResponse {
  return {
    ...data,
    firewalls: data["firewalls"] !== undefined ? data["firewalls"].map((item: any) => (deserializeFirewall(item))) : undefined,
  };
}

export interface InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy {
  /**
   * [Output Only] Deprecated, please use short name instead. The display name
   * of the firewall policy.
   */
  displayName?: string;
  /**
   * [Output Only] The name of the firewall policy.
   */
  name?: string;
  /**
   * The rules that apply to the network.
   */
  rules?: FirewallPolicyRule[];
  /**
   * [Output Only] The short name of the firewall policy.
   */
  shortName?: string;
  /**
   * [Output Only] The type of the firewall policy. Can be one of HIERARCHY,
   * NETWORK, NETWORK_REGIONAL.
   */
  type?:  | "HIERARCHY" | "NETWORK" | "NETWORK_REGIONAL" | "UNSPECIFIED";
}

/**
 * Additional options for Compute#instancesGetGuestAttributes.
 */
export interface InstancesGetGuestAttributesOptions {
  /**
   * Specifies the guest attributes path to be queried.
   */
  queryPath?: string;
  /**
   * Specifies the key for the guest attributes entry.
   */
  variableKey?: string;
}

/**
 * Additional options for Compute#instancesGetIamPolicy.
 */
export interface InstancesGetIamPolicyOptions {
  /**
   * Requested IAM Policy version.
   */
  optionsRequestedPolicyVersion?: number;
}

/**
 * Additional options for Compute#instancesGetSerialPortOutput.
 */
export interface InstancesGetSerialPortOutputOptions {
  /**
   * Specifies which COM or serial port to retrieve data from.
   */
  port?: number;
  /**
   * Specifies the starting byte position of the output to return. To start
   * with the first byte of output to the specified port, omit this field or set
   * it to `0`. If the output for that byte position is available, this field
   * matches the `start` parameter sent with the request. If the amount of
   * serial console output exceeds the size of the buffer (1 MB), the oldest
   * output is discarded and is no longer available. If the requested start
   * position refers to discarded output, the start position is adjusted to the
   * oldest output still available, and the adjusted start position is returned
   * as the `start` property value. You can also provide a negative start
   * position, which translates to the most recent number of bytes written to
   * the serial port. For example, -3 is interpreted as the most recent 3 bytes
   * written to the serial console.
   */
  start?: bigint;
}

function serializeInstancesGetSerialPortOutputOptions(data: any): InstancesGetSerialPortOutputOptions {
  return {
    ...data,
    start: data["start"] !== undefined ? String(data["start"]) : undefined,
  };
}

function deserializeInstancesGetSerialPortOutputOptions(data: any): InstancesGetSerialPortOutputOptions {
  return {
    ...data,
    start: data["start"] !== undefined ? BigInt(data["start"]) : undefined,
  };
}

/**
 * Additional options for Compute#instancesInsert.
 */
export interface InstancesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
  /**
   * Specifies instance template to create the instance. This field is
   * optional. It can be a full or partial URL. For example, the following are
   * all valid URLs to an instance template: -
   * https://www.googleapis.com/compute/v1/projects/project
   * /global/instanceTemplates/instanceTemplate -
   * projects/project/global/instanceTemplates/instanceTemplate -
   * global/instanceTemplates/instanceTemplate
   */
  sourceInstanceTemplate?: string;
  /**
   * Specifies the machine image to use to create the instance. This field is
   * optional. It can be a full or partial URL. For example, the following are
   * all valid URLs to a machine image: -
   * https://www.googleapis.com/compute/v1/projects/project/global/global
   * /machineImages/machineImage -
   * projects/project/global/global/machineImages/machineImage -
   * global/machineImages/machineImage
   */
  sourceMachineImage?: string;
}

/**
 * Additional options for Compute#instancesList.
 */
export interface InstancesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#instancesListReferrers.
 */
export interface InstancesListReferrersOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#instancesRemoveResourcePolicies.
 */
export interface InstancesRemoveResourcePoliciesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface InstancesRemoveResourcePoliciesRequest {
  /**
   * Resource policies to be removed from this instance.
   */
  resourcePolicies?: string[];
}

/**
 * Additional options for Compute#instancesReset.
 */
export interface InstancesResetOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instancesResume.
 */
export interface InstancesResumeOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface InstancesScopedList {
  /**
   * [Output Only] A list of instances contained in this scope.
   */
  instances?: Instance[];
  /**
   * [Output Only] Informational warning which replaces the list of instances
   * when the list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeInstancesScopedList(data: any): InstancesScopedList {
  return {
    ...data,
    instances: data["instances"] !== undefined ? data["instances"].map((item: any) => (serializeInstance(item))) : undefined,
  };
}

function deserializeInstancesScopedList(data: any): InstancesScopedList {
  return {
    ...data,
    instances: data["instances"] !== undefined ? data["instances"].map((item: any) => (deserializeInstance(item))) : undefined,
  };
}

/**
 * Additional options for Compute#instancesSetDeletionProtection.
 */
export interface InstancesSetDeletionProtectionOptions {
  /**
   * Whether the resource should be protected against deletion.
   */
  deletionProtection?: boolean;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instancesSetDiskAutoDelete.
 */
export interface InstancesSetDiskAutoDeleteOptions {
  /**
   * Whether to auto-delete the disk when the instance is deleted.
   */
  autoDelete: boolean;
  /**
   * The device name of the disk to modify. Make a get() request on the
   * instance to view currently attached disks and device names.
   */
  deviceName: string;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instancesSetLabels.
 */
export interface InstancesSetLabelsOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface InstancesSetLabelsRequest {
  /**
   * Fingerprint of the previous set of labels for this resource, used to
   * prevent conflicts. Provide the latest fingerprint value when making a
   * request to add or change labels.
   */
  labelFingerprint?: Uint8Array;
  labels?: {
    [key: string]: string
  };
}

function serializeInstancesSetLabelsRequest(data: any): InstancesSetLabelsRequest {
  return {
    ...data,
    labelFingerprint: data["labelFingerprint"] !== undefined ? encodeBase64(data["labelFingerprint"]) : undefined,
  };
}

function deserializeInstancesSetLabelsRequest(data: any): InstancesSetLabelsRequest {
  return {
    ...data,
    labelFingerprint: data["labelFingerprint"] !== undefined ? decodeBase64(data["labelFingerprint"] as string) : undefined,
  };
}

/**
 * Additional options for Compute#instancesSetMachineResources.
 */
export interface InstancesSetMachineResourcesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface InstancesSetMachineResourcesRequest {
  /**
   * A list of the type and count of accelerator cards attached to the
   * instance.
   */
  guestAccelerators?: AcceleratorConfig[];
}

/**
 * Additional options for Compute#instancesSetMachineType.
 */
export interface InstancesSetMachineTypeOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface InstancesSetMachineTypeRequest {
  /**
   * Full or partial URL of the machine type resource. See Machine Types for a
   * full list of machine types. For example:
   * zones/us-central1-f/machineTypes/n1-standard-1
   */
  machineType?: string;
}

/**
 * Additional options for Compute#instancesSetMetadata.
 */
export interface InstancesSetMetadataOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instancesSetMinCpuPlatform.
 */
export interface InstancesSetMinCpuPlatformOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface InstancesSetMinCpuPlatformRequest {
  /**
   * Minimum cpu/platform this instance should be started at.
   */
  minCpuPlatform?: string;
}

/**
 * Additional options for Compute#instancesSetName.
 */
export interface InstancesSetNameOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface InstancesSetNameRequest {
  /**
   * The current name of this resource, used to prevent conflicts. Provide the
   * latest name when making a request to change name.
   */
  currentName?: string;
  /**
   * The name to be applied to the instance. Needs to be RFC 1035 compliant.
   */
  name?: string;
}

/**
 * Additional options for Compute#instancesSetScheduling.
 */
export interface InstancesSetSchedulingOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instancesSetServiceAccount.
 */
export interface InstancesSetServiceAccountOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface InstancesSetServiceAccountRequest {
  /**
   * Email address of the service account.
   */
  email?: string;
  /**
   * The list of scopes to be made available for this service account.
   */
  scopes?: string[];
}

/**
 * Additional options for Compute#instancesSetShieldedInstanceIntegrityPolicy.
 */
export interface InstancesSetShieldedInstanceIntegrityPolicyOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instancesSetTags.
 */
export interface InstancesSetTagsOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instancesStart.
 */
export interface InstancesStartOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instancesStartWithEncryptionKey.
 */
export interface InstancesStartWithEncryptionKeyOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface InstancesStartWithEncryptionKeyRequest {
  /**
   * Array of disks associated with this instance that are protected with a
   * customer-supplied encryption key. In order to start the instance, the disk
   * url and its corresponding key must be provided. If the disk is not
   * protected with a customer-supplied encryption key it should not be
   * specified.
   */
  disks?: CustomerEncryptionKeyProtectedDisk[];
}

/**
 * Additional options for Compute#instancesStop.
 */
export interface InstancesStopOptions {
  /**
   * If true, discard the contents of any attached localSSD partitions. Default
   * value is false.
   */
  discardLocalSsd?: boolean;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instancesSuspend.
 */
export interface InstancesSuspendOptions {
  /**
   * If true, discard the contents of any attached localSSD partitions. Default
   * value is false.
   */
  discardLocalSsd?: boolean;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instancesUpdateAccessConfig.
 */
export interface InstancesUpdateAccessConfigOptions {
  /**
   * The name of the network interface where the access config is attached.
   */
  networkInterface: string;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instancesUpdateDisplayDevice.
 */
export interface InstancesUpdateDisplayDeviceOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instancesUpdateNetworkInterface.
 */
export interface InstancesUpdateNetworkInterfaceOptions {
  /**
   * The name of the network interface to update.
   */
  networkInterface: string;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instancesUpdate.
 */
export interface InstancesUpdateOptions {
  /**
   * Specifies the action to take when updating an instance even if the updated
   * properties do not require it. If not specified, then Compute Engine acts
   * based on the minimum action that the updated properties require.
   */
  minimalAction?:  | "INVALID" | "NO_EFFECT" | "REFRESH" | "RESTART";
  /**
   * Specifies the most disruptive action that can be taken on the instance as
   * part of the update. Compute Engine returns an error if the instance
   * properties require a more disruptive action as part of the instance update.
   * Valid options from lowest to highest are NO_EFFECT, REFRESH, and RESTART.
   */
  mostDisruptiveAllowedAction?:  | "INVALID" | "NO_EFFECT" | "REFRESH" | "RESTART";
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instancesUpdateShieldedInstanceConfig.
 */
export interface InstancesUpdateShieldedInstanceConfigOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Represents an Instance Template resource. You can use instance templates to
 * create VM instances and managed instance groups. For more information, read
 * Instance Templates.
 */
export interface InstanceTemplate {
  /**
   * [Output Only] The creation timestamp for this instance template in RFC3339
   * text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * [Output Only] A unique identifier for this instance template. The server
   * defines this identifier.
   */
  id?: bigint;
  /**
   * [Output Only] The resource type, which is always compute#instanceTemplate
   * for instance templates.
   */
  kind?: string;
  /**
   * Name of the resource; provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * The instance properties for this instance template.
   */
  properties?: InstanceProperties;
  /**
   * [Output Only] URL of the region where the instance template resides. Only
   * applicable for regional resources.
   */
  region?: string;
  /**
   * [Output Only] The URL for this instance template. The server defines this
   * URL.
   */
  selfLink?: string;
  /**
   * The source instance used to create the template. You can provide this as a
   * partial or full URL to the resource. For example, the following are valid
   * values: - https://www.googleapis.com/compute/v1/projects/project/zones/zone
   * /instances/instance - projects/project/zones/zone/instances/instance
   */
  sourceInstance?: string;
  /**
   * The source instance params to use to create this instance template.
   */
  sourceInstanceParams?: SourceInstanceParams;
}

function serializeInstanceTemplate(data: any): InstanceTemplate {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
    properties: data["properties"] !== undefined ? serializeInstanceProperties(data["properties"]) : undefined,
  };
}

function deserializeInstanceTemplate(data: any): InstanceTemplate {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
    properties: data["properties"] !== undefined ? deserializeInstanceProperties(data["properties"]) : undefined,
  };
}

/**
 * Contains a list of InstanceTemplatesScopedList.
 */
export interface InstanceTemplateAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of InstanceTemplatesScopedList resources.
   */
  items?: {
    [key: string]: InstanceTemplatesScopedList
  };
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeInstanceTemplateAggregatedList(data: any): InstanceTemplateAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeInstanceTemplatesScopedList(v)]))) : undefined,
  };
}

function deserializeInstanceTemplateAggregatedList(data: any): InstanceTemplateAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeInstanceTemplatesScopedList(v)]))) : undefined,
  };
}

/**
 * A list of instance templates.
 */
export interface InstanceTemplateList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of InstanceTemplate resources.
   */
  items?: InstanceTemplate[];
  /**
   * [Output Only] The resource type, which is always
   * compute#instanceTemplatesListResponse for instance template lists.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeInstanceTemplateList(data: any): InstanceTemplateList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeInstanceTemplate(item))) : undefined,
  };
}

function deserializeInstanceTemplateList(data: any): InstanceTemplateList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeInstanceTemplate(item))) : undefined,
  };
}

/**
 * Additional options for Compute#instanceTemplatesAggregatedList.
 */
export interface InstanceTemplatesAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#instanceTemplatesDelete.
 */
export interface InstanceTemplatesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instanceTemplatesGetIamPolicy.
 */
export interface InstanceTemplatesGetIamPolicyOptions {
  /**
   * Requested IAM Policy version.
   */
  optionsRequestedPolicyVersion?: number;
}

/**
 * Additional options for Compute#instanceTemplatesInsert.
 */
export interface InstanceTemplatesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#instanceTemplatesList.
 */
export interface InstanceTemplatesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface InstanceTemplatesScopedList {
  /**
   * [Output Only] A list of instance templates that are contained within the
   * specified project and zone.
   */
  instanceTemplates?: InstanceTemplate[];
  /**
   * [Output Only] An informational warning that replaces the list of instance
   * templates when the list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeInstanceTemplatesScopedList(data: any): InstanceTemplatesScopedList {
  return {
    ...data,
    instanceTemplates: data["instanceTemplates"] !== undefined ? data["instanceTemplates"].map((item: any) => (serializeInstanceTemplate(item))) : undefined,
  };
}

function deserializeInstanceTemplatesScopedList(data: any): InstanceTemplatesScopedList {
  return {
    ...data,
    instanceTemplates: data["instanceTemplates"] !== undefined ? data["instanceTemplates"].map((item: any) => (deserializeInstanceTemplate(item))) : undefined,
  };
}

export interface InstanceWithNamedPorts {
  /**
   * [Output Only] The URL of the instance.
   */
  instance?: string;
  /**
   * [Output Only] The named ports that belong to this instance group.
   */
  namedPorts?: NamedPort[];
  /**
   * [Output Only] The status of the instance.
   */
  status?:  | "DEPROVISIONING" | "PROVISIONING" | "REPAIRING" | "RUNNING" | "STAGING" | "STOPPED" | "STOPPING" | "SUSPENDED" | "SUSPENDING" | "TERMINATED";
}

/**
 * HttpRouteRuleMatch criteria for field values that must stay within the
 * specified integer range.
 */
export interface Int64RangeMatch {
  /**
   * The end of the range (exclusive) in signed long integer format.
   */
  rangeEnd?: bigint;
  /**
   * The start of the range (inclusive) in signed long integer format.
   */
  rangeStart?: bigint;
}

function serializeInt64RangeMatch(data: any): Int64RangeMatch {
  return {
    ...data,
    rangeEnd: data["rangeEnd"] !== undefined ? String(data["rangeEnd"]) : undefined,
    rangeStart: data["rangeStart"] !== undefined ? String(data["rangeStart"]) : undefined,
  };
}

function deserializeInt64RangeMatch(data: any): Int64RangeMatch {
  return {
    ...data,
    rangeEnd: data["rangeEnd"] !== undefined ? BigInt(data["rangeEnd"]) : undefined,
    rangeStart: data["rangeStart"] !== undefined ? BigInt(data["rangeStart"]) : undefined,
  };
}

/**
 * Represents an Interconnect resource. An Interconnect resource is a dedicated
 * connection between the GCP network and your on-premises network. For more
 * information, read the Dedicated Interconnect Overview.
 */
export interface Interconnect {
  /**
   * Administrative status of the interconnect. When this is set to true, the
   * Interconnect is functional and can carry traffic. When set to false, no
   * packets can be carried over the interconnect and no BGP routes are
   * exchanged over it. By default, the status is set to true.
   */
  adminEnabled?: boolean;
  /**
   * [Output Only] A list of CircuitInfo objects, that describe the individual
   * circuits in this LAG.
   */
  circuitInfos?: InterconnectCircuitInfo[];
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * Customer name, to put in the Letter of Authorization as the party
   * authorized to request a crossconnect.
   */
  customerName?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * [Output Only] A list of outages expected for this Interconnect.
   */
  expectedOutages?: InterconnectOutageNotification[];
  /**
   * [Output Only] IP address configured on the Google side of the Interconnect
   * link. This can be used only for ping tests.
   */
  googleIpAddress?: string;
  /**
   * [Output Only] Google reference ID to be used when raising support tickets
   * with Google or otherwise to debug backend connectivity issues.
   */
  googleReferenceId?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] A list of the URLs of all InterconnectAttachments configured
   * to use this Interconnect.
   */
  interconnectAttachments?: string[];
  /**
   * Type of interconnect, which can take one of the following values: -
   * PARTNER: A partner-managed interconnection shared between customers though
   * a partner. - DEDICATED: A dedicated physical interconnection with the
   * customer. Note that a value IT_PRIVATE has been deprecated in favor of
   * DEDICATED.
   */
  interconnectType?:  | "DEDICATED" | "IT_PRIVATE" | "PARTNER";
  /**
   * [Output Only] Type of the resource. Always compute#interconnect for
   * interconnects.
   */
  kind?: string;
  /**
   * Type of link requested, which can take one of the following values: -
   * LINK_TYPE_ETHERNET_10G_LR: A 10G Ethernet with LR optics -
   * LINK_TYPE_ETHERNET_100G_LR: A 100G Ethernet with LR optics. Note that this
   * field indicates the speed of each of the links in the bundle, not the speed
   * of the entire bundle.
   */
  linkType?:  | "LINK_TYPE_ETHERNET_100G_LR" | "LINK_TYPE_ETHERNET_10G_LR";
  /**
   * URL of the InterconnectLocation object that represents where this
   * connection is to be provisioned.
   */
  location?: string;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * Email address to contact the customer NOC for operations and maintenance
   * notifications regarding this Interconnect. If specified, this will be used
   * for notifications in addition to all other forms described, such as Cloud
   * Monitoring logs alerting and Cloud Notifications. This field is required
   * for users who sign up for Cloud Interconnect using workforce identity
   * federation.
   */
  nocContactEmail?: string;
  /**
   * [Output Only] The current status of this Interconnect's functionality,
   * which can take one of the following values: - OS_ACTIVE: A valid
   * Interconnect, which is turned up and is ready to use. Attachments may be
   * provisioned on this Interconnect. - OS_UNPROVISIONED: An Interconnect that
   * has not completed turnup. No attachments may be provisioned on this
   * Interconnect. - OS_UNDER_MAINTENANCE: An Interconnect that is undergoing
   * internal maintenance. No attachments may be provisioned or updated on this
   * Interconnect.
   */
  operationalStatus?:  | "OS_ACTIVE" | "OS_UNPROVISIONED";
  /**
   * [Output Only] IP address configured on the customer side of the
   * Interconnect link. The customer should configure this IP address during
   * turnup when prompted by Google NOC. This can be used only for ping tests.
   */
  peerIpAddress?: string;
  /**
   * [Output Only] Number of links actually provisioned in this interconnect.
   */
  provisionedLinkCount?: number;
  /**
   * Target number of physical links in the link bundle, as requested by the
   * customer.
   */
  requestedLinkCount?: number;
  /**
   * [Output Only] Reserved for future use.
   */
  satisfiesPzs?: boolean;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * [Output Only] The current state of Interconnect functionality, which can
   * take one of the following values: - ACTIVE: The Interconnect is valid,
   * turned up and ready to use. Attachments may be provisioned on this
   * Interconnect. - UNPROVISIONED: The Interconnect has not completed turnup.
   * No attachments may be provisioned on this Interconnect. -
   * UNDER_MAINTENANCE: The Interconnect is undergoing internal maintenance. No
   * attachments may be provisioned or updated on this Interconnect.
   */
  state?:  | "ACTIVE" | "UNPROVISIONED";
}

function serializeInterconnect(data: any): Interconnect {
  return {
    ...data,
    expectedOutages: data["expectedOutages"] !== undefined ? data["expectedOutages"].map((item: any) => (serializeInterconnectOutageNotification(item))) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeInterconnect(data: any): Interconnect {
  return {
    ...data,
    expectedOutages: data["expectedOutages"] !== undefined ? data["expectedOutages"].map((item: any) => (deserializeInterconnectOutageNotification(item))) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

/**
 * Represents an Interconnect Attachment (VLAN) resource. You can use
 * Interconnect attachments (VLANS) to connect your Virtual Private Cloud
 * networks to your on-premises networks through an Interconnect. For more
 * information, read Creating VLAN Attachments.
 */
export interface InterconnectAttachment {
  /**
   * Determines whether this Attachment will carry packets. Not present for
   * PARTNER_PROVIDER.
   */
  adminEnabled?: boolean;
  /**
   * Provisioned bandwidth capacity for the interconnect attachment. For
   * attachments of type DEDICATED, the user can set the bandwidth. For
   * attachments of type PARTNER, the Google Partner that is operating the
   * interconnect must set the bandwidth. Output only for PARTNER type, mutable
   * for PARTNER_PROVIDER and DEDICATED, and can take one of the following
   * values: - BPS_50M: 50 Mbit/s - BPS_100M: 100 Mbit/s - BPS_200M: 200 Mbit/s
   * - BPS_300M: 300 Mbit/s - BPS_400M: 400 Mbit/s - BPS_500M: 500 Mbit/s -
   * BPS_1G: 1 Gbit/s - BPS_2G: 2 Gbit/s - BPS_5G: 5 Gbit/s - BPS_10G: 10 Gbit/s
   * - BPS_20G: 20 Gbit/s - BPS_50G: 50 Gbit/s
   */
  bandwidth?:  | "BPS_100M" | "BPS_10G" | "BPS_1G" | "BPS_200M" | "BPS_20G" | "BPS_2G" | "BPS_300M" | "BPS_400M" | "BPS_500M" | "BPS_50G" | "BPS_50M" | "BPS_5G";
  /**
   * This field is not available.
   */
  candidateIpv6Subnets?: string[];
  /**
   * Up to 16 candidate prefixes that can be used to restrict the allocation of
   * cloudRouterIpAddress and customerRouterIpAddress for this attachment. All
   * prefixes must be within link-local address space (169.254.0.0/16) and must
   * be /29 or shorter (/28, /27, etc). Google will attempt to select an unused
   * /29 from the supplied candidate prefix(es). The request will fail if all
   * possible /29s are in use on Google's edge. If not supplied, Google will
   * randomly select an unused /29 from all of link-local space.
   */
  candidateSubnets?: string[];
  /**
   * [Output Only] IPv4 address + prefix length to be configured on Cloud
   * Router Interface for this interconnect attachment.
   */
  cloudRouterIpAddress?: string;
  /**
   * [Output Only] IPv6 address + prefix length to be configured on Cloud
   * Router Interface for this interconnect attachment.
   */
  cloudRouterIpv6Address?: string;
  /**
   * This field is not available.
   */
  cloudRouterIpv6InterfaceId?: string;
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * [Output Only] IPv4 address + prefix length to be configured on the
   * customer router subinterface for this interconnect attachment.
   */
  customerRouterIpAddress?: string;
  /**
   * [Output Only] IPv6 address + prefix length to be configured on the
   * customer router subinterface for this interconnect attachment.
   */
  customerRouterIpv6Address?: string;
  /**
   * This field is not available.
   */
  customerRouterIpv6InterfaceId?: string;
  /**
   * [Output Only] Dataplane version for this InterconnectAttachment. This
   * field is only present for Dataplane version 2 and higher. Absence of this
   * field in the API output indicates that the Dataplane is version 1.
   */
  dataplaneVersion?: number;
  /**
   * An optional description of this resource.
   */
  description?: string;
  /**
   * Desired availability domain for the attachment. Only available for type
   * PARTNER, at creation time, and can take one of the following values: -
   * AVAILABILITY_DOMAIN_ANY - AVAILABILITY_DOMAIN_1 - AVAILABILITY_DOMAIN_2 For
   * improved reliability, customers should configure a pair of attachments, one
   * per availability domain. The selected availability domain will be provided
   * to the Partner via the pairing key, so that the provisioned circuit will
   * lie in the specified domain. If not specified, the value will default to
   * AVAILABILITY_DOMAIN_ANY.
   */
  edgeAvailabilityDomain?:  | "AVAILABILITY_DOMAIN_1" | "AVAILABILITY_DOMAIN_2" | "AVAILABILITY_DOMAIN_ANY";
  /**
   * Indicates the user-supplied encryption option of this VLAN attachment
   * (interconnectAttachment). Can only be specified at attachment creation for
   * PARTNER or DEDICATED attachments. Possible values are: - NONE - This is the
   * default value, which means that the VLAN attachment carries unencrypted
   * traffic. VMs are able to send traffic to, or receive traffic from, such a
   * VLAN attachment. - IPSEC - The VLAN attachment carries only encrypted
   * traffic that is encrypted by an IPsec device, such as an HA VPN gateway or
   * third-party IPsec VPN. VMs cannot directly send traffic to, or receive
   * traffic from, such a VLAN attachment. To use *HA VPN over Cloud
   * Interconnect*, the VLAN attachment must be created with this option.
   */
  encryption?:  | "IPSEC" | "NONE";
  /**
   * [Output Only] Google reference ID, to be used when raising support tickets
   * with Google or otherwise to debug backend connectivity issues. [Deprecated]
   * This field is not used.
   */
  googleReferenceId?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * URL of the underlying Interconnect object that this attachment's traffic
   * will traverse through.
   */
  interconnect?: string;
  /**
   * A list of URLs of addresses that have been reserved for the VLAN
   * attachment. Used only for the VLAN attachment that has the encryption
   * option as IPSEC. The addresses must be regional internal IP address ranges.
   * When creating an HA VPN gateway over the VLAN attachment, if the attachment
   * is configured to use a regional internal IP address, then the VPN gateway's
   * IP address is allocated from the IP address range specified here. For
   * example, if the HA VPN gateway's interface 0 is paired to this VLAN
   * attachment, then a regional internal IP address for the VPN gateway
   * interface 0 will be allocated from the IP address specified for this VLAN
   * attachment. If this field is not specified when creating the VLAN
   * attachment, then later on when creating an HA VPN gateway on this VLAN
   * attachment, the HA VPN gateway's IP address is allocated from the regional
   * external IP address pool. Not currently available publicly.
   */
  ipsecInternalAddresses?: string[];
  /**
   * [Output Only] Type of the resource. Always compute#interconnectAttachment
   * for interconnect attachments.
   */
  kind?: string;
  /**
   * Maximum Transmission Unit (MTU), in bytes, of packets passing through this
   * interconnect attachment. Only 1440 and 1500 are allowed. If not specified,
   * the value will default to 1440.
   */
  mtu?: number;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * [Output Only] The current status of whether or not this interconnect
   * attachment is functional, which can take one of the following values: -
   * OS_ACTIVE: The attachment has been turned up and is ready to use. -
   * OS_UNPROVISIONED: The attachment is not ready to use yet, because turnup is
   * not complete.
   */
  operationalStatus?:  | "OS_ACTIVE" | "OS_UNPROVISIONED";
  /**
   * [Output only for type PARTNER. Input only for PARTNER_PROVIDER. Not
   * present for DEDICATED]. The opaque identifier of an PARTNER attachment used
   * to initiate provisioning with a selected partner. Of the form
   * "XXXXX/region/domain"
   */
  pairingKey?: string;
  /**
   * Optional BGP ASN for the router supplied by a Layer 3 Partner if they
   * configured BGP on behalf of the customer. Output only for PARTNER type,
   * input only for PARTNER_PROVIDER, not available for DEDICATED.
   */
  partnerAsn?: bigint;
  /**
   * Informational metadata about Partner attachments from Partners to display
   * to customers. Output only for for PARTNER type, mutable for
   * PARTNER_PROVIDER, not available for DEDICATED.
   */
  partnerMetadata?: InterconnectAttachmentPartnerMetadata;
  /**
   * [Output Only] Information specific to an InterconnectAttachment. This
   * property is populated if the interconnect that this is attached to is of
   * type DEDICATED.
   */
  privateInterconnectInfo?: InterconnectAttachmentPrivateInfo;
  /**
   * [Output Only] URL of the region where the regional interconnect attachment
   * resides. You must specify this field as part of the HTTP request URL. It is
   * not settable as a field in the request body.
   */
  region?: string;
  /**
   * URL of the Cloud Router to be used for dynamic routing. This router must
   * be in the same region as this InterconnectAttachment. The
   * InterconnectAttachment will automatically connect the Interconnect to the
   * network & region within which the Cloud Router is configured.
   */
  router?: string;
  /**
   * [Output Only] Reserved for future use.
   */
  satisfiesPzs?: boolean;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * The stack type for this interconnect attachment to identify whether the
   * IPv6 feature is enabled or not. If not specified, IPV4_ONLY will be used.
   * This field can be both set at interconnect attachments creation and update
   * interconnect attachment operations.
   */
  stackType?:  | "IPV4_IPV6" | "IPV4_ONLY";
  /**
   * [Output Only] The current state of this attachment's functionality. Enum
   * values ACTIVE and UNPROVISIONED are shared by DEDICATED/PRIVATE, PARTNER,
   * and PARTNER_PROVIDER interconnect attachments, while enum values
   * PENDING_PARTNER, PARTNER_REQUEST_RECEIVED, and PENDING_CUSTOMER are used
   * for only PARTNER and PARTNER_PROVIDER interconnect attachments. This state
   * can take one of the following values: - ACTIVE: The attachment has been
   * turned up and is ready to use. - UNPROVISIONED: The attachment is not ready
   * to use yet, because turnup is not complete. - PENDING_PARTNER: A
   * newly-created PARTNER attachment that has not yet been configured on the
   * Partner side. - PARTNER_REQUEST_RECEIVED: A PARTNER attachment is in the
   * process of provisioning after a PARTNER_PROVIDER attachment was created
   * that references it. - PENDING_CUSTOMER: A PARTNER or PARTNER_PROVIDER
   * attachment that is waiting for a customer to activate it. - DEFUNCT: The
   * attachment was deleted externally and is no longer functional. This could
   * be because the associated Interconnect was removed, or because the other
   * side of a Partner attachment was deleted.
   */
  state?:  | "ACTIVE" | "DEFUNCT" | "PARTNER_REQUEST_RECEIVED" | "PENDING_CUSTOMER" | "PENDING_PARTNER" | "STATE_UNSPECIFIED" | "UNPROVISIONED";
  /**
   * The type of interconnect attachment this is, which can take one of the
   * following values: - DEDICATED: an attachment to a Dedicated Interconnect. -
   * PARTNER: an attachment to a Partner Interconnect, created by the customer.
   * - PARTNER_PROVIDER: an attachment to a Partner Interconnect, created by the
   * partner.
   */
  type?:  | "DEDICATED" | "PARTNER" | "PARTNER_PROVIDER";
  /**
   * The IEEE 802.1Q VLAN tag for this attachment, in the range 2-4093. Only
   * specified at creation time.
   */
  vlanTag8021q?: number;
}

function serializeInterconnectAttachment(data: any): InterconnectAttachment {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
    partnerAsn: data["partnerAsn"] !== undefined ? String(data["partnerAsn"]) : undefined,
  };
}

function deserializeInterconnectAttachment(data: any): InterconnectAttachment {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
    partnerAsn: data["partnerAsn"] !== undefined ? BigInt(data["partnerAsn"]) : undefined,
  };
}

export interface InterconnectAttachmentAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of InterconnectAttachmentsScopedList resources.
   */
  items?: {
    [key: string]: InterconnectAttachmentsScopedList
  };
  /**
   * [Output Only] Type of resource. Always
   * compute#interconnectAttachmentAggregatedList for aggregated lists of
   * interconnect attachments.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeInterconnectAttachmentAggregatedList(data: any): InterconnectAttachmentAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeInterconnectAttachmentsScopedList(v)]))) : undefined,
  };
}

function deserializeInterconnectAttachmentAggregatedList(data: any): InterconnectAttachmentAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeInterconnectAttachmentsScopedList(v)]))) : undefined,
  };
}

/**
 * Response to the list request, and contains a list of interconnect
 * attachments.
 */
export interface InterconnectAttachmentList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of InterconnectAttachment resources.
   */
  items?: InterconnectAttachment[];
  /**
   * [Output Only] Type of resource. Always compute#interconnectAttachmentList
   * for lists of interconnect attachments.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeInterconnectAttachmentList(data: any): InterconnectAttachmentList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeInterconnectAttachment(item))) : undefined,
  };
}

function deserializeInterconnectAttachmentList(data: any): InterconnectAttachmentList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeInterconnectAttachment(item))) : undefined,
  };
}

/**
 * Informational metadata about Partner attachments from Partners to display to
 * customers. These fields are propagated from PARTNER_PROVIDER attachments to
 * their corresponding PARTNER attachments.
 */
export interface InterconnectAttachmentPartnerMetadata {
  /**
   * Plain text name of the Interconnect this attachment is connected to, as
   * displayed in the Partner's portal. For instance "Chicago 1". This value may
   * be validated to match approved Partner values.
   */
  interconnectName?: string;
  /**
   * Plain text name of the Partner providing this attachment. This value may
   * be validated to match approved Partner values.
   */
  partnerName?: string;
  /**
   * URL of the Partner's portal for this Attachment. Partners may customise
   * this to be a deep link to the specific resource on the Partner portal. This
   * value may be validated to match approved Partner values.
   */
  portalUrl?: string;
}

/**
 * Information for an interconnect attachment when this belongs to an
 * interconnect of type DEDICATED.
 */
export interface InterconnectAttachmentPrivateInfo {
  /**
   * [Output Only] 802.1q encapsulation tag to be used for traffic between
   * Google and the customer, going to and from this network and region.
   */
  tag8021q?: number;
}

/**
 * Additional options for Compute#interconnectAttachmentsAggregatedList.
 */
export interface InterconnectAttachmentsAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#interconnectAttachmentsDelete.
 */
export interface InterconnectAttachmentsDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#interconnectAttachmentsInsert.
 */
export interface InterconnectAttachmentsInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
  /**
   * If true, the request will not be committed.
   */
  validateOnly?: boolean;
}

/**
 * Additional options for Compute#interconnectAttachmentsList.
 */
export interface InterconnectAttachmentsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#interconnectAttachmentsPatch.
 */
export interface InterconnectAttachmentsPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface InterconnectAttachmentsScopedList {
  /**
   * A list of interconnect attachments contained in this scope.
   */
  interconnectAttachments?: InterconnectAttachment[];
  /**
   * Informational warning which replaces the list of addresses when the list
   * is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeInterconnectAttachmentsScopedList(data: any): InterconnectAttachmentsScopedList {
  return {
    ...data,
    interconnectAttachments: data["interconnectAttachments"] !== undefined ? data["interconnectAttachments"].map((item: any) => (serializeInterconnectAttachment(item))) : undefined,
  };
}

function deserializeInterconnectAttachmentsScopedList(data: any): InterconnectAttachmentsScopedList {
  return {
    ...data,
    interconnectAttachments: data["interconnectAttachments"] !== undefined ? data["interconnectAttachments"].map((item: any) => (deserializeInterconnectAttachment(item))) : undefined,
  };
}

/**
 * Additional options for Compute#interconnectAttachmentsSetLabels.
 */
export interface InterconnectAttachmentsSetLabelsOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Describes a single physical circuit between the Customer and Google.
 * CircuitInfo objects are created by Google, so all fields are output only.
 */
export interface InterconnectCircuitInfo {
  /**
   * Customer-side demarc ID for this circuit.
   */
  customerDemarcId?: string;
  /**
   * Google-assigned unique ID for this circuit. Assigned at circuit turn-up.
   */
  googleCircuitId?: string;
  /**
   * Google-side demarc ID for this circuit. Assigned at circuit turn-up and
   * provided by Google to the customer in the LOA.
   */
  googleDemarcId?: string;
}

/**
 * Diagnostics information about interconnect, contains detailed and current
 * technical information about Google's side of the connection.
 */
export interface InterconnectDiagnostics {
  /**
   * A list of InterconnectDiagnostics.ARPEntry objects, describing individual
   * neighbors currently seen by the Google router in the ARP cache for the
   * Interconnect. This will be empty when the Interconnect is not bundled.
   */
  arpCaches?: InterconnectDiagnosticsARPEntry[];
  /**
   * The aggregation type of the bundle interface.
   */
  bundleAggregationType?:  | "BUNDLE_AGGREGATION_TYPE_LACP" | "BUNDLE_AGGREGATION_TYPE_STATIC";
  /**
   * The operational status of the bundle interface.
   */
  bundleOperationalStatus?:  | "BUNDLE_OPERATIONAL_STATUS_DOWN" | "BUNDLE_OPERATIONAL_STATUS_UP";
  /**
   * A list of InterconnectDiagnostics.LinkStatus objects, describing the
   * status for each link on the Interconnect.
   */
  links?: InterconnectDiagnosticsLinkStatus[];
  /**
   * The MAC address of the Interconnect's bundle interface.
   */
  macAddress?: string;
}

/**
 * Describing the ARP neighbor entries seen on this link
 */
export interface InterconnectDiagnosticsARPEntry {
  /**
   * The IP address of this ARP neighbor.
   */
  ipAddress?: string;
  /**
   * The MAC address of this ARP neighbor.
   */
  macAddress?: string;
}

export interface InterconnectDiagnosticsLinkLACPStatus {
  /**
   * System ID of the port on Google's side of the LACP exchange.
   */
  googleSystemId?: string;
  /**
   * System ID of the port on the neighbor's side of the LACP exchange.
   */
  neighborSystemId?: string;
  /**
   * The state of a LACP link, which can take one of the following values: -
   * ACTIVE: The link is configured and active within the bundle. - DETACHED:
   * The link is not configured within the bundle. This means that the rest of
   * the object should be empty.
   */
  state?:  | "ACTIVE" | "DETACHED";
}

export interface InterconnectDiagnosticsLinkOpticalPower {
  /**
   * The status of the current value when compared to the warning and alarm
   * levels for the receiving or transmitting transceiver. Possible states
   * include: - OK: The value has not crossed a warning threshold. -
   * LOW_WARNING: The value has crossed below the low warning threshold. -
   * HIGH_WARNING: The value has crossed above the high warning threshold. -
   * LOW_ALARM: The value has crossed below the low alarm threshold. -
   * HIGH_ALARM: The value has crossed above the high alarm threshold.
   */
  state?:  | "HIGH_ALARM" | "HIGH_WARNING" | "LOW_ALARM" | "LOW_WARNING" | "OK";
  /**
   * Value of the current receiving or transmitting optical power, read in dBm.
   * Take a known good optical value, give it a 10% margin and trigger warnings
   * relative to that value. In general, a -7dBm warning and a -11dBm alarm are
   * good optical value estimates for most links.
   */
  value?: number;
}

export interface InterconnectDiagnosticsLinkStatus {
  /**
   * A list of InterconnectDiagnostics.ARPEntry objects, describing the ARP
   * neighbor entries seen on this link. This will be empty if the link is
   * bundled
   */
  arpCaches?: InterconnectDiagnosticsARPEntry[];
  /**
   * The unique ID for this link assigned during turn up by Google.
   */
  circuitId?: string;
  /**
   * The Demarc address assigned by Google and provided in the LoA.
   */
  googleDemarc?: string;
  lacpStatus?: InterconnectDiagnosticsLinkLACPStatus;
  /**
   * The operational status of the link.
   */
  operationalStatus?:  | "LINK_OPERATIONAL_STATUS_DOWN" | "LINK_OPERATIONAL_STATUS_UP";
  /**
   * An InterconnectDiagnostics.LinkOpticalPower object, describing the current
   * value and status of the received light level.
   */
  receivingOpticalPower?: InterconnectDiagnosticsLinkOpticalPower;
  /**
   * An InterconnectDiagnostics.LinkOpticalPower object, describing the current
   * value and status of the transmitted light level.
   */
  transmittingOpticalPower?: InterconnectDiagnosticsLinkOpticalPower;
}

/**
 * Response to the list request, and contains a list of interconnects.
 */
export interface InterconnectList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of Interconnect resources.
   */
  items?: Interconnect[];
  /**
   * [Output Only] Type of resource. Always compute#interconnectList for lists
   * of interconnects.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeInterconnectList(data: any): InterconnectList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeInterconnect(item))) : undefined,
  };
}

function deserializeInterconnectList(data: any): InterconnectList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeInterconnect(item))) : undefined,
  };
}

/**
 * Represents an Interconnect Attachment (VLAN) Location resource. You can use
 * this resource to find location details about an Interconnect attachment
 * (VLAN). For more information about interconnect attachments, read Creating
 * VLAN Attachments.
 */
export interface InterconnectLocation {
  /**
   * [Output Only] The postal address of the Point of Presence, each line in
   * the address is separated by a newline character.
   */
  address?: string;
  /**
   * [Output Only] Availability zone for this InterconnectLocation. Within a
   * metropolitan area (metro), maintenance will not be simultaneously scheduled
   * in more than one availability zone. Example: "zone1" or "zone2".
   */
  availabilityZone?: string;
  /**
   * [Output Only] Metropolitan area designator that indicates which city an
   * interconnect is located. For example: "Chicago, IL", "Amsterdam,
   * Netherlands".
   */
  city?: string;
  /**
   * [Output Only] Continent for this location, which can take one of the
   * following values: - AFRICA - ASIA_PAC - EUROPE - NORTH_AMERICA -
   * SOUTH_AMERICA
   */
  continent?:  | "AFRICA" | "ASIA_PAC" | "C_AFRICA" | "C_ASIA_PAC" | "C_EUROPE" | "C_NORTH_AMERICA" | "C_SOUTH_AMERICA" | "EUROPE" | "NORTH_AMERICA" | "SOUTH_AMERICA";
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * [Output Only] An optional description of the resource.
   */
  description?: string;
  /**
   * [Output Only] The name of the provider for this facility (e.g., EQUINIX).
   */
  facilityProvider?: string;
  /**
   * [Output Only] A provider-assigned Identifier for this facility (e.g.,
   * Ashburn-DC1).
   */
  facilityProviderFacilityId?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of the resource. Always compute#interconnectLocation
   * for interconnect locations.
   */
  kind?: string;
  /**
   * [Output Only] Name of the resource.
   */
  name?: string;
  /**
   * [Output Only] The peeringdb identifier for this facility (corresponding
   * with a netfac type in peeringdb).
   */
  peeringdbFacilityId?: string;
  /**
   * [Output Only] A list of InterconnectLocation.RegionInfo objects, that
   * describe parameters pertaining to the relation between this
   * InterconnectLocation and various Google Cloud regions.
   */
  regionInfos?: InterconnectLocationRegionInfo[];
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * [Output Only] The status of this InterconnectLocation, which can take one
   * of the following values: - CLOSED: The InterconnectLocation is closed and
   * is unavailable for provisioning new Interconnects. - AVAILABLE: The
   * InterconnectLocation is available for provisioning new Interconnects.
   */
  status?:  | "AVAILABLE" | "CLOSED";
  /**
   * [Output Only] Reserved for future use.
   */
  supportsPzs?: boolean;
}

function serializeInterconnectLocation(data: any): InterconnectLocation {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
    regionInfos: data["regionInfos"] !== undefined ? data["regionInfos"].map((item: any) => (serializeInterconnectLocationRegionInfo(item))) : undefined,
  };
}

function deserializeInterconnectLocation(data: any): InterconnectLocation {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
    regionInfos: data["regionInfos"] !== undefined ? data["regionInfos"].map((item: any) => (deserializeInterconnectLocationRegionInfo(item))) : undefined,
  };
}

/**
 * Response to the list request, and contains a list of interconnect locations.
 */
export interface InterconnectLocationList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of InterconnectLocation resources.
   */
  items?: InterconnectLocation[];
  /**
   * [Output Only] Type of resource. Always compute#interconnectLocationList
   * for lists of interconnect locations.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeInterconnectLocationList(data: any): InterconnectLocationList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeInterconnectLocation(item))) : undefined,
  };
}

function deserializeInterconnectLocationList(data: any): InterconnectLocationList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeInterconnectLocation(item))) : undefined,
  };
}

/**
 * Information about any potential InterconnectAttachments between an
 * Interconnect at a specific InterconnectLocation, and a specific Cloud Region.
 */
export interface InterconnectLocationRegionInfo {
  /**
   * Expected round-trip time in milliseconds, from this InterconnectLocation
   * to a VM in this region.
   */
  expectedRttMs?: bigint;
  /**
   * Identifies the network presence of this location.
   */
  locationPresence?:  | "GLOBAL" | "LOCAL_REGION" | "LP_GLOBAL" | "LP_LOCAL_REGION";
  /**
   * URL for the region of this location.
   */
  region?: string;
}

function serializeInterconnectLocationRegionInfo(data: any): InterconnectLocationRegionInfo {
  return {
    ...data,
    expectedRttMs: data["expectedRttMs"] !== undefined ? String(data["expectedRttMs"]) : undefined,
  };
}

function deserializeInterconnectLocationRegionInfo(data: any): InterconnectLocationRegionInfo {
  return {
    ...data,
    expectedRttMs: data["expectedRttMs"] !== undefined ? BigInt(data["expectedRttMs"]) : undefined,
  };
}

/**
 * Additional options for Compute#interconnectLocationsList.
 */
export interface InterconnectLocationsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Description of a planned outage on this Interconnect.
 */
export interface InterconnectOutageNotification {
  /**
   * If issue_type is IT_PARTIAL_OUTAGE, a list of the Google-side circuit IDs
   * that will be affected.
   */
  affectedCircuits?: string[];
  /**
   * A description about the purpose of the outage.
   */
  description?: string;
  /**
   * Scheduled end time for the outage (milliseconds since Unix epoch).
   */
  endTime?: bigint;
  /**
   * Form this outage is expected to take, which can take one of the following
   * values: - OUTAGE: The Interconnect may be completely out of service for
   * some or all of the specified window. - PARTIAL_OUTAGE: Some circuits
   * comprising the Interconnect as a whole should remain up, but with reduced
   * bandwidth. Note that the versions of this enum prefixed with "IT_" have
   * been deprecated in favor of the unprefixed values.
   */
  issueType?:  | "IT_OUTAGE" | "IT_PARTIAL_OUTAGE" | "OUTAGE" | "PARTIAL_OUTAGE";
  /**
   * Unique identifier for this outage notification.
   */
  name?: string;
  /**
   * The party that generated this notification, which can take the following
   * value: - GOOGLE: this notification as generated by Google. Note that the
   * value of NSRC_GOOGLE has been deprecated in favor of GOOGLE.
   */
  source?:  | "GOOGLE" | "NSRC_GOOGLE";
  /**
   * Scheduled start time for the outage (milliseconds since Unix epoch).
   */
  startTime?: bigint;
  /**
   * State of this notification, which can take one of the following values: -
   * ACTIVE: This outage notification is active. The event could be in the past,
   * present, or future. See start_time and end_time for scheduling. -
   * CANCELLED: The outage associated with this notification was cancelled
   * before the outage was due to start. - COMPLETED: The outage associated with
   * this notification is complete. Note that the versions of this enum prefixed
   * with "NS_" have been deprecated in favor of the unprefixed values.
   */
  state?:  | "ACTIVE" | "CANCELLED" | "COMPLETED" | "NS_ACTIVE" | "NS_CANCELED";
}

function serializeInterconnectOutageNotification(data: any): InterconnectOutageNotification {
  return {
    ...data,
    endTime: data["endTime"] !== undefined ? String(data["endTime"]) : undefined,
    startTime: data["startTime"] !== undefined ? String(data["startTime"]) : undefined,
  };
}

function deserializeInterconnectOutageNotification(data: any): InterconnectOutageNotification {
  return {
    ...data,
    endTime: data["endTime"] !== undefined ? BigInt(data["endTime"]) : undefined,
    startTime: data["startTime"] !== undefined ? BigInt(data["startTime"]) : undefined,
  };
}

/**
 * Additional options for Compute#interconnectsDelete.
 */
export interface InterconnectsDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Response for the InterconnectsGetDiagnosticsRequest.
 */
export interface InterconnectsGetDiagnosticsResponse {
  result?: InterconnectDiagnostics;
}

/**
 * Additional options for Compute#interconnectsInsert.
 */
export interface InterconnectsInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#interconnectsList.
 */
export interface InterconnectsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#interconnectsPatch.
 */
export interface InterconnectsPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Represents a License resource. A License represents billing and aggregate
 * usage data for public and marketplace images. *Caution* This resource is
 * intended for use only by third-party partners who are creating Cloud
 * Marketplace images.
 */
export interface License {
  /**
   * [Output Only] Deprecated. This field no longer reflects whether a license
   * charges a usage fee.
   */
  chargesUseFee?: boolean;
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional textual description of the resource; provided by the client
   * when the resource is created.
   */
  description?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of resource. Always compute#license for licenses.
   */
  kind?: string;
  /**
   * [Output Only] The unique code used to attach this license to images,
   * snapshots, and disks.
   */
  licenseCode?: bigint;
  /**
   * Name of the resource. The name must be 1-63 characters long and comply
   * with RFC1035.
   */
  name?: string;
  resourceRequirements?: LicenseResourceRequirements;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * If false, licenses will not be copied from the source resource when
   * creating an image from a disk, disk from snapshot, or snapshot from disk.
   */
  transferable?: boolean;
}

function serializeLicense(data: any): License {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
    licenseCode: data["licenseCode"] !== undefined ? String(data["licenseCode"]) : undefined,
  };
}

function deserializeLicense(data: any): License {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
    licenseCode: data["licenseCode"] !== undefined ? BigInt(data["licenseCode"]) : undefined,
  };
}

/**
 * Represents a License Code resource. A License Code is a unique identifier
 * used to represent a license resource. *Caution* This resource is intended for
 * use only by third-party partners who are creating Cloud Marketplace images.
 */
export interface LicenseCode {
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * [Output Only] Description of this License Code.
   */
  description?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of resource. Always compute#licenseCode for licenses.
   */
  kind?: string;
  /**
   * [Output Only] URL and description aliases of Licenses with the same
   * License Code.
   */
  licenseAlias?: LicenseCodeLicenseAlias[];
  /**
   * [Output Only] Name of the resource. The name is 1-20 characters long and
   * must be a valid 64 bit integer.
   */
  name?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Current state of this License Code.
   */
  state?:  | "DISABLED" | "ENABLED" | "RESTRICTED" | "STATE_UNSPECIFIED" | "TERMINATED";
  /**
   * [Output Only] If true, the license will remain attached when creating
   * images or snapshots from disks. Otherwise, the license is not transferred.
   */
  transferable?: boolean;
}

function serializeLicenseCode(data: any): LicenseCode {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeLicenseCode(data: any): LicenseCode {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface LicenseCodeLicenseAlias {
  /**
   * [Output Only] Description of this License Code.
   */
  description?: string;
  /**
   * [Output Only] URL of license corresponding to this License Code.
   */
  selfLink?: string;
}

/**
 * Commitment for a particular license resource.
 */
export interface LicenseResourceCommitment {
  /**
   * The number of licenses purchased.
   */
  amount?: bigint;
  /**
   * Specifies the core range of the instance for which this license applies.
   */
  coresPerLicense?: string;
  /**
   * Any applicable license URI.
   */
  license?: string;
}

function serializeLicenseResourceCommitment(data: any): LicenseResourceCommitment {
  return {
    ...data,
    amount: data["amount"] !== undefined ? String(data["amount"]) : undefined,
  };
}

function deserializeLicenseResourceCommitment(data: any): LicenseResourceCommitment {
  return {
    ...data,
    amount: data["amount"] !== undefined ? BigInt(data["amount"]) : undefined,
  };
}

export interface LicenseResourceRequirements {
  /**
   * Minimum number of guest cpus required to use the Instance. Enforced at
   * Instance creation and Instance start.
   */
  minGuestCpuCount?: number;
  /**
   * Minimum memory required to use the Instance. Enforced at Instance creation
   * and Instance start.
   */
  minMemoryMb?: number;
}

/**
 * Additional options for Compute#licensesDelete.
 */
export interface LicensesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#licensesGetIamPolicy.
 */
export interface LicensesGetIamPolicyOptions {
  /**
   * Requested IAM Policy version.
   */
  optionsRequestedPolicyVersion?: number;
}

/**
 * Additional options for Compute#licensesInsert.
 */
export interface LicensesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#licensesList.
 */
export interface LicensesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface LicensesListResponse {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of License resources.
   */
  items?: License[];
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeLicensesListResponse(data: any): LicensesListResponse {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeLicense(item))) : undefined,
  };
}

function deserializeLicensesListResponse(data: any): LicensesListResponse {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeLicense(item))) : undefined,
  };
}

export interface LocalDisk {
  /**
   * Specifies the number of such disks.
   */
  diskCount?: number;
  /**
   * Specifies the size of the disk in base-2 GB.
   */
  diskSizeGb?: number;
  /**
   * Specifies the desired disk type on the node. This disk type must be a
   * local storage type (e.g.: local-ssd). Note that for nodeTemplates, this
   * should be the name of the disk type and not its URL.
   */
  diskType?: string;
}

/**
 * Provides a localized error message that is safe to return to the user which
 * can be attached to an RPC error.
 */
export interface LocalizedMessage {
  /**
   * The locale used following the specification defined at
   * https://www.rfc-editor.org/rfc/bcp/bcp47.txt. Examples are: "en-US",
   * "fr-CH", "es-MX"
   */
  locale?: string;
  /**
   * The localized error message in the above locale.
   */
  message?: string;
}

/**
 * Configuration for location policy among multiple possible locations (e.g.
 * preferences for zone selection among zones in a single region).
 */
export interface LocationPolicy {
  /**
   * Location configurations mapped by location name. Currently only zone names
   * are supported and must be represented as valid internal URLs, such as
   * zones/us-central1-a.
   */
  locations?: {
    [key: string]: LocationPolicyLocation
  };
  /**
   * Strategy for distributing VMs across zones in a region.
   */
  targetShape?:  | "ANY" | "ANY_SINGLE_ZONE" | "BALANCED";
}

export interface LocationPolicyLocation {
  /**
   * Constraints that the caller requires on the result distribution in this
   * zone.
   */
  constraints?: LocationPolicyLocationConstraints;
  /**
   * Preference for a given location. Set to either ALLOW or DENY.
   */
  preference?:  | "ALLOW" | "DENY" | "PREFERENCE_UNSPECIFIED";
}

/**
 * Per-zone constraints on location policy for this zone.
 */
export interface LocationPolicyLocationConstraints {
  /**
   * Maximum number of items that are allowed to be placed in this zone. The
   * value must be non-negative.
   */
  maxCount?: number;
}

/**
 * This is deprecated and has no effect. Do not use.
 */
export interface LogConfig {
  /**
   * This is deprecated and has no effect. Do not use.
   */
  cloudAudit?: LogConfigCloudAuditOptions;
  /**
   * This is deprecated and has no effect. Do not use.
   */
  counter?: LogConfigCounterOptions;
  /**
   * This is deprecated and has no effect. Do not use.
   */
  dataAccess?: LogConfigDataAccessOptions;
}

/**
 * This is deprecated and has no effect. Do not use.
 */
export interface LogConfigCloudAuditOptions {
  /**
   * This is deprecated and has no effect. Do not use.
   */
  authorizationLoggingOptions?: AuthorizationLoggingOptions;
  /**
   * This is deprecated and has no effect. Do not use.
   */
  logName?:  | "ADMIN_ACTIVITY" | "DATA_ACCESS" | "UNSPECIFIED_LOG_NAME";
}

/**
 * This is deprecated and has no effect. Do not use.
 */
export interface LogConfigCounterOptions {
  /**
   * This is deprecated and has no effect. Do not use.
   */
  customFields?: LogConfigCounterOptionsCustomField[];
  /**
   * This is deprecated and has no effect. Do not use.
   */
  field?: string;
  /**
   * This is deprecated and has no effect. Do not use.
   */
  metric?: string;
}

/**
 * This is deprecated and has no effect. Do not use.
 */
export interface LogConfigCounterOptionsCustomField {
  /**
   * This is deprecated and has no effect. Do not use.
   */
  name?: string;
  /**
   * This is deprecated and has no effect. Do not use.
   */
  value?: string;
}

/**
 * This is deprecated and has no effect. Do not use.
 */
export interface LogConfigDataAccessOptions {
  /**
   * This is deprecated and has no effect. Do not use.
   */
  logMode?:  | "LOG_FAIL_CLOSED" | "LOG_MODE_UNSPECIFIED";
}

/**
 * Represents a machine image resource. A machine image is a Compute Engine
 * resource that stores all the configuration, metadata, permissions, and data
 * from one or more disks required to create a Virtual machine (VM) instance.
 * For more information, see Machine images.
 */
export interface MachineImage {
  /**
   * [Output Only] The creation timestamp for this machine image in RFC3339
   * text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * [Input Only] Whether to attempt an application consistent machine image by
   * informing the OS to prepare for the snapshot process.
   */
  guestFlush?: boolean;
  /**
   * [Output Only] A unique identifier for this machine image. The server
   * defines this identifier.
   */
  id?: bigint;
  /**
   * [Output Only] Properties of source instance
   */
  instanceProperties?: InstanceProperties;
  /**
   * [Output Only] The resource type, which is always compute#machineImage for
   * machine image.
   */
  kind?: string;
  /**
   * Encrypts the machine image using a customer-supplied encryption key. After
   * you encrypt a machine image using a customer-supplied key, you must provide
   * the same key if you use the machine image later. For example, you must
   * provide the encryption key when you create an instance from the encrypted
   * machine image in a future request. Customer-supplied encryption keys do not
   * protect access to metadata of the machine image. If you do not provide an
   * encryption key when creating the machine image, then the machine image will
   * be encrypted using an automatically generated key and you do not need to
   * provide a key to use the machine image later.
   */
  machineImageEncryptionKey?: CustomerEncryptionKey;
  /**
   * Name of the resource; provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * [Output Only] Reserved for future use.
   */
  satisfiesPzs?: boolean;
  /**
   * An array of Machine Image specific properties for disks attached to the
   * source instance
   */
  savedDisks?: SavedDisk[];
  /**
   * [Output Only] The URL for this machine image. The server defines this URL.
   */
  selfLink?: string;
  /**
   * [Input Only] The customer-supplied encryption key of the disks attached to
   * the source instance. Required if the source disk is protected by a
   * customer-supplied encryption key.
   */
  sourceDiskEncryptionKeys?: SourceDiskEncryptionKey[];
  /**
   * The source instance used to create the machine image. You can provide this
   * as a partial or full URL to the resource. For example, the following are
   * valid values: -
   * https://www.googleapis.com/compute/v1/projects/project/zones/zone
   * /instances/instance - projects/project/zones/zone/instances/instance
   */
  sourceInstance?: string;
  /**
   * [Output Only] DEPRECATED: Please use instance_properties instead for
   * source instance related properties. New properties will not be added to
   * this field.
   */
  sourceInstanceProperties?: SourceInstanceProperties;
  /**
   * [Output Only] The status of the machine image. One of the following
   * values: INVALID, CREATING, READY, DELETING, and UPLOADING.
   */
  status?:  | "CREATING" | "DELETING" | "INVALID" | "READY" | "UPLOADING";
  /**
   * The regional or multi-regional Cloud Storage bucket location where the
   * machine image is stored.
   */
  storageLocations?: string[];
  /**
   * [Output Only] Total size of the storage used by the machine image.
   */
  totalStorageBytes?: bigint;
}

function serializeMachineImage(data: any): MachineImage {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
    instanceProperties: data["instanceProperties"] !== undefined ? serializeInstanceProperties(data["instanceProperties"]) : undefined,
    savedDisks: data["savedDisks"] !== undefined ? data["savedDisks"].map((item: any) => (serializeSavedDisk(item))) : undefined,
    sourceInstanceProperties: data["sourceInstanceProperties"] !== undefined ? serializeSourceInstanceProperties(data["sourceInstanceProperties"]) : undefined,
    totalStorageBytes: data["totalStorageBytes"] !== undefined ? String(data["totalStorageBytes"]) : undefined,
  };
}

function deserializeMachineImage(data: any): MachineImage {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
    instanceProperties: data["instanceProperties"] !== undefined ? deserializeInstanceProperties(data["instanceProperties"]) : undefined,
    savedDisks: data["savedDisks"] !== undefined ? data["savedDisks"].map((item: any) => (deserializeSavedDisk(item))) : undefined,
    sourceInstanceProperties: data["sourceInstanceProperties"] !== undefined ? deserializeSourceInstanceProperties(data["sourceInstanceProperties"]) : undefined,
    totalStorageBytes: data["totalStorageBytes"] !== undefined ? BigInt(data["totalStorageBytes"]) : undefined,
  };
}

/**
 * A list of machine images.
 */
export interface MachineImageList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of MachineImage resources.
   */
  items?: MachineImage[];
  /**
   * [Output Only] The resource type, which is always
   * compute#machineImagesListResponse for machine image lists.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeMachineImageList(data: any): MachineImageList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeMachineImage(item))) : undefined,
  };
}

function deserializeMachineImageList(data: any): MachineImageList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeMachineImage(item))) : undefined,
  };
}

/**
 * Additional options for Compute#machineImagesDelete.
 */
export interface MachineImagesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#machineImagesGetIamPolicy.
 */
export interface MachineImagesGetIamPolicyOptions {
  /**
   * Requested IAM Policy version.
   */
  optionsRequestedPolicyVersion?: number;
}

/**
 * Additional options for Compute#machineImagesInsert.
 */
export interface MachineImagesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
  /**
   * Required. Source instance that is used to create the machine image from.
   */
  sourceInstance?: string;
}

/**
 * Additional options for Compute#machineImagesList.
 */
export interface MachineImagesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Represents a Machine Type resource. You can use specific machine types for
 * your VM instances based on performance and pricing requirements. For more
 * information, read Machine Types.
 */
export interface MachineType {
  /**
   * [Output Only] A list of accelerator configurations assigned to this
   * machine type.
   */
  accelerators?: {
    guestAcceleratorCount?: number;
    guestAcceleratorType?: string;
  }[];
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * [Output Only] The deprecation status associated with this machine type.
   * Only applicable if the machine type is unavailable.
   */
  deprecated?: DeprecationStatus;
  /**
   * [Output Only] An optional textual description of the resource.
   */
  description?: string;
  /**
   * [Output Only] The number of virtual CPUs that are available to the
   * instance.
   */
  guestCpus?: number;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Deprecated] This property is deprecated and will never be populated with
   * any relevant values.
   */
  imageSpaceGb?: number;
  /**
   * [Output Only] Whether this machine type has a shared CPU. See Shared-core
   * machine types for more information.
   */
  isSharedCpu?: boolean;
  /**
   * [Output Only] The type of the resource. Always compute#machineType for
   * machine types.
   */
  kind?: string;
  /**
   * [Output Only] Maximum persistent disks allowed.
   */
  maximumPersistentDisks?: number;
  /**
   * [Output Only] Maximum total persistent disks size (GB) allowed.
   */
  maximumPersistentDisksSizeGb?: bigint;
  /**
   * [Output Only] The amount of physical memory available to the instance,
   * defined in MB.
   */
  memoryMb?: number;
  /**
   * [Output Only] Name of the resource.
   */
  name?: string;
  /**
   * [Output Only] A list of extended scratch disks assigned to the instance.
   */
  scratchDisks?: {
    diskGb?: number;
  }[];
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * [Output Only] The name of the zone where the machine type resides, such as
   * us-central1-a.
   */
  zone?: string;
}

function serializeMachineType(data: any): MachineType {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
    maximumPersistentDisksSizeGb: data["maximumPersistentDisksSizeGb"] !== undefined ? String(data["maximumPersistentDisksSizeGb"]) : undefined,
  };
}

function deserializeMachineType(data: any): MachineType {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
    maximumPersistentDisksSizeGb: data["maximumPersistentDisksSizeGb"] !== undefined ? BigInt(data["maximumPersistentDisksSizeGb"]) : undefined,
  };
}

export interface MachineTypeAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of MachineTypesScopedList resources.
   */
  items?: {
    [key: string]: MachineTypesScopedList
  };
  /**
   * [Output Only] Type of resource. Always compute#machineTypeAggregatedList
   * for aggregated lists of machine types.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeMachineTypeAggregatedList(data: any): MachineTypeAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeMachineTypesScopedList(v)]))) : undefined,
  };
}

function deserializeMachineTypeAggregatedList(data: any): MachineTypeAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeMachineTypesScopedList(v)]))) : undefined,
  };
}

/**
 * Contains a list of machine types.
 */
export interface MachineTypeList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of MachineType resources.
   */
  items?: MachineType[];
  /**
   * [Output Only] Type of resource. Always compute#machineTypeList for lists
   * of machine types.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeMachineTypeList(data: any): MachineTypeList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeMachineType(item))) : undefined,
  };
}

function deserializeMachineTypeList(data: any): MachineTypeList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeMachineType(item))) : undefined,
  };
}

/**
 * Additional options for Compute#machineTypesAggregatedList.
 */
export interface MachineTypesAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#machineTypesList.
 */
export interface MachineTypesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface MachineTypesScopedList {
  /**
   * [Output Only] A list of machine types contained in this scope.
   */
  machineTypes?: MachineType[];
  /**
   * [Output Only] An informational warning that appears when the machine types
   * list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeMachineTypesScopedList(data: any): MachineTypesScopedList {
  return {
    ...data,
    machineTypes: data["machineTypes"] !== undefined ? data["machineTypes"].map((item: any) => (serializeMachineType(item))) : undefined,
  };
}

function deserializeMachineTypesScopedList(data: any): MachineTypesScopedList {
  return {
    ...data,
    machineTypes: data["machineTypes"] !== undefined ? data["machineTypes"].map((item: any) => (deserializeMachineType(item))) : undefined,
  };
}

/**
 * A Managed Instance resource.
 */
export interface ManagedInstance {
  /**
   * [Output Only] The current action that the managed instance group has
   * scheduled for the instance. Possible values: - NONE The instance is
   * running, and the managed instance group does not have any scheduled actions
   * for this instance. - CREATING The managed instance group is creating this
   * instance. If the group fails to create this instance, it will try again
   * until it is successful. - CREATING_WITHOUT_RETRIES The managed instance
   * group is attempting to create this instance only once. If the group fails
   * to create this instance, it does not try again and the group's targetSize
   * value is decreased instead. - RECREATING The managed instance group is
   * recreating this instance. - DELETING The managed instance group is
   * permanently deleting this instance. - ABANDONING The managed instance group
   * is abandoning this instance. The instance will be removed from the instance
   * group and from any target pools that are associated with this group. -
   * RESTARTING The managed instance group is restarting the instance. -
   * REFRESHING The managed instance group is applying configuration changes to
   * the instance without stopping it. For example, the group can update the
   * target pool list for an instance without stopping that instance. -
   * VERIFYING The managed instance group has created the instance and it is in
   * the process of being verified.
   */
  currentAction?:  | "ABANDONING" | "CREATING" | "CREATING_WITHOUT_RETRIES" | "DELETING" | "NONE" | "RECREATING" | "REFRESHING" | "RESTARTING" | "RESUMING" | "STARTING" | "STOPPING" | "SUSPENDING" | "VERIFYING";
  /**
   * [Output only] The unique identifier for this resource. This field is empty
   * when instance does not exist.
   */
  id?: bigint;
  /**
   * [Output Only] The URL of the instance. The URL can exist even if the
   * instance has not yet been created.
   */
  instance?: string;
  /**
   * [Output Only] Health state of the instance per health-check.
   */
  instanceHealth?: ManagedInstanceInstanceHealth[];
  /**
   * [Output Only] The status of the instance. This field is empty when the
   * instance does not exist.
   */
  instanceStatus?:  | "DEPROVISIONING" | "PROVISIONING" | "REPAIRING" | "RUNNING" | "STAGING" | "STOPPED" | "STOPPING" | "SUSPENDED" | "SUSPENDING" | "TERMINATED";
  /**
   * [Output Only] Information about the last attempt to create or delete the
   * instance.
   */
  lastAttempt?: ManagedInstanceLastAttempt;
  /**
   * [Output Only] Preserved state applied from per-instance config for this
   * instance.
   */
  preservedStateFromConfig?: PreservedState;
  /**
   * [Output Only] Preserved state generated based on stateful policy for this
   * instance.
   */
  preservedStateFromPolicy?: PreservedState;
  /**
   * [Output Only] Intended version of this instance.
   */
  version?: ManagedInstanceVersion;
}

function serializeManagedInstance(data: any): ManagedInstance {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeManagedInstance(data: any): ManagedInstance {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface ManagedInstanceInstanceHealth {
  /**
   * [Output Only] The current detailed instance health state.
   */
  detailedHealthState?:  | "DRAINING" | "HEALTHY" | "TIMEOUT" | "UNHEALTHY" | "UNKNOWN";
  /**
   * [Output Only] The URL for the health check that verifies whether the
   * instance is healthy.
   */
  healthCheck?: string;
}

export interface ManagedInstanceLastAttempt {
  /**
   * [Output Only] Encountered errors during the last attempt to create or
   * delete the instance.
   */
  errors?: {
    errors?: {
      code?: string;
      errorDetails?: {
        errorInfo?: ErrorInfo;
        help?: Help;
        localizedMessage?: LocalizedMessage;
        quotaInfo?: QuotaExceededInfo;
      }[];
      location?: string;
      message?: string;
    }[];
  };
}

export interface ManagedInstanceVersion {
  /**
   * [Output Only] The intended template of the instance. This field is empty
   * when current_action is one of { DELETING, ABANDONING }.
   */
  instanceTemplate?: string;
  /**
   * [Output Only] Name of the version.
   */
  name?: string;
}

/**
 * A metadata key/value entry.
 */
export interface Metadata {
  /**
   * Specifies a fingerprint for this request, which is essentially a hash of
   * the metadata's contents and used for optimistic locking. The fingerprint is
   * initially generated by Compute Engine and changes after every request to
   * modify or update metadata. You must always provide an up-to-date
   * fingerprint hash in order to update or change metadata, otherwise the
   * request will fail with error 412 conditionNotMet. To see the latest
   * fingerprint, make a get() request to retrieve the resource.
   */
  fingerprint?: Uint8Array;
  /**
   * Array of key/value pairs. The total size of all keys and values must be
   * less than 512 KB.
   */
  items?: {
    key?: string;
    value?: string;
  }[];
  /**
   * [Output Only] Type of the resource. Always compute#metadata for metadata.
   */
  kind?: string;
}

function serializeMetadata(data: any): Metadata {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
  };
}

function deserializeMetadata(data: any): Metadata {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
  };
}

/**
 * Opaque filter criteria used by load balancers to restrict routing
 * configuration to a limited set of load balancing proxies. Proxies and
 * sidecars involved in load balancing would typically present metadata to the
 * load balancers that need to match criteria specified here. If a match takes
 * place, the relevant configuration is made available to those proxies. For
 * each metadataFilter in this list, if its filterMatchCriteria is set to
 * MATCH_ANY, at least one of the filterLabels must match the corresponding
 * label provided in the metadata. If its filterMatchCriteria is set to
 * MATCH_ALL, then all of its filterLabels must match with corresponding labels
 * provided in the metadata. An example for using metadataFilters would be: if
 * load balancing involves Envoys, they receive routing configuration when
 * values in metadataFilters match values supplied in of their XDS requests to
 * loadbalancers.
 */
export interface MetadataFilter {
  /**
   * The list of label value pairs that must match labels in the provided
   * metadata based on filterMatchCriteria This list must not be empty and can
   * have at the most 64 entries.
   */
  filterLabels?: MetadataFilterLabelMatch[];
  /**
   * Specifies how individual filter label matches within the list of
   * filterLabels and contributes toward the overall metadataFilter match.
   * Supported values are: - MATCH_ANY: at least one of the filterLabels must
   * have a matching label in the provided metadata. - MATCH_ALL: all
   * filterLabels must have matching labels in the provided metadata.
   */
  filterMatchCriteria?:  | "MATCH_ALL" | "MATCH_ANY" | "NOT_SET";
}

/**
 * MetadataFilter label name value pairs that are expected to match
 * corresponding labels presented as metadata to the load balancer.
 */
export interface MetadataFilterLabelMatch {
  /**
   * Name of metadata label. The name can have a maximum length of 1024
   * characters and must be at least 1 character long.
   */
  name?: string;
  /**
   * The value of the label must match the specified value. value can have a
   * maximum length of 1024 characters.
   */
  value?: string;
}

/**
 * The named port. For example: <"http", 80>.
 */
export interface NamedPort {
  /**
   * The name for this named port. The name must be 1-63 characters long, and
   * comply with RFC1035.
   */
  name?: string;
  /**
   * The port number, which can be a value between 1 and 65535.
   */
  port?: number;
}

/**
 * Represents a VPC Network resource. Networks connect resources to each other
 * and to the internet. For more information, read Virtual Private Cloud (VPC)
 * Network.
 */
export interface Network {
  /**
   * Must be set to create a VPC network. If not set, a legacy network is
   * created. When set to true, the VPC network is created in auto mode. When
   * set to false, the VPC network is created in custom mode. An auto mode VPC
   * network starts with one subnet per region. Each subnet has a predetermined
   * range as described in Auto mode VPC network IP ranges. For custom mode VPC
   * networks, you can add subnets using the subnetworks insert method.
   */
  autoCreateSubnetworks?: boolean;
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this field when you
   * create the resource.
   */
  description?: string;
  /**
   * Enable ULA internal ipv6 on this network. Enabling this feature will
   * assign a /48 from google defined ULA prefix fd20::/20. .
   */
  enableUlaInternalIpv6?: boolean;
  /**
   * [Output Only] URL of the firewall policy the network is associated with.
   */
  firewallPolicy?: string;
  /**
   * [Output Only] The gateway address for default routing out of the network,
   * selected by GCP.
   */
  gatewayIPv4?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * When enabling ula internal ipv6, caller optionally can specify the /48
   * range they want from the google defined ULA prefix fd20::/20. The input
   * must be a valid /48 ULA IPv6 address and must be within the fd20::/20.
   * Operation will fail if the speficied /48 is already in used by another
   * resource. If the field is not speficied, then a /48 range will be randomly
   * allocated from fd20::/20 and returned via this field. .
   */
  internalIpv6Range?: string;
  /**
   * Deprecated in favor of subnet mode networks. The range of internal
   * addresses that are legal on this network. This range is a CIDR
   * specification, for example: 192.168.0.0/16. Provided by the client when the
   * network is created.
   */
  IPv4Range?: string;
  /**
   * [Output Only] Type of the resource. Always compute#network for networks.
   */
  kind?: string;
  /**
   * Maximum Transmission Unit in bytes. The minimum value for this field is
   * 1300 and the maximum value is 8896. The suggested value is 1500, which is
   * the default MTU used on the Internet, or 8896 if you want to use Jumbo
   * frames. If unspecified, the value defaults to 1460.
   */
  mtu?: number;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a
   * lowercase letter, and all following characters (except for the last
   * character) must be a dash, lowercase letter, or digit. The last character
   * must be a lowercase letter or digit.
   */
  name?: string;
  /**
   * The network firewall policy enforcement order. Can be either
   * AFTER_CLASSIC_FIREWALL or BEFORE_CLASSIC_FIREWALL. Defaults to
   * AFTER_CLASSIC_FIREWALL if the field is not specified.
   */
  networkFirewallPolicyEnforcementOrder?:  | "AFTER_CLASSIC_FIREWALL" | "BEFORE_CLASSIC_FIREWALL";
  /**
   * [Output Only] A list of network peerings for the resource.
   */
  peerings?: NetworkPeering[];
  /**
   * The network-level routing configuration for this network. Used by Cloud
   * Router to determine what type of network-wide routing behavior to enforce.
   */
  routingConfig?: NetworkRoutingConfig;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Server-defined URL for this resource with the resource id.
   */
  selfLinkWithId?: string;
  /**
   * [Output Only] Server-defined fully-qualified URLs for all subnetworks in
   * this VPC network.
   */
  subnetworks?: string[];
}

function serializeNetwork(data: any): Network {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeNetwork(data: any): Network {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

/**
 * NetworkAttachments A network attachment resource ...
 */
export interface NetworkAttachment {
  /**
   * [Output Only] An array of connections for all the producers connected to
   * this network attachment.
   */
  connectionEndpoints?: NetworkAttachmentConnectedEndpoint[];
  connectionPreference?:  | "ACCEPT_AUTOMATIC" | "ACCEPT_MANUAL" | "INVALID";
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * [Output Only] Fingerprint of this resource. A hash of the contents stored
   * in this object. This field is used in optimistic locking. An up-to-date
   * fingerprint must be provided in order to patch.
   */
  fingerprint?: Uint8Array;
  /**
   * [Output Only] The unique identifier for the resource type. The server
   * generates this identifier.
   */
  id?: bigint;
  /**
   * [Output Only] Type of the resource.
   */
  kind?: string;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * [Output Only] The URL of the network which the Network Attachment belongs
   * to.
   */
  network?: string;
  /**
   * Projects that are allowed to connect to this network attachment. The
   * project can be specified using its id or number.
   */
  producerAcceptLists?: string[];
  /**
   * Projects that are not allowed to connect to this network attachment. The
   * project can be specified using its id or number.
   */
  producerRejectLists?: string[];
  /**
   * [Output Only] URL of the region where the network attachment resides. This
   * field applies only to the region resource. You must specify this field as
   * part of the HTTP request URL. It is not settable as a field in the request
   * body.
   */
  region?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Server-defined URL for this resource's resource id.
   */
  selfLinkWithId?: string;
  /**
   * An array of URLs where each entry is the URL of a subnet provided by the
   * service consumer to use for endpoints in the producers that connect to this
   * network attachment.
   */
  subnetworks?: string[];
}

function serializeNetworkAttachment(data: any): NetworkAttachment {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeNetworkAttachment(data: any): NetworkAttachment {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

/**
 * Contains a list of NetworkAttachmentsScopedList.
 */
export interface NetworkAttachmentAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of NetworkAttachmentsScopedList resources.
   */
  items?: {
    [key: string]: NetworkAttachmentsScopedList
  };
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeNetworkAttachmentAggregatedList(data: any): NetworkAttachmentAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeNetworkAttachmentsScopedList(v)]))) : undefined,
  };
}

function deserializeNetworkAttachmentAggregatedList(data: any): NetworkAttachmentAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeNetworkAttachmentsScopedList(v)]))) : undefined,
  };
}

/**
 * [Output Only] A connection connected to this network attachment.
 */
export interface NetworkAttachmentConnectedEndpoint {
  /**
   * The IP address assigned to the producer instance network interface. This
   * value will be a range in case of Serverless.
   */
  ipAddress?: string;
  /**
   * The project id or number of the interface to which the IP was assigned.
   */
  projectIdOrNum?: string;
  /**
   * Alias IP ranges from the same subnetwork
   */
  secondaryIpCidrRanges?: string[];
  /**
   * The status of a connected endpoint to this network attachment.
   */
  status?:  | "ACCEPTED" | "CLOSED" | "NEEDS_ATTENTION" | "PENDING" | "REJECTED" | "STATUS_UNSPECIFIED";
  /**
   * The subnetwork used to assign the IP to the producer instance network
   * interface.
   */
  subnetwork?: string;
}

export interface NetworkAttachmentList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of NetworkAttachment resources.
   */
  items?: NetworkAttachment[];
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeNetworkAttachmentList(data: any): NetworkAttachmentList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeNetworkAttachment(item))) : undefined,
  };
}

function deserializeNetworkAttachmentList(data: any): NetworkAttachmentList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeNetworkAttachment(item))) : undefined,
  };
}

/**
 * Additional options for Compute#networkAttachmentsAggregatedList.
 */
export interface NetworkAttachmentsAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#networkAttachmentsDelete.
 */
export interface NetworkAttachmentsDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000). end_interface:
   * MixerMutationRequestBuilder
   */
  requestId?: string;
}

/**
 * Additional options for Compute#networkAttachmentsGetIamPolicy.
 */
export interface NetworkAttachmentsGetIamPolicyOptions {
  /**
   * Requested IAM Policy version.
   */
  optionsRequestedPolicyVersion?: number;
}

/**
 * Additional options for Compute#networkAttachmentsInsert.
 */
export interface NetworkAttachmentsInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000). end_interface:
   * MixerMutationRequestBuilder
   */
  requestId?: string;
}

/**
 * Additional options for Compute#networkAttachmentsList.
 */
export interface NetworkAttachmentsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface NetworkAttachmentsScopedList {
  /**
   * A list of NetworkAttachments contained in this scope.
   */
  networkAttachments?: NetworkAttachment[];
  /**
   * Informational warning which replaces the list of network attachments when
   * the list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeNetworkAttachmentsScopedList(data: any): NetworkAttachmentsScopedList {
  return {
    ...data,
    networkAttachments: data["networkAttachments"] !== undefined ? data["networkAttachments"].map((item: any) => (serializeNetworkAttachment(item))) : undefined,
  };
}

function deserializeNetworkAttachmentsScopedList(data: any): NetworkAttachmentsScopedList {
  return {
    ...data,
    networkAttachments: data["networkAttachments"] !== undefined ? data["networkAttachments"].map((item: any) => (deserializeNetworkAttachment(item))) : undefined,
  };
}

/**
 * Represents a Google Cloud Armor network edge security service resource.
 */
export interface NetworkEdgeSecurityService {
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * Fingerprint of this resource. A hash of the contents stored in this
   * object. This field is used in optimistic locking. This field will be
   * ignored when inserting a NetworkEdgeSecurityService. An up-to-date
   * fingerprint must be provided in order to update the
   * NetworkEdgeSecurityService, otherwise the request will fail with error 412
   * conditionNotMet. To see the latest fingerprint, make a get() request to
   * retrieve a NetworkEdgeSecurityService.
   */
  fingerprint?: Uint8Array;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output only] Type of the resource. Always
   * compute#networkEdgeSecurityService for NetworkEdgeSecurityServices
   */
  kind?: string;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * [Output Only] URL of the region where the resource resides. You must
   * specify this field as part of the HTTP request URL. It is not settable as a
   * field in the request body.
   */
  region?: string;
  /**
   * The resource URL for the network edge security service associated with
   * this network edge security service.
   */
  securityPolicy?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Server-defined URL for this resource with the resource id.
   */
  selfLinkWithId?: string;
}

function serializeNetworkEdgeSecurityService(data: any): NetworkEdgeSecurityService {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeNetworkEdgeSecurityService(data: any): NetworkEdgeSecurityService {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface NetworkEdgeSecurityServiceAggregatedList {
  etag?: string;
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of NetworkEdgeSecurityServicesScopedList resources.
   */
  items?: {
    [key: string]: NetworkEdgeSecurityServicesScopedList
  };
  /**
   * [Output Only] Type of resource. Always
   * compute#networkEdgeSecurityServiceAggregatedList for lists of Network Edge
   * Security Services.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeNetworkEdgeSecurityServiceAggregatedList(data: any): NetworkEdgeSecurityServiceAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeNetworkEdgeSecurityServicesScopedList(v)]))) : undefined,
  };
}

function deserializeNetworkEdgeSecurityServiceAggregatedList(data: any): NetworkEdgeSecurityServiceAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeNetworkEdgeSecurityServicesScopedList(v)]))) : undefined,
  };
}

/**
 * Additional options for Compute#networkEdgeSecurityServicesAggregatedList.
 */
export interface NetworkEdgeSecurityServicesAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#networkEdgeSecurityServicesDelete.
 */
export interface NetworkEdgeSecurityServicesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#networkEdgeSecurityServicesInsert.
 */
export interface NetworkEdgeSecurityServicesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
  /**
   * If true, the request will not be committed.
   */
  validateOnly?: boolean;
}

/**
 * Additional options for Compute#networkEdgeSecurityServicesPatch.
 */
export interface NetworkEdgeSecurityServicesPatchOptions {
  paths?: string;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
  /**
   * Indicates fields to be updated as part of this request.
   */
  updateMask?: string /* FieldMask */;
}

function serializeNetworkEdgeSecurityServicesPatchOptions(data: any): NetworkEdgeSecurityServicesPatchOptions {
  return {
    ...data,
    updateMask: data["updateMask"] !== undefined ? data["updateMask"] : undefined,
  };
}

function deserializeNetworkEdgeSecurityServicesPatchOptions(data: any): NetworkEdgeSecurityServicesPatchOptions {
  return {
    ...data,
    updateMask: data["updateMask"] !== undefined ? data["updateMask"] : undefined,
  };
}

export interface NetworkEdgeSecurityServicesScopedList {
  /**
   * A list of NetworkEdgeSecurityServices contained in this scope.
   */
  networkEdgeSecurityServices?: NetworkEdgeSecurityService[];
  /**
   * Informational warning which replaces the list of security policies when
   * the list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeNetworkEdgeSecurityServicesScopedList(data: any): NetworkEdgeSecurityServicesScopedList {
  return {
    ...data,
    networkEdgeSecurityServices: data["networkEdgeSecurityServices"] !== undefined ? data["networkEdgeSecurityServices"].map((item: any) => (serializeNetworkEdgeSecurityService(item))) : undefined,
  };
}

function deserializeNetworkEdgeSecurityServicesScopedList(data: any): NetworkEdgeSecurityServicesScopedList {
  return {
    ...data,
    networkEdgeSecurityServices: data["networkEdgeSecurityServices"] !== undefined ? data["networkEdgeSecurityServices"].map((item: any) => (deserializeNetworkEdgeSecurityService(item))) : undefined,
  };
}

/**
 * The network endpoint.
 */
export interface NetworkEndpoint {
  /**
   * Metadata defined as annotations on the network endpoint.
   */
  annotations?: {
    [key: string]: string
  };
  /**
   * Optional fully qualified domain name of network endpoint. This can only be
   * specified when NetworkEndpointGroup.network_endpoint_type is
   * NON_GCP_FQDN_PORT.
   */
  fqdn?: string;
  /**
   * The name for a specific VM instance that the IP address belongs to. This
   * is required for network endpoints of type GCE_VM_IP_PORT. The instance must
   * be in the same zone of network endpoint group. The name must be 1-63
   * characters long, and comply with RFC1035.
   */
  instance?: string;
  /**
   * Optional IPv4 address of network endpoint. The IP address must belong to a
   * VM in Compute Engine (either the primary IP or as part of an aliased IP
   * range). If the IP address is not specified, then the primary IP address for
   * the VM instance in the network that the network endpoint group belongs to
   * will be used.
   */
  ipAddress?: string;
  /**
   * Optional port number of network endpoint. If not specified, the
   * defaultPort for the network endpoint group will be used.
   */
  port?: number;
}

/**
 * Represents a collection of network endpoints. A network endpoint group (NEG)
 * defines how a set of endpoints should be reached, whether they are reachable,
 * and where they are located. For more information about using NEGs, see
 * Setting up external HTTP(S) Load Balancing with internet NEGs, Setting up
 * zonal NEGs, or Setting up external HTTP(S) Load Balancing with serverless
 * NEGs.
 */
export interface NetworkEndpointGroup {
  /**
   * Metadata defined as annotations on the network endpoint group.
   */
  annotations?: {
    [key: string]: string
  };
  /**
   * Only valid when networkEndpointType is "SERVERLESS". Only one of cloudRun,
   * appEngine or cloudFunction may be set.
   */
  appEngine?: NetworkEndpointGroupAppEngine;
  /**
   * Only valid when networkEndpointType is "SERVERLESS". Only one of cloudRun,
   * appEngine or cloudFunction may be set.
   */
  cloudFunction?: NetworkEndpointGroupCloudFunction;
  /**
   * Only valid when networkEndpointType is "SERVERLESS". Only one of cloudRun,
   * appEngine or cloudFunction may be set.
   */
  cloudRun?: NetworkEndpointGroupCloudRun;
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * The default port used if the port number is not specified in the network
   * endpoint.
   */
  defaultPort?: number;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of the resource. Always compute#networkEndpointGroup
   * for network endpoint group.
   */
  kind?: string;
  /**
   * Name of the resource; provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * The URL of the network to which all network endpoints in the NEG belong.
   * Uses "default" project network if unspecified.
   */
  network?: string;
  /**
   * Type of network endpoints in this network endpoint group. Can be one of
   * GCE_VM_IP, GCE_VM_IP_PORT, NON_GCP_PRIVATE_IP_PORT, INTERNET_FQDN_PORT,
   * INTERNET_IP_PORT, SERVERLESS, PRIVATE_SERVICE_CONNECT.
   */
  networkEndpointType?:  | "GCE_VM_IP" | "GCE_VM_IP_PORT" | "INTERNET_FQDN_PORT" | "INTERNET_IP_PORT" | "NON_GCP_PRIVATE_IP_PORT" | "PRIVATE_SERVICE_CONNECT" | "SERVERLESS";
  pscData?: NetworkEndpointGroupPscData;
  /**
   * The target service url used to set up private service connection to a
   * Google API or a PSC Producer Service Attachment. An example value is:
   * "asia-northeast3-cloudkms.googleapis.com"
   */
  pscTargetService?: string;
  /**
   * [Output Only] The URL of the region where the network endpoint group is
   * located.
   */
  region?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * [Output only] Number of network endpoints in the network endpoint group.
   */
  size?: number;
  /**
   * Optional URL of the subnetwork to which all network endpoints in the NEG
   * belong.
   */
  subnetwork?: string;
  /**
   * [Output Only] The URL of the zone where the network endpoint group is
   * located.
   */
  zone?: string;
}

function serializeNetworkEndpointGroup(data: any): NetworkEndpointGroup {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
    pscData: data["pscData"] !== undefined ? serializeNetworkEndpointGroupPscData(data["pscData"]) : undefined,
  };
}

function deserializeNetworkEndpointGroup(data: any): NetworkEndpointGroup {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
    pscData: data["pscData"] !== undefined ? deserializeNetworkEndpointGroupPscData(data["pscData"]) : undefined,
  };
}

export interface NetworkEndpointGroupAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of NetworkEndpointGroupsScopedList resources.
   */
  items?: {
    [key: string]: NetworkEndpointGroupsScopedList
  };
  /**
   * [Output Only] The resource type, which is always
   * compute#networkEndpointGroupAggregatedList for aggregated lists of network
   * endpoint groups.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeNetworkEndpointGroupAggregatedList(data: any): NetworkEndpointGroupAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeNetworkEndpointGroupsScopedList(v)]))) : undefined,
  };
}

function deserializeNetworkEndpointGroupAggregatedList(data: any): NetworkEndpointGroupAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeNetworkEndpointGroupsScopedList(v)]))) : undefined,
  };
}

/**
 * Configuration for an App Engine network endpoint group (NEG). The service is
 * optional, may be provided explicitly or in the URL mask. The version is
 * optional and can only be provided explicitly or in the URL mask when service
 * is present. Note: App Engine service must be in the same project and located
 * in the same region as the Serverless NEG.
 */
export interface NetworkEndpointGroupAppEngine {
  /**
   * Optional serving service. The service name is case-sensitive and must be
   * 1-63 characters long. Example value: "default", "my-service".
   */
  service?: string;
  /**
   * A template to parse service and version fields from a request URL. URL
   * mask allows for routing to multiple App Engine services without having to
   * create multiple Network Endpoint Groups and backend services. For example,
   * the request URLs "foo1-dot-appname.appspot.com/v1" and
   * "foo1-dot-appname.appspot.com/v2" can be backed by the same Serverless NEG
   * with URL mask "<service>-dot-appname.appspot.com/<version>". The URL mask
   * will parse them to { service = "foo1", version = "v1" } and { service =
   * "foo1", version = "v2" } respectively.
   */
  urlMask?: string;
  /**
   * Optional serving version. The version name is case-sensitive and must be
   * 1-100 characters long. Example value: "v1", "v2".
   */
  version?: string;
}

/**
 * Configuration for a Cloud Function network endpoint group (NEG). The
 * function must be provided explicitly or in the URL mask. Note: Cloud Function
 * must be in the same project and located in the same region as the Serverless
 * NEG.
 */
export interface NetworkEndpointGroupCloudFunction {
  /**
   * A user-defined name of the Cloud Function. The function name is
   * case-sensitive and must be 1-63 characters long. Example value: "func1".
   */
  function?: string;
  /**
   * A template to parse function field from a request URL. URL mask allows for
   * routing to multiple Cloud Functions without having to create multiple
   * Network Endpoint Groups and backend services. For example, request URLs "
   * mydomain.com/function1" and "mydomain.com/function2" can be backed by the
   * same Serverless NEG with URL mask "/<function>". The URL mask will parse
   * them to { function = "function1" } and { function = "function2" }
   * respectively.
   */
  urlMask?: string;
}

/**
 * Configuration for a Cloud Run network endpoint group (NEG). The service must
 * be provided explicitly or in the URL mask. The tag is optional, may be
 * provided explicitly or in the URL mask. Note: Cloud Run service must be in
 * the same project and located in the same region as the Serverless NEG.
 */
export interface NetworkEndpointGroupCloudRun {
  /**
   * Cloud Run service is the main resource of Cloud Run. The service must be
   * 1-63 characters long, and comply with RFC1035. Example value:
   * "run-service".
   */
  service?: string;
  /**
   * Optional Cloud Run tag represents the "named-revision" to provide
   * additional fine-grained traffic routing information. The tag must be 1-63
   * characters long, and comply with RFC1035. Example value: "revision-0010".
   */
  tag?: string;
  /**
   * A template to parse <service> and <tag> fields from a request URL. URL
   * mask allows for routing to multiple Run services without having to create
   * multiple network endpoint groups and backend services. For example, request
   * URLs "foo1.domain.com/bar1" and "foo1.domain.com/bar2" can be backed by the
   * same Serverless Network Endpoint Group (NEG) with URL mask
   * "<tag>.domain.com/<service>". The URL mask will parse them to {
   * service="bar1", tag="foo1" } and { service="bar2", tag="foo2" }
   * respectively.
   */
  urlMask?: string;
}

export interface NetworkEndpointGroupList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of NetworkEndpointGroup resources.
   */
  items?: NetworkEndpointGroup[];
  /**
   * [Output Only] The resource type, which is always
   * compute#networkEndpointGroupList for network endpoint group lists.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeNetworkEndpointGroupList(data: any): NetworkEndpointGroupList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeNetworkEndpointGroup(item))) : undefined,
  };
}

function deserializeNetworkEndpointGroupList(data: any): NetworkEndpointGroupList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeNetworkEndpointGroup(item))) : undefined,
  };
}

/**
 * All data that is specifically relevant to only network endpoint groups of
 * type PRIVATE_SERVICE_CONNECT.
 */
export interface NetworkEndpointGroupPscData {
  /**
   * [Output Only] Address allocated from given subnetwork for PSC. This IP
   * address acts as a VIP for a PSC NEG, allowing it to act as an endpoint in
   * L7 PSC-XLB.
   */
  consumerPscAddress?: string;
  /**
   * [Output Only] The PSC connection id of the PSC Network Endpoint Group
   * Consumer.
   */
  pscConnectionId?: bigint;
  /**
   * [Output Only] The connection status of the PSC Forwarding Rule.
   */
  pscConnectionStatus?:  | "ACCEPTED" | "CLOSED" | "NEEDS_ATTENTION" | "PENDING" | "REJECTED" | "STATUS_UNSPECIFIED";
}

function serializeNetworkEndpointGroupPscData(data: any): NetworkEndpointGroupPscData {
  return {
    ...data,
    pscConnectionId: data["pscConnectionId"] !== undefined ? String(data["pscConnectionId"]) : undefined,
  };
}

function deserializeNetworkEndpointGroupPscData(data: any): NetworkEndpointGroupPscData {
  return {
    ...data,
    pscConnectionId: data["pscConnectionId"] !== undefined ? BigInt(data["pscConnectionId"]) : undefined,
  };
}

/**
 * Additional options for Compute#networkEndpointGroupsAggregatedList.
 */
export interface NetworkEndpointGroupsAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface NetworkEndpointGroupsAttachEndpointsRequest {
  /**
   * The list of network endpoints to be attached.
   */
  networkEndpoints?: NetworkEndpoint[];
}

/**
 * Additional options for Compute#networkEndpointGroupsAttachNetworkEndpoints.
 */
export interface NetworkEndpointGroupsAttachNetworkEndpointsOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#networkEndpointGroupsDelete.
 */
export interface NetworkEndpointGroupsDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface NetworkEndpointGroupsDetachEndpointsRequest {
  /**
   * The list of network endpoints to be detached.
   */
  networkEndpoints?: NetworkEndpoint[];
}

/**
 * Additional options for Compute#networkEndpointGroupsDetachNetworkEndpoints.
 */
export interface NetworkEndpointGroupsDetachNetworkEndpointsOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#networkEndpointGroupsInsert.
 */
export interface NetworkEndpointGroupsInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface NetworkEndpointGroupsListEndpointsRequest {
  /**
   * Optional query parameter for showing the health status of each network
   * endpoint. Valid options are SKIP or SHOW. If you don't specify this
   * parameter, the health status of network endpoints will not be provided.
   */
  healthStatus?:  | "SHOW" | "SKIP";
}

export interface NetworkEndpointGroupsListNetworkEndpoints {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of NetworkEndpointWithHealthStatus resources.
   */
  items?: NetworkEndpointWithHealthStatus[];
  /**
   * [Output Only] The resource type, which is always
   * compute#networkEndpointGroupsListNetworkEndpoints for the list of network
   * endpoints in the specified network endpoint group.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

/**
 * Additional options for Compute#networkEndpointGroupsListNetworkEndpoints.
 */
export interface NetworkEndpointGroupsListNetworkEndpointsOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#networkEndpointGroupsList.
 */
export interface NetworkEndpointGroupsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface NetworkEndpointGroupsScopedList {
  /**
   * [Output Only] The list of network endpoint groups that are contained in
   * this scope.
   */
  networkEndpointGroups?: NetworkEndpointGroup[];
  /**
   * [Output Only] An informational warning that replaces the list of network
   * endpoint groups when the list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeNetworkEndpointGroupsScopedList(data: any): NetworkEndpointGroupsScopedList {
  return {
    ...data,
    networkEndpointGroups: data["networkEndpointGroups"] !== undefined ? data["networkEndpointGroups"].map((item: any) => (serializeNetworkEndpointGroup(item))) : undefined,
  };
}

function deserializeNetworkEndpointGroupsScopedList(data: any): NetworkEndpointGroupsScopedList {
  return {
    ...data,
    networkEndpointGroups: data["networkEndpointGroups"] !== undefined ? data["networkEndpointGroups"].map((item: any) => (deserializeNetworkEndpointGroup(item))) : undefined,
  };
}

export interface NetworkEndpointWithHealthStatus {
  /**
   * [Output only] The health status of network endpoint;
   */
  healths?: HealthStatusForNetworkEndpoint[];
  /**
   * [Output only] The network endpoint;
   */
  networkEndpoint?: NetworkEndpoint;
}

/**
 * Additional options for Compute#networkFirewallPoliciesAddAssociation.
 */
export interface NetworkFirewallPoliciesAddAssociationOptions {
  /**
   * Indicates whether or not to replace it if an association of the attachment
   * already exists. This is false by default, in which case an error will be
   * returned if an association already exists.
   */
  replaceExistingAssociation?: boolean;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#networkFirewallPoliciesAddRule.
 */
export interface NetworkFirewallPoliciesAddRuleOptions {
  /**
   * When rule.priority is not specified, auto choose a unused priority between
   * minPriority and maxPriority>. This field is exclusive with rule.priority.
   */
  maxPriority?: number;
  /**
   * When rule.priority is not specified, auto choose a unused priority between
   * minPriority and maxPriority>. This field is exclusive with rule.priority.
   */
  minPriority?: number;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#networkFirewallPoliciesCloneRules.
 */
export interface NetworkFirewallPoliciesCloneRulesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
  /**
   * The firewall policy from which to copy rules.
   */
  sourceFirewallPolicy?: string;
}

/**
 * Additional options for Compute#networkFirewallPoliciesDelete.
 */
export interface NetworkFirewallPoliciesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#networkFirewallPoliciesGetAssociation.
 */
export interface NetworkFirewallPoliciesGetAssociationOptions {
  /**
   * The name of the association to get from the firewall policy.
   */
  name?: string;
}

/**
 * Additional options for Compute#networkFirewallPoliciesGetIamPolicy.
 */
export interface NetworkFirewallPoliciesGetIamPolicyOptions {
  /**
   * Requested IAM Policy version.
   */
  optionsRequestedPolicyVersion?: number;
}

/**
 * Additional options for Compute#networkFirewallPoliciesGetRule.
 */
export interface NetworkFirewallPoliciesGetRuleOptions {
  /**
   * The priority of the rule to get from the firewall policy.
   */
  priority?: number;
}

/**
 * Additional options for Compute#networkFirewallPoliciesInsert.
 */
export interface NetworkFirewallPoliciesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#networkFirewallPoliciesList.
 */
export interface NetworkFirewallPoliciesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#networkFirewallPoliciesPatch.
 */
export interface NetworkFirewallPoliciesPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#networkFirewallPoliciesPatchRule.
 */
export interface NetworkFirewallPoliciesPatchRuleOptions {
  /**
   * The priority of the rule to patch.
   */
  priority?: number;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#networkFirewallPoliciesRemoveAssociation.
 */
export interface NetworkFirewallPoliciesRemoveAssociationOptions {
  /**
   * Name for the attachment that will be removed.
   */
  name?: string;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#networkFirewallPoliciesRemoveRule.
 */
export interface NetworkFirewallPoliciesRemoveRuleOptions {
  /**
   * The priority of the rule to remove from the firewall policy.
   */
  priority?: number;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * A network interface resource attached to an instance.
 */
export interface NetworkInterface {
  /**
   * An array of configurations for this interface. Currently, only one access
   * config, ONE_TO_ONE_NAT, is supported. If there are no accessConfigs
   * specified, then this instance will have no external internet access.
   */
  accessConfigs?: AccessConfig[];
  /**
   * An array of alias IP ranges for this network interface. You can only
   * specify this field for network interfaces in VPC networks.
   */
  aliasIpRanges?: AliasIpRange[];
  /**
   * Fingerprint hash of contents stored in this network interface. This field
   * will be ignored when inserting an Instance or adding a NetworkInterface. An
   * up-to-date fingerprint must be provided in order to update the
   * NetworkInterface. The request will fail with error 400 Bad Request if the
   * fingerprint is not provided, or 412 Precondition Failed if the fingerprint
   * is out of date.
   */
  fingerprint?: Uint8Array;
  /**
   * The prefix length of the primary internal IPv6 range.
   */
  internalIpv6PrefixLength?: number;
  /**
   * An array of IPv6 access configurations for this interface. Currently, only
   * one IPv6 access config, DIRECT_IPV6, is supported. If there is no
   * ipv6AccessConfig specified, then this instance will have no external IPv6
   * Internet access.
   */
  ipv6AccessConfigs?: AccessConfig[];
  /**
   * [Output Only] One of EXTERNAL, INTERNAL to indicate whether the IP can be
   * accessed from the Internet. This field is always inherited from its
   * subnetwork. Valid only if stackType is IPV4_IPV6.
   */
  ipv6AccessType?:  | "EXTERNAL" | "INTERNAL";
  /**
   * An IPv6 internal network address for this network interface. To use a
   * static internal IP address, it must be unused and in the same region as the
   * instance's zone. If not specified, Google Cloud will automatically assign
   * an internal IPv6 address from the instance's subnetwork.
   */
  ipv6Address?: string;
  /**
   * [Output Only] Type of the resource. Always compute#networkInterface for
   * network interfaces.
   */
  kind?: string;
  /**
   * [Output Only] The name of the network interface, which is generated by the
   * server. For a VM, the network interface uses the nicN naming format. Where
   * N is a value between 0 and 7. The default interface value is nic0.
   */
  name?: string;
  /**
   * URL of the VPC network resource for this instance. When creating an
   * instance, if neither the network nor the subnetwork is specified, the
   * default network global/networks/default is used. If the selected project
   * doesn't have the default network, you must specify a network or subnet. If
   * the network is not specified but the subnetwork is specified, the network
   * is inferred. If you specify this property, you can specify the network as a
   * full or partial URL. For example, the following are all valid URLs: -
   * https://www.googleapis.com/compute/v1/projects/project/global/networks/
   * network - projects/project/global/networks/network -
   * global/networks/default
   */
  network?: string;
  /**
   * The URL of the network attachment that this interface should connect to in
   * the following format:
   * projects/{project_number}/regions/{region_name}/networkAttachments/{network_attachment_name}.
   */
  networkAttachment?: string;
  /**
   * An IPv4 internal IP address to assign to the instance for this network
   * interface. If not specified by the user, an unused internal IP is assigned
   * by the system.
   */
  networkIP?: string;
  /**
   * The type of vNIC to be used on this interface. This may be gVNIC or
   * VirtioNet.
   */
  nicType?:  | "GVNIC" | "UNSPECIFIED_NIC_TYPE" | "VIRTIO_NET";
  /**
   * The networking queue count that's specified by users for the network
   * interface. Both Rx and Tx queues will be set to this number. It'll be empty
   * if not specified by the users.
   */
  queueCount?: number;
  /**
   * The stack type for this network interface to identify whether the IPv6
   * feature is enabled or not. If not specified, IPV4_ONLY will be used. This
   * field can be both set at instance creation and update network interface
   * operations.
   */
  stackType?:  | "IPV4_IPV6" | "IPV4_ONLY";
  /**
   * The URL of the Subnetwork resource for this instance. If the network
   * resource is in legacy mode, do not specify this field. If the network is in
   * auto subnet mode, specifying the subnetwork is optional. If the network is
   * in custom subnet mode, specifying the subnetwork is required. If you
   * specify this field, you can specify the subnetwork as a full or partial
   * URL. For example, the following are all valid URLs: -
   * https://www.googleapis.com/compute/v1/projects/project/regions/region
   * /subnetworks/subnetwork - regions/region/subnetworks/subnetwork
   */
  subnetwork?: string;
}

function serializeNetworkInterface(data: any): NetworkInterface {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
  };
}

function deserializeNetworkInterface(data: any): NetworkInterface {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
  };
}

/**
 * Contains a list of networks.
 */
export interface NetworkList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of Network resources.
   */
  items?: Network[];
  /**
   * [Output Only] Type of resource. Always compute#networkList for lists of
   * networks.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeNetworkList(data: any): NetworkList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeNetwork(item))) : undefined,
  };
}

function deserializeNetworkList(data: any): NetworkList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeNetwork(item))) : undefined,
  };
}

/**
 * A network peering attached to a network resource. The message includes the
 * peering name, peer network, peering state, and a flag indicating whether
 * Google Compute Engine should automatically create routes for the peering.
 */
export interface NetworkPeering {
  /**
   * This field will be deprecated soon. Use the exchange_subnet_routes field
   * instead. Indicates whether full mesh connectivity is created and managed
   * automatically between peered networks. Currently this field should always
   * be true since Google Compute Engine will automatically create and manage
   * subnetwork routes between two networks when peering state is ACTIVE.
   */
  autoCreateRoutes?: boolean;
  /**
   * Indicates whether full mesh connectivity is created and managed
   * automatically between peered networks. Currently this field should always
   * be true since Google Compute Engine will automatically create and manage
   * subnetwork routes between two networks when peering state is ACTIVE.
   */
  exchangeSubnetRoutes?: boolean;
  /**
   * Whether to export the custom routes to peer network. The default value is
   * false.
   */
  exportCustomRoutes?: boolean;
  /**
   * Whether subnet routes with public IP range are exported. The default value
   * is true, all subnet routes are exported. IPv4 special-use ranges are always
   * exported to peers and are not controlled by this field.
   */
  exportSubnetRoutesWithPublicIp?: boolean;
  /**
   * Whether to import the custom routes from peer network. The default value
   * is false.
   */
  importCustomRoutes?: boolean;
  /**
   * Whether subnet routes with public IP range are imported. The default value
   * is false. IPv4 special-use ranges are always imported from peers and are
   * not controlled by this field.
   */
  importSubnetRoutesWithPublicIp?: boolean;
  /**
   * Name of this peering. Provided by the client when the peering is created.
   * The name must comply with RFC1035. Specifically, the name must be 1-63
   * characters long and match regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`.
   * The first character must be a lowercase letter, and all the following
   * characters must be a dash, lowercase letter, or digit, except the last
   * character, which cannot be a dash.
   */
  name?: string;
  /**
   * The URL of the peer network. It can be either full URL or partial URL. The
   * peer network may belong to a different project. If the partial URL does not
   * contain project, it is assumed that the peer network is in the same project
   * as the current network.
   */
  network?: string;
  /**
   * Maximum Transmission Unit in bytes.
   */
  peerMtu?: number;
  /**
   * Which IP version(s) of traffic and routes are allowed to be imported or
   * exported between peer networks. The default value is IPV4_ONLY.
   */
  stackType?:  | "IPV4_IPV6" | "IPV4_ONLY";
  /**
   * [Output Only] State for the peering, either `ACTIVE` or `INACTIVE`. The
   * peering is `ACTIVE` when there's a matching configuration in the peer
   * network.
   */
  state?:  | "ACTIVE" | "INACTIVE";
  /**
   * [Output Only] Details about the current state of the peering.
   */
  stateDetails?: string;
}

export interface NetworkPerformanceConfig {
  totalEgressBandwidthTier?:  | "DEFAULT" | "TIER_1";
}

/**
 * A routing configuration attached to a network resource. The message includes
 * the list of routers associated with the network, and a flag indicating the
 * type of routing behavior to enforce network-wide.
 */
export interface NetworkRoutingConfig {
  /**
   * The network-wide routing mode to use. If set to REGIONAL, this network's
   * Cloud Routers will only advertise routes with subnets of this network in
   * the same region as the router. If set to GLOBAL, this network's Cloud
   * Routers will advertise routes with all subnets of this network, across
   * regions.
   */
  routingMode?:  | "GLOBAL" | "REGIONAL";
}

/**
 * Additional options for Compute#networksAddPeering.
 */
export interface NetworksAddPeeringOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface NetworksAddPeeringRequest {
  /**
   * This field will be deprecated soon. Use exchange_subnet_routes in
   * network_peering instead. Indicates whether full mesh connectivity is
   * created and managed automatically between peered networks. Currently this
   * field should always be true since Google Compute Engine will automatically
   * create and manage subnetwork routes between two networks when peering state
   * is ACTIVE.
   */
  autoCreateRoutes?: boolean;
  /**
   * Name of the peering, which should conform to RFC1035.
   */
  name?: string;
  /**
   * Network peering parameters. In order to specify route policies for peering
   * using import and export custom routes, you must specify all peering related
   * parameters (name, peer network, exchange_subnet_routes) in the
   * network_peering field. The corresponding fields in
   * NetworksAddPeeringRequest will be deprecated soon.
   */
  networkPeering?: NetworkPeering;
  /**
   * URL of the peer network. It can be either full URL or partial URL. The
   * peer network may belong to a different project. If the partial URL does not
   * contain project, it is assumed that the peer network is in the same project
   * as the current network.
   */
  peerNetwork?: string;
}

/**
 * Additional options for Compute#networksDelete.
 */
export interface NetworksDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface NetworksGetEffectiveFirewallsResponse {
  /**
   * Effective firewalls from firewall policy.
   */
  firewallPolicys?: NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy[];
  /**
   * Effective firewalls on the network.
   */
  firewalls?: Firewall[];
}

function serializeNetworksGetEffectiveFirewallsResponse(data: any): NetworksGetEffectiveFirewallsResponse {
  return {
    ...data,
    firewalls: data["firewalls"] !== undefined ? data["firewalls"].map((item: any) => (serializeFirewall(item))) : undefined,
  };
}

function deserializeNetworksGetEffectiveFirewallsResponse(data: any): NetworksGetEffectiveFirewallsResponse {
  return {
    ...data,
    firewalls: data["firewalls"] !== undefined ? data["firewalls"].map((item: any) => (deserializeFirewall(item))) : undefined,
  };
}

export interface NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy {
  /**
   * [Output Only] Deprecated, please use short name instead. The display name
   * of the firewall policy.
   */
  displayName?: string;
  /**
   * [Output Only] The name of the firewall policy.
   */
  name?: string;
  /**
   * The rules that apply to the network.
   */
  rules?: FirewallPolicyRule[];
  /**
   * [Output Only] The short name of the firewall policy.
   */
  shortName?: string;
  /**
   * [Output Only] The type of the firewall policy.
   */
  type?:  | "HIERARCHY" | "NETWORK" | "UNSPECIFIED";
}

/**
 * Additional options for Compute#networksInsert.
 */
export interface NetworksInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#networksList.
 */
export interface NetworksListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#networksListPeeringRoutes.
 */
export interface NetworksListPeeringRoutesOptions {
  /**
   * The direction of the exchanged routes.
   */
  direction?:  | "INCOMING" | "OUTGOING";
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * The response will show routes exchanged over the given peering connection.
   */
  peeringName?: string;
  /**
   * The region of the request. The response will include all subnet routes,
   * static routes and dynamic routes in the region.
   */
  region?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#networksPatch.
 */
export interface NetworksPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#networksRemovePeering.
 */
export interface NetworksRemovePeeringOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface NetworksRemovePeeringRequest {
  /**
   * Name of the peering, which should conform to RFC1035.
   */
  name?: string;
}

/**
 * Additional options for Compute#networksSwitchToCustomMode.
 */
export interface NetworksSwitchToCustomModeOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#networksUpdatePeering.
 */
export interface NetworksUpdatePeeringOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface NetworksUpdatePeeringRequest {
  networkPeering?: NetworkPeering;
}

/**
 * Represents a sole-tenant Node Group resource. A sole-tenant node is a
 * physical server that is dedicated to hosting VM instances only for your
 * specific project. Use sole-tenant nodes to keep your instances physically
 * separated from instances in other projects, or to group your instances
 * together on the same host hardware. For more information, read Sole-tenant
 * nodes.
 */
export interface NodeGroup {
  /**
   * Specifies how autoscaling should behave.
   */
  autoscalingPolicy?: NodeGroupAutoscalingPolicy;
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  fingerprint?: Uint8Array;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] The type of the resource. Always compute#nodeGroup for node
   * group.
   */
  kind?: string;
  /**
   * An opaque location hint used to place the Node close to other resources.
   * This field is for use by internal tools that use the public API. The
   * location hint here on the NodeGroup overrides any location_hint present in
   * the NodeTemplate.
   */
  locationHint?: string;
  /**
   * Specifies how to handle instances when a node in the group undergoes
   * maintenance. Set to one of: DEFAULT, RESTART_IN_PLACE, or
   * MIGRATE_WITHIN_NODE_GROUP. The default value is DEFAULT. For more
   * information, see Maintenance policies.
   */
  maintenancePolicy?:  | "DEFAULT" | "MAINTENANCE_POLICY_UNSPECIFIED" | "MIGRATE_WITHIN_NODE_GROUP" | "RESTART_IN_PLACE";
  maintenanceWindow?: NodeGroupMaintenanceWindow;
  /**
   * The name of the resource, provided by the client when initially creating
   * the resource. The resource name must be 1-63 characters long, and comply
   * with RFC1035. Specifically, the name must be 1-63 characters long and match
   * the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first
   * character must be a lowercase letter, and all following characters must be
   * a dash, lowercase letter, or digit, except the last character, which cannot
   * be a dash.
   */
  name?: string;
  /**
   * URL of the node template to create the node group from.
   */
  nodeTemplate?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * Share-settings for the node group
   */
  shareSettings?: ShareSettings;
  /**
   * [Output Only] The total number of nodes in the node group.
   */
  size?: number;
  status?:  | "CREATING" | "DELETING" | "INVALID" | "READY";
  /**
   * [Output Only] The name of the zone where the node group resides, such as
   * us-central1-a.
   */
  zone?: string;
}

function serializeNodeGroup(data: any): NodeGroup {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
    maintenanceWindow: data["maintenanceWindow"] !== undefined ? serializeNodeGroupMaintenanceWindow(data["maintenanceWindow"]) : undefined,
  };
}

function deserializeNodeGroup(data: any): NodeGroup {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
    maintenanceWindow: data["maintenanceWindow"] !== undefined ? deserializeNodeGroupMaintenanceWindow(data["maintenanceWindow"]) : undefined,
  };
}

export interface NodeGroupAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of NodeGroupsScopedList resources.
   */
  items?: {
    [key: string]: NodeGroupsScopedList
  };
  /**
   * [Output Only] Type of resource.Always compute#nodeGroupAggregatedList for
   * aggregated lists of node groups.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeNodeGroupAggregatedList(data: any): NodeGroupAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeNodeGroupsScopedList(v)]))) : undefined,
  };
}

function deserializeNodeGroupAggregatedList(data: any): NodeGroupAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeNodeGroupsScopedList(v)]))) : undefined,
  };
}

export interface NodeGroupAutoscalingPolicy {
  /**
   * The maximum number of nodes that the group should have. Must be set if
   * autoscaling is enabled. Maximum value allowed is 100.
   */
  maxNodes?: number;
  /**
   * The minimum number of nodes that the group should have.
   */
  minNodes?: number;
  /**
   * The autoscaling mode. Set to one of: ON, OFF, or ONLY_SCALE_OUT. For more
   * information, see Autoscaler modes.
   */
  mode?:  | "MODE_UNSPECIFIED" | "OFF" | "ON" | "ONLY_SCALE_OUT";
}

/**
 * Contains a list of nodeGroups.
 */
export interface NodeGroupList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of NodeGroup resources.
   */
  items?: NodeGroup[];
  /**
   * [Output Only] Type of resource.Always compute#nodeGroupList for lists of
   * node groups.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeNodeGroupList(data: any): NodeGroupList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeNodeGroup(item))) : undefined,
  };
}

function deserializeNodeGroupList(data: any): NodeGroupList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeNodeGroup(item))) : undefined,
  };
}

/**
 * Time window specified for daily maintenance operations. GCE's internal
 * maintenance will be performed within this window.
 */
export interface NodeGroupMaintenanceWindow {
  /**
   * [Output only] A predetermined duration for the window, automatically
   * chosen to be the smallest possible in the given scenario.
   */
  maintenanceDuration?: Duration;
  /**
   * Start time of the window. This must be in UTC format that resolves to one
   * of 00:00, 04:00, 08:00, 12:00, 16:00, or 20:00. For example, both 13:00-5
   * and 08:00 are valid.
   */
  startTime?: string;
}

function serializeNodeGroupMaintenanceWindow(data: any): NodeGroupMaintenanceWindow {
  return {
    ...data,
    maintenanceDuration: data["maintenanceDuration"] !== undefined ? serializeDuration(data["maintenanceDuration"]) : undefined,
  };
}

function deserializeNodeGroupMaintenanceWindow(data: any): NodeGroupMaintenanceWindow {
  return {
    ...data,
    maintenanceDuration: data["maintenanceDuration"] !== undefined ? deserializeDuration(data["maintenanceDuration"]) : undefined,
  };
}

export interface NodeGroupNode {
  /**
   * Accelerators for this node.
   */
  accelerators?: AcceleratorConfig[];
  /**
   * Node resources that are reserved by all instances.
   */
  consumedResources?: InstanceConsumptionInfo;
  /**
   * CPU overcommit.
   */
  cpuOvercommitType?:  | "CPU_OVERCOMMIT_TYPE_UNSPECIFIED" | "ENABLED" | "NONE";
  /**
   * Local disk configurations.
   */
  disks?: LocalDisk[];
  /**
   * Instance data that shows consumed resources on the node.
   */
  instanceConsumptionData?: InstanceConsumptionData[];
  /**
   * Instances scheduled on this node.
   */
  instances?: string[];
  /**
   * The name of the node.
   */
  name?: string;
  /**
   * The type of this node.
   */
  nodeType?: string;
  /**
   * [Output Only] Reserved for future use.
   */
  satisfiesPzs?: boolean;
  /**
   * Binding properties for the physical server.
   */
  serverBinding?: ServerBinding;
  /**
   * Server ID associated with this node.
   */
  serverId?: string;
  status?:  | "CREATING" | "DELETING" | "INVALID" | "READY" | "REPAIRING";
  /**
   * Total amount of available resources on the node.
   */
  totalResources?: InstanceConsumptionInfo;
}

/**
 * Additional options for Compute#nodeGroupsAddNodes.
 */
export interface NodeGroupsAddNodesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface NodeGroupsAddNodesRequest {
  /**
   * Count of additional nodes to be added to the node group.
   */
  additionalNodeCount?: number;
}

/**
 * Additional options for Compute#nodeGroupsAggregatedList.
 */
export interface NodeGroupsAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#nodeGroupsDeleteNodes.
 */
export interface NodeGroupsDeleteNodesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface NodeGroupsDeleteNodesRequest {
  /**
   * Names of the nodes to delete.
   */
  nodes?: string[];
}

/**
 * Additional options for Compute#nodeGroupsDelete.
 */
export interface NodeGroupsDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#nodeGroupsGetIamPolicy.
 */
export interface NodeGroupsGetIamPolicyOptions {
  /**
   * Requested IAM Policy version.
   */
  optionsRequestedPolicyVersion?: number;
}

/**
 * Additional options for Compute#nodeGroupsInsert.
 */
export interface NodeGroupsInsertOptions {
  /**
   * Initial count of nodes in the node group.
   */
  initialNodeCount: number;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface NodeGroupsListNodes {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of Node resources.
   */
  items?: NodeGroupNode[];
  /**
   * [Output Only] The resource type, which is always
   * compute.nodeGroupsListNodes for the list of nodes in the specified node
   * group.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

/**
 * Additional options for Compute#nodeGroupsListNodes.
 */
export interface NodeGroupsListNodesOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#nodeGroupsList.
 */
export interface NodeGroupsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#nodeGroupsPatch.
 */
export interface NodeGroupsPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface NodeGroupsScopedList {
  /**
   * [Output Only] A list of node groups contained in this scope.
   */
  nodeGroups?: NodeGroup[];
  /**
   * [Output Only] An informational warning that appears when the nodeGroup
   * list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeNodeGroupsScopedList(data: any): NodeGroupsScopedList {
  return {
    ...data,
    nodeGroups: data["nodeGroups"] !== undefined ? data["nodeGroups"].map((item: any) => (serializeNodeGroup(item))) : undefined,
  };
}

function deserializeNodeGroupsScopedList(data: any): NodeGroupsScopedList {
  return {
    ...data,
    nodeGroups: data["nodeGroups"] !== undefined ? data["nodeGroups"].map((item: any) => (deserializeNodeGroup(item))) : undefined,
  };
}

/**
 * Additional options for Compute#nodeGroupsSetNodeTemplate.
 */
export interface NodeGroupsSetNodeTemplateOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface NodeGroupsSetNodeTemplateRequest {
  /**
   * Full or partial URL of the node template resource to be updated for this
   * node group.
   */
  nodeTemplate?: string;
}

/**
 * Represent a sole-tenant Node Template resource. You can use a template to
 * define properties for nodes in a node group. For more information, read
 * Creating node groups and instances.
 */
export interface NodeTemplate {
  accelerators?: AcceleratorConfig[];
  /**
   * CPU overcommit.
   */
  cpuOvercommitType?:  | "CPU_OVERCOMMIT_TYPE_UNSPECIFIED" | "ENABLED" | "NONE";
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  disks?: LocalDisk[];
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] The type of the resource. Always compute#nodeTemplate for
   * node templates.
   */
  kind?: string;
  /**
   * The name of the resource, provided by the client when initially creating
   * the resource. The resource name must be 1-63 characters long, and comply
   * with RFC1035. Specifically, the name must be 1-63 characters long and match
   * the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first
   * character must be a lowercase letter, and all following characters must be
   * a dash, lowercase letter, or digit, except the last character, which cannot
   * be a dash.
   */
  name?: string;
  /**
   * Labels to use for node affinity, which will be used in instance
   * scheduling.
   */
  nodeAffinityLabels?: {
    [key: string]: string
  };
  /**
   * The node type to use for nodes group that are created from this template.
   */
  nodeType?: string;
  /**
   * Do not use. Instead, use the node_type property.
   */
  nodeTypeFlexibility?: NodeTemplateNodeTypeFlexibility;
  /**
   * [Output Only] The name of the region where the node template resides, such
   * as us-central1.
   */
  region?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * Sets the binding properties for the physical server. Valid values include:
   * - *[Default]* RESTART_NODE_ON_ANY_SERVER: Restarts VMs on any available
   * physical server - RESTART_NODE_ON_MINIMAL_SERVER: Restarts VMs on the same
   * physical server whenever possible See Sole-tenant node options for more
   * information.
   */
  serverBinding?: ServerBinding;
  /**
   * [Output Only] The status of the node template. One of the following
   * values: CREATING, READY, and DELETING.
   */
  status?:  | "CREATING" | "DELETING" | "INVALID" | "READY";
  /**
   * [Output Only] An optional, human-readable explanation of the status.
   */
  statusMessage?: string;
}

function serializeNodeTemplate(data: any): NodeTemplate {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeNodeTemplate(data: any): NodeTemplate {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface NodeTemplateAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of NodeTemplatesScopedList resources.
   */
  items?: {
    [key: string]: NodeTemplatesScopedList
  };
  /**
   * [Output Only] Type of resource.Always compute#nodeTemplateAggregatedList
   * for aggregated lists of node templates.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeNodeTemplateAggregatedList(data: any): NodeTemplateAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeNodeTemplatesScopedList(v)]))) : undefined,
  };
}

function deserializeNodeTemplateAggregatedList(data: any): NodeTemplateAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeNodeTemplatesScopedList(v)]))) : undefined,
  };
}

/**
 * Contains a list of node templates.
 */
export interface NodeTemplateList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of NodeTemplate resources.
   */
  items?: NodeTemplate[];
  /**
   * [Output Only] Type of resource.Always compute#nodeTemplateList for lists
   * of node templates.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeNodeTemplateList(data: any): NodeTemplateList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeNodeTemplate(item))) : undefined,
  };
}

function deserializeNodeTemplateList(data: any): NodeTemplateList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeNodeTemplate(item))) : undefined,
  };
}

export interface NodeTemplateNodeTypeFlexibility {
  cpus?: string;
  localSsd?: string;
  memory?: string;
}

/**
 * Additional options for Compute#nodeTemplatesAggregatedList.
 */
export interface NodeTemplatesAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#nodeTemplatesDelete.
 */
export interface NodeTemplatesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#nodeTemplatesGetIamPolicy.
 */
export interface NodeTemplatesGetIamPolicyOptions {
  /**
   * Requested IAM Policy version.
   */
  optionsRequestedPolicyVersion?: number;
}

/**
 * Additional options for Compute#nodeTemplatesInsert.
 */
export interface NodeTemplatesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#nodeTemplatesList.
 */
export interface NodeTemplatesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface NodeTemplatesScopedList {
  /**
   * [Output Only] A list of node templates contained in this scope.
   */
  nodeTemplates?: NodeTemplate[];
  /**
   * [Output Only] An informational warning that appears when the node
   * templates list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeNodeTemplatesScopedList(data: any): NodeTemplatesScopedList {
  return {
    ...data,
    nodeTemplates: data["nodeTemplates"] !== undefined ? data["nodeTemplates"].map((item: any) => (serializeNodeTemplate(item))) : undefined,
  };
}

function deserializeNodeTemplatesScopedList(data: any): NodeTemplatesScopedList {
  return {
    ...data,
    nodeTemplates: data["nodeTemplates"] !== undefined ? data["nodeTemplates"].map((item: any) => (deserializeNodeTemplate(item))) : undefined,
  };
}

/**
 * Represent a sole-tenant Node Type resource. Each node within a node group
 * must have a node type. A node type specifies the total amount of cores and
 * memory for that node. Currently, the only available node type is
 * n1-node-96-624 node type that has 96 vCPUs and 624 GB of memory, available in
 * multiple zones. For more information read Node types.
 */
export interface NodeType {
  /**
   * [Output Only] The CPU platform used by this node type.
   */
  cpuPlatform?: string;
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * [Output Only] The deprecation status associated with this node type.
   */
  deprecated?: DeprecationStatus;
  /**
   * [Output Only] An optional textual description of the resource.
   */
  description?: string;
  /**
   * [Output Only] The number of virtual CPUs that are available to the node
   * type.
   */
  guestCpus?: number;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] The type of the resource. Always compute#nodeType for node
   * types.
   */
  kind?: string;
  /**
   * [Output Only] Local SSD available to the node type, defined in GB.
   */
  localSsdGb?: number;
  /**
   * [Output Only] The amount of physical memory available to the node type,
   * defined in MB.
   */
  memoryMb?: number;
  /**
   * [Output Only] Name of the resource.
   */
  name?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * [Output Only] The name of the zone where the node type resides, such as
   * us-central1-a.
   */
  zone?: string;
}

function serializeNodeType(data: any): NodeType {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeNodeType(data: any): NodeType {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface NodeTypeAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of NodeTypesScopedList resources.
   */
  items?: {
    [key: string]: NodeTypesScopedList
  };
  /**
   * [Output Only] Type of resource.Always compute#nodeTypeAggregatedList for
   * aggregated lists of node types.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeNodeTypeAggregatedList(data: any): NodeTypeAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeNodeTypesScopedList(v)]))) : undefined,
  };
}

function deserializeNodeTypeAggregatedList(data: any): NodeTypeAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeNodeTypesScopedList(v)]))) : undefined,
  };
}

/**
 * Contains a list of node types.
 */
export interface NodeTypeList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of NodeType resources.
   */
  items?: NodeType[];
  /**
   * [Output Only] Type of resource.Always compute#nodeTypeList for lists of
   * node types.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeNodeTypeList(data: any): NodeTypeList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeNodeType(item))) : undefined,
  };
}

function deserializeNodeTypeList(data: any): NodeTypeList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeNodeType(item))) : undefined,
  };
}

/**
 * Additional options for Compute#nodeTypesAggregatedList.
 */
export interface NodeTypesAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#nodeTypesList.
 */
export interface NodeTypesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface NodeTypesScopedList {
  /**
   * [Output Only] A list of node types contained in this scope.
   */
  nodeTypes?: NodeType[];
  /**
   * [Output Only] An informational warning that appears when the node types
   * list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeNodeTypesScopedList(data: any): NodeTypesScopedList {
  return {
    ...data,
    nodeTypes: data["nodeTypes"] !== undefined ? data["nodeTypes"].map((item: any) => (serializeNodeType(item))) : undefined,
  };
}

function deserializeNodeTypesScopedList(data: any): NodeTypesScopedList {
  return {
    ...data,
    nodeTypes: data["nodeTypes"] !== undefined ? data["nodeTypes"].map((item: any) => (deserializeNodeType(item))) : undefined,
  };
}

/**
 * Represents a notification endpoint. A notification endpoint resource defines
 * an endpoint to receive notifications when there are status changes detected
 * by the associated health check service. For more information, see Health
 * checks overview.
 */
export interface NotificationEndpoint {
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * Settings of the gRPC notification endpoint including the endpoint URL and
   * the retry duration.
   */
  grpcSettings?: NotificationEndpointGrpcSettings;
  /**
   * [Output Only] A unique identifier for this resource type. The server
   * generates this identifier.
   */
  id?: bigint;
  /**
   * [Output Only] Type of the resource. Always compute#notificationEndpoint
   * for notification endpoints.
   */
  kind?: string;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * [Output Only] URL of the region where the notification endpoint resides.
   * This field applies only to the regional resource. You must specify this
   * field as part of the HTTP request URL. It is not settable as a field in the
   * request body.
   */
  region?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
}

function serializeNotificationEndpoint(data: any): NotificationEndpoint {
  return {
    ...data,
    grpcSettings: data["grpcSettings"] !== undefined ? serializeNotificationEndpointGrpcSettings(data["grpcSettings"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeNotificationEndpoint(data: any): NotificationEndpoint {
  return {
    ...data,
    grpcSettings: data["grpcSettings"] !== undefined ? deserializeNotificationEndpointGrpcSettings(data["grpcSettings"]) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

/**
 * Represents a gRPC setting that describes one gRPC notification endpoint and
 * the retry duration attempting to send notification to this endpoint.
 */
export interface NotificationEndpointGrpcSettings {
  /**
   * Optional. If specified, this field is used to set the authority header by
   * the sender of notifications. See
   * https://tools.ietf.org/html/rfc7540#section-8.1.2.3
   */
  authority?: string;
  /**
   * Endpoint to which gRPC notifications are sent. This must be a valid gRPCLB
   * DNS name.
   */
  endpoint?: string;
  /**
   * Optional. If specified, this field is used to populate the "name" field in
   * gRPC requests.
   */
  payloadName?: string;
  /**
   * Optional. This field is used to configure how often to send a full update
   * of all non-healthy backends. If unspecified, full updates are not sent. If
   * specified, must be in the range between 600 seconds to 3600 seconds. Nanos
   * are disallowed. Can only be set for regional notification endpoints.
   */
  resendInterval?: Duration;
  /**
   * How much time (in seconds) is spent attempting notification retries until
   * a successful response is received. Default is 30s. Limit is 20m (1200s).
   * Must be a positive number.
   */
  retryDurationSec?: number;
}

function serializeNotificationEndpointGrpcSettings(data: any): NotificationEndpointGrpcSettings {
  return {
    ...data,
    resendInterval: data["resendInterval"] !== undefined ? serializeDuration(data["resendInterval"]) : undefined,
  };
}

function deserializeNotificationEndpointGrpcSettings(data: any): NotificationEndpointGrpcSettings {
  return {
    ...data,
    resendInterval: data["resendInterval"] !== undefined ? deserializeDuration(data["resendInterval"]) : undefined,
  };
}

export interface NotificationEndpointList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of NotificationEndpoint resources.
   */
  items?: NotificationEndpoint[];
  /**
   * [Output Only] Type of the resource. Always compute#notificationEndpoint
   * for notification endpoints.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeNotificationEndpointList(data: any): NotificationEndpointList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeNotificationEndpoint(item))) : undefined,
  };
}

function deserializeNotificationEndpointList(data: any): NotificationEndpointList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeNotificationEndpoint(item))) : undefined,
  };
}

/**
 * Represents an Operation resource. Google Compute Engine has three Operation
 * resources: * [Global](/compute/docs/reference/rest/v1/globalOperations) *
 * [Regional](/compute/docs/reference/rest/v1/regionOperations) *
 * [Zonal](/compute/docs/reference/rest/v1/zoneOperations) You can use an
 * operation resource to manage asynchronous API requests. For more information,
 * read Handling API responses. Operations can be global, regional or zonal. -
 * For global operations, use the `globalOperations` resource. - For regional
 * operations, use the `regionOperations` resource. - For zonal operations, use
 * the `zonalOperations` resource. For more information, read Global, Regional,
 * and Zonal Resources.
 */
export interface Operation {
  /**
   * [Output Only] The value of `requestId` if you provided it in the request.
   * Not present otherwise.
   */
  clientOperationId?: string;
  /**
   * [Deprecated] This field is deprecated.
   */
  creationTimestamp?: string;
  /**
   * [Output Only] A textual description of the operation, which is set when
   * the operation is created.
   */
  description?: string;
  /**
   * [Output Only] The time that this operation was completed. This value is in
   * RFC3339 text format.
   */
  endTime?: string;
  /**
   * [Output Only] If errors are generated during processing of the operation,
   * this field will be populated.
   */
  error?: {
    errors?: {
      code?: string;
      errorDetails?: {
        errorInfo?: ErrorInfo;
        help?: Help;
        localizedMessage?: LocalizedMessage;
        quotaInfo?: QuotaExceededInfo;
      }[];
      location?: string;
      message?: string;
    }[];
  };
  /**
   * [Output Only] If the operation fails, this field contains the HTTP error
   * message that was returned, such as `NOT FOUND`.
   */
  httpErrorMessage?: string;
  /**
   * [Output Only] If the operation fails, this field contains the HTTP error
   * status code that was returned. For example, a `404` means the resource was
   * not found.
   */
  httpErrorStatusCode?: number;
  /**
   * [Output Only] The unique identifier for the operation. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] The time that this operation was requested. This value is in
   * RFC3339 text format.
   */
  insertTime?: string;
  /**
   * [Output Only] Type of the resource. Always `compute#operation` for
   * Operation resources.
   */
  kind?: string;
  /**
   * [Output Only] Name of the operation.
   */
  name?: string;
  /**
   * [Output Only] An ID that represents a group of operations, such as when a
   * group of operations results from a `bulkInsert` API request.
   */
  operationGroupId?: string;
  /**
   * [Output Only] The type of operation, such as `insert`, `update`, or
   * `delete`, and so on.
   */
  operationType?: string;
  /**
   * [Output Only] An optional progress indicator that ranges from 0 to 100.
   * There is no requirement that this be linear or support any granularity of
   * operations. This should not be used to guess when the operation will be
   * complete. This number should monotonically increase as the operation
   * progresses.
   */
  progress?: number;
  /**
   * [Output Only] The URL of the region where the operation resides. Only
   * applicable when performing regional operations.
   */
  region?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * [Output Only] The time that this operation was started by the server. This
   * value is in RFC3339 text format.
   */
  startTime?: string;
  /**
   * [Output Only] The status of the operation, which can be one of the
   * following: `PENDING`, `RUNNING`, or `DONE`.
   */
  status?:  | "DONE" | "PENDING" | "RUNNING";
  /**
   * [Output Only] An optional textual description of the current status of the
   * operation.
   */
  statusMessage?: string;
  /**
   * [Output Only] The unique target ID, which identifies a specific
   * incarnation of the target resource.
   */
  targetId?: bigint;
  /**
   * [Output Only] The URL of the resource that the operation modifies. For
   * operations related to creating a snapshot, this points to the persistent
   * disk that the snapshot was created from.
   */
  targetLink?: string;
  /**
   * [Output Only] User who requested the operation, for example:
   * `user@example.com`.
   */
  user?: string;
  /**
   * [Output Only] If warning messages are generated during processing of the
   * operation, this field will be populated.
   */
  warnings?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  }[];
  /**
   * [Output Only] The URL of the zone where the operation resides. Only
   * applicable when performing per-zone operations.
   */
  zone?: string;
}

function serializeOperation(data: any): Operation {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
    targetId: data["targetId"] !== undefined ? String(data["targetId"]) : undefined,
  };
}

function deserializeOperation(data: any): Operation {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
    targetId: data["targetId"] !== undefined ? BigInt(data["targetId"]) : undefined,
  };
}

export interface OperationAggregatedList {
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: string;
  /**
   * [Output Only] A map of scoped operation lists.
   */
  items?: {
    [key: string]: OperationsScopedList
  };
  /**
   * [Output Only] Type of resource. Always `compute#operationAggregatedList`
   * for aggregated lists of operations.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than `maxResults`, use
   * the `nextPageToken` as a value for the query parameter `pageToken` in the
   * next list request. Subsequent list requests will have their own
   * `nextPageToken` to continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeOperationAggregatedList(data: any): OperationAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeOperationsScopedList(v)]))) : undefined,
  };
}

function deserializeOperationAggregatedList(data: any): OperationAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeOperationsScopedList(v)]))) : undefined,
  };
}

/**
 * Contains a list of Operation resources.
 */
export interface OperationList {
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: string;
  /**
   * [Output Only] A list of Operation resources.
   */
  items?: Operation[];
  /**
   * [Output Only] Type of resource. Always `compute#operations` for Operations
   * resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than `maxResults`, use
   * the `nextPageToken` as a value for the query parameter `pageToken` in the
   * next list request. Subsequent list requests will have their own
   * `nextPageToken` to continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeOperationList(data: any): OperationList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeOperation(item))) : undefined,
  };
}

function deserializeOperationList(data: any): OperationList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeOperation(item))) : undefined,
  };
}

export interface OperationsScopedList {
  /**
   * [Output Only] A list of operations contained in this scope.
   */
  operations?: Operation[];
  /**
   * [Output Only] Informational warning which replaces the list of operations
   * when the list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeOperationsScopedList(data: any): OperationsScopedList {
  return {
    ...data,
    operations: data["operations"] !== undefined ? data["operations"].map((item: any) => (serializeOperation(item))) : undefined,
  };
}

function deserializeOperationsScopedList(data: any): OperationsScopedList {
  return {
    ...data,
    operations: data["operations"] !== undefined ? data["operations"].map((item: any) => (deserializeOperation(item))) : undefined,
  };
}

/**
 * Settings controlling the eviction of unhealthy hosts from the load balancing
 * pool for the backend service.
 */
export interface OutlierDetection {
  /**
   * The base time that a host is ejected for. The real ejection time is equal
   * to the base ejection time multiplied by the number of times the host has
   * been ejected. Defaults to 30000ms or 30s.
   */
  baseEjectionTime?: Duration;
  /**
   * Number of errors before a host is ejected from the connection pool. When
   * the backend host is accessed over HTTP, a 5xx return code qualifies as an
   * error. Defaults to 5. Not supported when the backend service is referenced
   * by a URL map that is bound to target gRPC proxy that has
   * validateForProxyless field set to true.
   */
  consecutiveErrors?: number;
  /**
   * The number of consecutive gateway failures (502, 503, 504 status or
   * connection errors that are mapped to one of those status codes) before a
   * consecutive gateway failure ejection occurs. Defaults to 3. Not supported
   * when the backend service is referenced by a URL map that is bound to target
   * gRPC proxy that has validateForProxyless field set to true.
   */
  consecutiveGatewayFailure?: number;
  /**
   * The percentage chance that a host will be actually ejected when an outlier
   * status is detected through consecutive 5xx. This setting can be used to
   * disable ejection or to ramp it up slowly. Defaults to 0. Not supported when
   * the backend service is referenced by a URL map that is bound to target gRPC
   * proxy that has validateForProxyless field set to true.
   */
  enforcingConsecutiveErrors?: number;
  /**
   * The percentage chance that a host will be actually ejected when an outlier
   * status is detected through consecutive gateway failures. This setting can
   * be used to disable ejection or to ramp it up slowly. Defaults to 100. Not
   * supported when the backend service is referenced by a URL map that is bound
   * to target gRPC proxy that has validateForProxyless field set to true.
   */
  enforcingConsecutiveGatewayFailure?: number;
  /**
   * The percentage chance that a host will be actually ejected when an outlier
   * status is detected through success rate statistics. This setting can be
   * used to disable ejection or to ramp it up slowly. Defaults to 100.
   */
  enforcingSuccessRate?: number;
  /**
   * Time interval between ejection analysis sweeps. This can result in both
   * new ejections as well as hosts being returned to service. Defaults to 1
   * second.
   */
  interval?: Duration;
  /**
   * Maximum percentage of hosts in the load balancing pool for the backend
   * service that can be ejected. Defaults to 50%.
   */
  maxEjectionPercent?: number;
  /**
   * The number of hosts in a cluster that must have enough request volume to
   * detect success rate outliers. If the number of hosts is less than this
   * setting, outlier detection via success rate statistics is not performed for
   * any host in the cluster. Defaults to 5.
   */
  successRateMinimumHosts?: number;
  /**
   * The minimum number of total requests that must be collected in one
   * interval (as defined by the interval duration above) to include this host
   * in success rate based outlier detection. If the volume is lower than this
   * setting, outlier detection via success rate statistics is not performed for
   * that host. Defaults to 100.
   */
  successRateRequestVolume?: number;
  /**
   * This factor is used to determine the ejection threshold for success rate
   * outlier ejection. The ejection threshold is the difference between the mean
   * success rate, and the product of this factor and the standard deviation of
   * the mean success rate: mean - (stdev * success_rate_stdev_factor). This
   * factor is divided by a thousand to get a double. That is, if the desired
   * factor is 1.9, the runtime value should be 1900. Defaults to 1900.
   */
  successRateStdevFactor?: number;
}

function serializeOutlierDetection(data: any): OutlierDetection {
  return {
    ...data,
    baseEjectionTime: data["baseEjectionTime"] !== undefined ? serializeDuration(data["baseEjectionTime"]) : undefined,
    interval: data["interval"] !== undefined ? serializeDuration(data["interval"]) : undefined,
  };
}

function deserializeOutlierDetection(data: any): OutlierDetection {
  return {
    ...data,
    baseEjectionTime: data["baseEjectionTime"] !== undefined ? deserializeDuration(data["baseEjectionTime"]) : undefined,
    interval: data["interval"] !== undefined ? deserializeDuration(data["interval"]) : undefined,
  };
}

/**
 * Next free: 7
 */
export interface PacketIntervals {
  /**
   * Average observed inter-packet interval in milliseconds.
   */
  avgMs?: bigint;
  /**
   * From how long ago in the past these intervals were observed.
   */
  duration?:  | "DURATION_UNSPECIFIED" | "HOUR" | "MAX" | "MINUTE";
  /**
   * Maximum observed inter-packet interval in milliseconds.
   */
  maxMs?: bigint;
  /**
   * Minimum observed inter-packet interval in milliseconds.
   */
  minMs?: bigint;
  /**
   * Number of inter-packet intervals from which these statistics were derived.
   */
  numIntervals?: bigint;
  /**
   * The type of packets for which inter-packet intervals were computed.
   */
  type?:  | "LOOPBACK" | "RECEIVE" | "TRANSMIT" | "TYPE_UNSPECIFIED";
}

function serializePacketIntervals(data: any): PacketIntervals {
  return {
    ...data,
    avgMs: data["avgMs"] !== undefined ? String(data["avgMs"]) : undefined,
    maxMs: data["maxMs"] !== undefined ? String(data["maxMs"]) : undefined,
    minMs: data["minMs"] !== undefined ? String(data["minMs"]) : undefined,
    numIntervals: data["numIntervals"] !== undefined ? String(data["numIntervals"]) : undefined,
  };
}

function deserializePacketIntervals(data: any): PacketIntervals {
  return {
    ...data,
    avgMs: data["avgMs"] !== undefined ? BigInt(data["avgMs"]) : undefined,
    maxMs: data["maxMs"] !== undefined ? BigInt(data["maxMs"]) : undefined,
    minMs: data["minMs"] !== undefined ? BigInt(data["minMs"]) : undefined,
    numIntervals: data["numIntervals"] !== undefined ? BigInt(data["numIntervals"]) : undefined,
  };
}

/**
 * Represents a Packet Mirroring resource. Packet Mirroring clones the traffic
 * of specified instances in your Virtual Private Cloud (VPC) network and
 * forwards it to a collector destination, such as an instance group of an
 * internal TCP/UDP load balancer, for analysis or examination. For more
 * information about setting up Packet Mirroring, see Using Packet Mirroring.
 */
export interface PacketMirroring {
  /**
   * The Forwarding Rule resource of type loadBalancingScheme=INTERNAL that
   * will be used as collector for mirrored traffic. The specified forwarding
   * rule must have isMirroringCollector set to true.
   */
  collectorIlb?: PacketMirroringForwardingRuleInfo;
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * Indicates whether or not this packet mirroring takes effect. If set to
   * FALSE, this packet mirroring policy will not be enforced on the network.
   * The default is TRUE.
   */
  enable?:  | "FALSE" | "TRUE";
  /**
   * Filter for mirrored traffic. If unspecified, all traffic is mirrored.
   */
  filter?: PacketMirroringFilter;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of the resource. Always compute#packetMirroring for
   * packet mirrorings.
   */
  kind?: string;
  /**
   * PacketMirroring mirroredResourceInfos. MirroredResourceInfo specifies a
   * set of mirrored VM instances, subnetworks and/or tags for which traffic
   * from/to all VM instances will be mirrored.
   */
  mirroredResources?: PacketMirroringMirroredResourceInfo;
  /**
   * Name of the resource; provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * Specifies the mirrored VPC network. Only packets in this network will be
   * mirrored. All mirrored VMs should have a NIC in the given network. All
   * mirrored subnetworks should belong to the given network.
   */
  network?: PacketMirroringNetworkInfo;
  /**
   * The priority of applying this configuration. Priority is used to break
   * ties in cases where there is more than one matching rule. In the case of
   * two rules that apply for a given Instance, the one with the lowest-numbered
   * priority value wins. Default value is 1000. Valid range is 0 through 65535.
   */
  priority?: number;
  /**
   * [Output Only] URI of the region where the packetMirroring resides.
   */
  region?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
}

function serializePacketMirroring(data: any): PacketMirroring {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializePacketMirroring(data: any): PacketMirroring {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

/**
 * Contains a list of packetMirrorings.
 */
export interface PacketMirroringAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of PacketMirroring resources.
   */
  items?: {
    [key: string]: PacketMirroringsScopedList
  };
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializePacketMirroringAggregatedList(data: any): PacketMirroringAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializePacketMirroringsScopedList(v)]))) : undefined,
  };
}

function deserializePacketMirroringAggregatedList(data: any): PacketMirroringAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializePacketMirroringsScopedList(v)]))) : undefined,
  };
}

export interface PacketMirroringFilter {
  /**
   * IP CIDR ranges that apply as filter on the source (ingress) or destination
   * (egress) IP in the IP header. Only IPv4 is supported. If no ranges are
   * specified, all traffic that matches the specified IPProtocols is mirrored.
   * If neither cidrRanges nor IPProtocols is specified, all traffic is
   * mirrored.
   */
  cidrRanges?: string[];
  /**
   * Direction of traffic to mirror, either INGRESS, EGRESS, or BOTH. The
   * default is BOTH.
   */
  direction?:  | "BOTH" | "EGRESS" | "INGRESS";
  /**
   * Protocols that apply as filter on mirrored traffic. If no protocols are
   * specified, all traffic that matches the specified CIDR ranges is mirrored.
   * If neither cidrRanges nor IPProtocols is specified, all traffic is
   * mirrored.
   */
  IPProtocols?: string[];
}

export interface PacketMirroringForwardingRuleInfo {
  /**
   * [Output Only] Unique identifier for the forwarding rule; defined by the
   * server.
   */
  canonicalUrl?: string;
  /**
   * Resource URL to the forwarding rule representing the ILB configured as
   * destination of the mirrored traffic.
   */
  url?: string;
}

/**
 * Contains a list of PacketMirroring resources.
 */
export interface PacketMirroringList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of PacketMirroring resources.
   */
  items?: PacketMirroring[];
  /**
   * [Output Only] Type of resource. Always compute#packetMirroring for
   * packetMirrorings.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializePacketMirroringList(data: any): PacketMirroringList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializePacketMirroring(item))) : undefined,
  };
}

function deserializePacketMirroringList(data: any): PacketMirroringList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializePacketMirroring(item))) : undefined,
  };
}

export interface PacketMirroringMirroredResourceInfo {
  /**
   * A set of virtual machine instances that are being mirrored. They must live
   * in zones contained in the same region as this packetMirroring. Note that
   * this config will apply only to those network interfaces of the Instances
   * that belong to the network specified in this packetMirroring. You may
   * specify a maximum of 50 Instances.
   */
  instances?: PacketMirroringMirroredResourceInfoInstanceInfo[];
  /**
   * A set of subnetworks for which traffic from/to all VM instances will be
   * mirrored. They must live in the same region as this packetMirroring. You
   * may specify a maximum of 5 subnetworks.
   */
  subnetworks?: PacketMirroringMirroredResourceInfoSubnetInfo[];
  /**
   * A set of mirrored tags. Traffic from/to all VM instances that have one or
   * more of these tags will be mirrored.
   */
  tags?: string[];
}

export interface PacketMirroringMirroredResourceInfoInstanceInfo {
  /**
   * [Output Only] Unique identifier for the instance; defined by the server.
   */
  canonicalUrl?: string;
  /**
   * Resource URL to the virtual machine instance which is being mirrored.
   */
  url?: string;
}

export interface PacketMirroringMirroredResourceInfoSubnetInfo {
  /**
   * [Output Only] Unique identifier for the subnetwork; defined by the server.
   */
  canonicalUrl?: string;
  /**
   * Resource URL to the subnetwork for which traffic from/to all VM instances
   * will be mirrored.
   */
  url?: string;
}

export interface PacketMirroringNetworkInfo {
  /**
   * [Output Only] Unique identifier for the network; defined by the server.
   */
  canonicalUrl?: string;
  /**
   * URL of the network resource.
   */
  url?: string;
}

/**
 * Additional options for Compute#packetMirroringsAggregatedList.
 */
export interface PacketMirroringsAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#packetMirroringsDelete.
 */
export interface PacketMirroringsDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#packetMirroringsInsert.
 */
export interface PacketMirroringsInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#packetMirroringsList.
 */
export interface PacketMirroringsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#packetMirroringsPatch.
 */
export interface PacketMirroringsPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface PacketMirroringsScopedList {
  /**
   * A list of packetMirrorings contained in this scope.
   */
  packetMirrorings?: PacketMirroring[];
  /**
   * Informational warning which replaces the list of packetMirrorings when the
   * list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializePacketMirroringsScopedList(data: any): PacketMirroringsScopedList {
  return {
    ...data,
    packetMirrorings: data["packetMirrorings"] !== undefined ? data["packetMirrorings"].map((item: any) => (serializePacketMirroring(item))) : undefined,
  };
}

function deserializePacketMirroringsScopedList(data: any): PacketMirroringsScopedList {
  return {
    ...data,
    packetMirrorings: data["packetMirrorings"] !== undefined ? data["packetMirrorings"].map((item: any) => (deserializePacketMirroring(item))) : undefined,
  };
}

/**
 * A matcher for the path portion of the URL. The BackendService from the
 * longest-matched rule will serve the URL. If no rule was matched, the default
 * service is used.
 */
export interface PathMatcher {
  /**
   * defaultRouteAction takes effect when none of the pathRules or routeRules
   * match. The load balancer performs advanced routing actions, such as URL
   * rewrites and header transformations, before forwarding the request to the
   * selected backend. If defaultRouteAction specifies any
   * weightedBackendServices, defaultService must not be set. Conversely if
   * defaultService is set, defaultRouteAction cannot contain any
   * weightedBackendServices. Only one of defaultRouteAction or
   * defaultUrlRedirect must be set. URL maps for Classic external HTTP(S) load
   * balancers only support the urlRewrite action within a path matcher's
   * defaultRouteAction.
   */
  defaultRouteAction?: HttpRouteAction;
  /**
   * The full or partial URL to the BackendService resource. This URL is used
   * if none of the pathRules or routeRules defined by this PathMatcher are
   * matched. For example, the following are all valid URLs to a BackendService
   * resource: - https://www.googleapis.com/compute/v1/projects/project
   * /global/backendServices/backendService -
   * compute/v1/projects/project/global/backendServices/backendService -
   * global/backendServices/backendService If defaultRouteAction is also
   * specified, advanced routing actions, such as URL rewrites, take effect
   * before sending the request to the backend. However, if defaultService is
   * specified, defaultRouteAction cannot contain any weightedBackendServices.
   * Conversely, if defaultRouteAction specifies any weightedBackendServices,
   * defaultService must not be specified. Only one of defaultService,
   * defaultUrlRedirect , or defaultRouteAction.weightedBackendService must be
   * set. Authorization requires one or more of the following Google IAM
   * permissions on the specified resource default_service: -
   * compute.backendBuckets.use - compute.backendServices.use
   */
  defaultService?: string;
  /**
   * When none of the specified pathRules or routeRules match, the request is
   * redirected to a URL specified by defaultUrlRedirect. If defaultUrlRedirect
   * is specified, defaultService or defaultRouteAction must not be set. Not
   * supported when the URL map is bound to a target gRPC proxy.
   */
  defaultUrlRedirect?: HttpRedirectAction;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * Specifies changes to request and response headers that need to take effect
   * for the selected backend service. HeaderAction specified here are applied
   * after the matching HttpRouteRule HeaderAction and before the HeaderAction
   * in the UrlMap HeaderAction is not supported for load balancers that have
   * their loadBalancingScheme set to EXTERNAL. Not supported when the URL map
   * is bound to a target gRPC proxy that has validateForProxyless field set to
   * true.
   */
  headerAction?: HttpHeaderAction;
  /**
   * The name to which this PathMatcher is referred by the HostRule.
   */
  name?: string;
  /**
   * The list of path rules. Use this list instead of routeRules when routing
   * based on simple path matching is all that's required. The order by which
   * path rules are specified does not matter. Matches are always done on the
   * longest-path-first basis. For example: a pathRule with a path /a/b/c/* will
   * match before /a/b/* irrespective of the order in which those paths appear
   * in this list. Within a given pathMatcher, only one of pathRules or
   * routeRules must be set.
   */
  pathRules?: PathRule[];
  /**
   * The list of HTTP route rules. Use this list instead of pathRules when
   * advanced route matching and routing actions are desired. routeRules are
   * evaluated in order of priority, from the lowest to highest number. Within a
   * given pathMatcher, you can set only one of pathRules or routeRules.
   */
  routeRules?: HttpRouteRule[];
}

function serializePathMatcher(data: any): PathMatcher {
  return {
    ...data,
    defaultRouteAction: data["defaultRouteAction"] !== undefined ? serializeHttpRouteAction(data["defaultRouteAction"]) : undefined,
    pathRules: data["pathRules"] !== undefined ? data["pathRules"].map((item: any) => (serializePathRule(item))) : undefined,
    routeRules: data["routeRules"] !== undefined ? data["routeRules"].map((item: any) => (serializeHttpRouteRule(item))) : undefined,
  };
}

function deserializePathMatcher(data: any): PathMatcher {
  return {
    ...data,
    defaultRouteAction: data["defaultRouteAction"] !== undefined ? deserializeHttpRouteAction(data["defaultRouteAction"]) : undefined,
    pathRules: data["pathRules"] !== undefined ? data["pathRules"].map((item: any) => (deserializePathRule(item))) : undefined,
    routeRules: data["routeRules"] !== undefined ? data["routeRules"].map((item: any) => (deserializeHttpRouteRule(item))) : undefined,
  };
}

/**
 * A path-matching rule for a URL. If matched, will use the specified
 * BackendService to handle the traffic arriving at this URL.
 */
export interface PathRule {
  /**
   * The list of path patterns to match. Each must start with / and the only
   * place a * is allowed is at the end following a /. The string fed to the
   * path matcher does not include any text after the first ? or #, and those
   * chars are not allowed here.
   */
  paths?: string[];
  /**
   * In response to a matching path, the load balancer performs advanced
   * routing actions, such as URL rewrites and header transformations, before
   * forwarding the request to the selected backend. If routeAction specifies
   * any weightedBackendServices, service must not be set. Conversely if service
   * is set, routeAction cannot contain any weightedBackendServices. Only one of
   * routeAction or urlRedirect must be set. URL maps for Classic external
   * HTTP(S) load balancers only support the urlRewrite action within a path
   * rule's routeAction.
   */
  routeAction?: HttpRouteAction;
  /**
   * The full or partial URL of the backend service resource to which traffic
   * is directed if this rule is matched. If routeAction is also specified,
   * advanced routing actions, such as URL rewrites, take effect before sending
   * the request to the backend. However, if service is specified, routeAction
   * cannot contain any weightedBackendServices. Conversely, if routeAction
   * specifies any weightedBackendServices, service must not be specified. Only
   * one of urlRedirect, service or routeAction.weightedBackendService must be
   * set.
   */
  service?: string;
  /**
   * When a path pattern is matched, the request is redirected to a URL
   * specified by urlRedirect. If urlRedirect is specified, service or
   * routeAction must not be set. Not supported when the URL map is bound to a
   * target gRPC proxy.
   */
  urlRedirect?: HttpRedirectAction;
}

function serializePathRule(data: any): PathRule {
  return {
    ...data,
    routeAction: data["routeAction"] !== undefined ? serializeHttpRouteAction(data["routeAction"]) : undefined,
  };
}

function deserializePathRule(data: any): PathRule {
  return {
    ...data,
    routeAction: data["routeAction"] !== undefined ? deserializeHttpRouteAction(data["routeAction"]) : undefined,
  };
}

export interface PerInstanceConfig {
  /**
   * Fingerprint of this per-instance config. This field can be used in
   * optimistic locking. It is ignored when inserting a per-instance config. An
   * up-to-date fingerprint must be provided in order to update an existing
   * per-instance configuration or the field needs to be unset.
   */
  fingerprint?: Uint8Array;
  /**
   * The name of a per-instance configuration and its corresponding instance.
   * Serves as a merge key during UpdatePerInstanceConfigs operations, that is,
   * if a per-instance configuration with the same name exists then it will be
   * updated, otherwise a new one will be created for the VM instance with the
   * same name. An attempt to create a per-instance configconfiguration for a VM
   * instance that either doesn't exist or is not part of the group will result
   * in an error.
   */
  name?: string;
  /**
   * The intended preserved state for the given instance. Does not contain
   * preserved state generated from a stateful policy.
   */
  preservedState?: PreservedState;
  /**
   * The status of applying this per-instance configuration on the
   * corresponding managed instance.
   */
  status?:  | "APPLYING" | "DELETING" | "EFFECTIVE" | "NONE" | "UNAPPLIED" | "UNAPPLIED_DELETION";
}

function serializePerInstanceConfig(data: any): PerInstanceConfig {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
  };
}

function deserializePerInstanceConfig(data: any): PerInstanceConfig {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
  };
}

/**
 * An Identity and Access Management (IAM) policy, which specifies access
 * controls for Google Cloud resources. A `Policy` is a collection of
 * `bindings`. A `binding` binds one or more `members`, or principals, to a
 * single `role`. Principals can be user accounts, service accounts, Google
 * groups, and domains (such as G Suite). A `role` is a named list of
 * permissions; each `role` can be an IAM predefined role or a user-created
 * custom role. For some types of Google Cloud resources, a `binding` can also
 * specify a `condition`, which is a logical expression that allows access to a
 * resource only if the expression evaluates to `true`. A condition can add
 * constraints based on attributes of the request, the resource, or both. To
 * learn which resources support conditions in their IAM policies, see the [IAM
 * documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 * **JSON example:** { "bindings": [ { "role":
 * "roles/resourcemanager.organizationAdmin", "members": [
 * "user:mike@example.com", "group:admins@example.com", "domain:google.com",
 * "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role":
 * "roles/resourcemanager.organizationViewer", "members": [
 * "user:eve@example.com" ], "condition": { "title": "expirable access",
 * "description": "Does not grant access after Sep 2020", "expression":
 * "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag":
 * "BwWWja0YfJA=", "version": 3 } **YAML example:** bindings: - members: -
 * user:mike@example.com - group:admins@example.com - domain:google.com -
 * serviceAccount:my-project-id@appspot.gserviceaccount.com role:
 * roles/resourcemanager.organizationAdmin - members: - user:eve@example.com
 * role: roles/resourcemanager.organizationViewer condition: title: expirable
 * access description: Does not grant access after Sep 2020 expression:
 * request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA=
 * version: 3 For a description of IAM and its features, see the [IAM
 * documentation](https://cloud.google.com/iam/docs/).
 */
export interface Policy {
  /**
   * Specifies cloud audit logging configuration for this policy.
   */
  auditConfigs?: AuditConfig[];
  /**
   * Associates a list of `members`, or principals, with a `role`. Optionally,
   * may specify a `condition` that determines how and when the `bindings` are
   * applied. Each of the `bindings` must contain at least one principal. The
   * `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250 of
   * these principals can be Google groups. Each occurrence of a principal
   * counts towards these limits. For example, if the `bindings` grant 50
   * different roles to `user:alice@example.com`, and not to any other
   * principal, then you can add another 1,450 principals to the `bindings` in
   * the `Policy`.
   */
  bindings?: Binding[];
  /**
   * `etag` is used for optimistic concurrency control as a way to help prevent
   * simultaneous updates of a policy from overwriting each other. It is
   * strongly suggested that systems make use of the `etag` in the
   * read-modify-write cycle to perform policy updates in order to avoid race
   * conditions: An `etag` is returned in the response to `getIamPolicy`, and
   * systems are expected to put that etag in the request to `setIamPolicy` to
   * ensure that their change will be applied to the same version of the policy.
   * **Important:** If you use IAM Conditions, you must include the `etag` field
   * whenever you call `setIamPolicy`. If you omit this field, then IAM allows
   * you to overwrite a version `3` policy with a version `1` policy, and all of
   * the conditions in the version `3` policy are lost.
   */
  etag?: Uint8Array;
  /**
   * This is deprecated and has no effect. Do not use.
   */
  rules?: Rule[];
  /**
   * Specifies the format of the policy. Valid values are `0`, `1`, and `3`.
   * Requests that specify an invalid value are rejected. Any operation that
   * affects conditional role bindings must specify version `3`. This
   * requirement applies to the following operations: * Getting a policy that
   * includes a conditional role binding * Adding a conditional role binding to
   * a policy * Changing a conditional role binding in a policy * Removing any
   * role binding, with or without a condition, from a policy that includes
   * conditions **Important:** If you use IAM Conditions, you must include the
   * `etag` field whenever you call `setIamPolicy`. If you omit this field, then
   * IAM allows you to overwrite a version `3` policy with a version `1` policy,
   * and all of the conditions in the version `3` policy are lost. If a policy
   * does not include any conditions, operations on that policy may specify any
   * valid version or leave the field unset. To learn which resources support
   * conditions in their IAM policies, see the [IAM
   * documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
   */
  version?: number;
}

function serializePolicy(data: any): Policy {
  return {
    ...data,
    etag: data["etag"] !== undefined ? encodeBase64(data["etag"]) : undefined,
  };
}

function deserializePolicy(data: any): Policy {
  return {
    ...data,
    etag: data["etag"] !== undefined ? decodeBase64(data["etag"] as string) : undefined,
  };
}

export interface PreconfiguredWafSet {
  /**
   * List of entities that are currently supported for WAF rules.
   */
  expressionSets?: WafExpressionSet[];
}

/**
 * Preserved state for a given instance.
 */
export interface PreservedState {
  /**
   * Preserved disks defined for this instance. This map is keyed with the
   * device names of the disks.
   */
  disks?: {
    [key: string]: PreservedStatePreservedDisk
  };
  /**
   * Preserved metadata defined for this instance.
   */
  metadata?: {
    [key: string]: string
  };
}

export interface PreservedStatePreservedDisk {
  /**
   * These stateful disks will never be deleted during autohealing, update,
   * instance recreate operations. This flag is used to configure if the disk
   * should be deleted after it is no longer used by the group, e.g. when the
   * given instance or the whole MIG is deleted. Note: disks attached in
   * READ_ONLY mode cannot be auto-deleted.
   */
  autoDelete?:  | "NEVER" | "ON_PERMANENT_INSTANCE_DELETION";
  /**
   * The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If
   * not specified, the default is to attach the disk in READ_WRITE mode.
   */
  mode?:  | "READ_ONLY" | "READ_WRITE";
  /**
   * The URL of the disk resource that is stateful and should be attached to
   * the VM instance.
   */
  source?: string;
}

/**
 * Represents a Project resource. A project is used to organize resources in a
 * Google Cloud Platform environment. For more information, read about the
 * Resource Hierarchy.
 */
export interface Project {
  /**
   * Metadata key/value pairs available to all instances contained in this
   * project. See Custom metadata for more information.
   */
  commonInstanceMetadata?: Metadata;
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * This signifies the default network tier used for configuring resources of
   * the project and can only take the following values: PREMIUM, STANDARD.
   * Initially the default network tier is PREMIUM.
   */
  defaultNetworkTier?:  | "FIXED_STANDARD" | "PREMIUM" | "STANDARD" | "STANDARD_OVERRIDES_FIXED_STANDARD";
  /**
   * [Output Only] Default service account used by VMs running in this project.
   */
  defaultServiceAccount?: string;
  /**
   * An optional textual description of the resource.
   */
  description?: string;
  /**
   * Restricted features enabled for use on this project.
   */
  enabledFeatures?: string[];
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server. This is *not* the project ID, and is just a unique
   * ID used by Compute Engine to identify resources.
   */
  id?: bigint;
  /**
   * [Output Only] Type of the resource. Always compute#project for projects.
   */
  kind?: string;
  /**
   * The project ID. For example: my-example-project. Use the project ID to
   * make requests to Compute Engine.
   */
  name?: string;
  /**
   * [Output Only] Quotas assigned to this project.
   */
  quotas?: Quota[];
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * The naming prefix for daily usage reports and the Google Cloud Storage
   * bucket where they are stored.
   */
  usageExportLocation?: UsageExportLocation;
  /**
   * [Output Only] Default internal DNS setting used by VMs running in this
   * project.
   */
  vmDnsSetting?:  | "GLOBAL_DEFAULT" | "UNSPECIFIED_VM_DNS_SETTING" | "ZONAL_DEFAULT" | "ZONAL_ONLY";
  /**
   * [Output Only] The role this project has in a shared VPC configuration.
   * Currently, only projects with the host role, which is specified by the
   * value HOST, are differentiated.
   */
  xpnProjectStatus?:  | "HOST" | "UNSPECIFIED_XPN_PROJECT_STATUS";
}

function serializeProject(data: any): Project {
  return {
    ...data,
    commonInstanceMetadata: data["commonInstanceMetadata"] !== undefined ? serializeMetadata(data["commonInstanceMetadata"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeProject(data: any): Project {
  return {
    ...data,
    commonInstanceMetadata: data["commonInstanceMetadata"] !== undefined ? deserializeMetadata(data["commonInstanceMetadata"]) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

/**
 * Additional options for Compute#projectsDisableXpnHost.
 */
export interface ProjectsDisableXpnHostOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#projectsDisableXpnResource.
 */
export interface ProjectsDisableXpnResourceOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface ProjectsDisableXpnResourceRequest {
  /**
   * Service resource (a.k.a service project) ID.
   */
  xpnResource?: XpnResourceId;
}

/**
 * Additional options for Compute#projectsEnableXpnHost.
 */
export interface ProjectsEnableXpnHostOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#projectsEnableXpnResource.
 */
export interface ProjectsEnableXpnResourceOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface ProjectsEnableXpnResourceRequest {
  /**
   * Service resource (a.k.a service project) ID.
   */
  xpnResource?: XpnResourceId;
}

export interface ProjectsGetXpnResources {
  /**
   * [Output Only] Type of resource. Always compute#projectsGetXpnResources for
   * lists of service resources (a.k.a service projects)
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * Service resources (a.k.a service projects) attached to this project as
   * their shared VPC host.
   */
  resources?: XpnResourceId[];
}

/**
 * Additional options for Compute#projectsGetXpnResources.
 */
export interface ProjectsGetXpnResourcesOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#projectsListXpnHosts.
 */
export interface ProjectsListXpnHostsOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface ProjectsListXpnHostsRequest {
  /**
   * Optional organization ID managed by Cloud Resource Manager, for which to
   * list shared VPC host projects. If not specified, the organization will be
   * inferred from the project.
   */
  organization?: string;
}

/**
 * Additional options for Compute#projectsMoveDisk.
 */
export interface ProjectsMoveDiskOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#projectsMoveInstance.
 */
export interface ProjectsMoveInstanceOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#projectsSetCommonInstanceMetadata.
 */
export interface ProjectsSetCommonInstanceMetadataOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#projectsSetDefaultNetworkTier.
 */
export interface ProjectsSetDefaultNetworkTierOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface ProjectsSetDefaultNetworkTierRequest {
  /**
   * Default network tier to be set.
   */
  networkTier?:  | "FIXED_STANDARD" | "PREMIUM" | "STANDARD" | "STANDARD_OVERRIDES_FIXED_STANDARD";
}

/**
 * Additional options for Compute#projectsSetUsageExportBucket.
 */
export interface ProjectsSetUsageExportBucketOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * A public advertised prefix represents an aggregated IP prefix or netblock
 * which customers bring to cloud. The IP prefix is a single unit of route
 * advertisement and is announced globally to the internet.
 */
export interface PublicAdvertisedPrefix {
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * The IPv4 address to be used for reverse DNS verification.
   */
  dnsVerificationIp?: string;
  /**
   * Fingerprint of this resource. A hash of the contents stored in this
   * object. This field is used in optimistic locking. This field will be
   * ignored when inserting a new PublicAdvertisedPrefix. An up-to-date
   * fingerprint must be provided in order to update the PublicAdvertisedPrefix,
   * otherwise the request will fail with error 412 conditionNotMet. To see the
   * latest fingerprint, make a get() request to retrieve a
   * PublicAdvertisedPrefix.
   */
  fingerprint?: Uint8Array;
  /**
   * [Output Only] The unique identifier for the resource type. The server
   * generates this identifier.
   */
  id?: bigint;
  /**
   * The IPv4 address range, in CIDR format, represented by this public
   * advertised prefix.
   */
  ipCidrRange?: string;
  /**
   * [Output Only] Type of the resource. Always compute#publicAdvertisedPrefix
   * for public advertised prefixes.
   */
  kind?: string;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * [Output Only] The list of public delegated prefixes that exist for this
   * public advertised prefix.
   */
  publicDelegatedPrefixs?: PublicAdvertisedPrefixPublicDelegatedPrefix[];
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * [Output Only] The shared secret to be used for reverse DNS verification.
   */
  sharedSecret?: string;
  /**
   * The status of the public advertised prefix. Possible values include: -
   * `INITIAL`: RPKI validation is complete. - `PTR_CONFIGURED`: User has
   * configured the PTR. - `VALIDATED`: Reverse DNS lookup is successful. -
   * `REVERSE_DNS_LOOKUP_FAILED`: Reverse DNS lookup failed. -
   * `PREFIX_CONFIGURATION_IN_PROGRESS`: The prefix is being configured. -
   * `PREFIX_CONFIGURATION_COMPLETE`: The prefix is fully configured. -
   * `PREFIX_REMOVAL_IN_PROGRESS`: The prefix is being removed.
   */
  status?:  | "INITIAL" | "PREFIX_CONFIGURATION_COMPLETE" | "PREFIX_CONFIGURATION_IN_PROGRESS" | "PREFIX_REMOVAL_IN_PROGRESS" | "PTR_CONFIGURED" | "REVERSE_DNS_LOOKUP_FAILED" | "VALIDATED";
}

function serializePublicAdvertisedPrefix(data: any): PublicAdvertisedPrefix {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializePublicAdvertisedPrefix(data: any): PublicAdvertisedPrefix {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

/**
 * Additional options for Compute#publicAdvertisedPrefixesDelete.
 */
export interface PublicAdvertisedPrefixesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#publicAdvertisedPrefixesInsert.
 */
export interface PublicAdvertisedPrefixesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#publicAdvertisedPrefixesList.
 */
export interface PublicAdvertisedPrefixesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#publicAdvertisedPrefixesPatch.
 */
export interface PublicAdvertisedPrefixesPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface PublicAdvertisedPrefixList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of PublicAdvertisedPrefix resources.
   */
  items?: PublicAdvertisedPrefix[];
  /**
   * [Output Only] Type of the resource. Always compute#publicAdvertisedPrefix
   * for public advertised prefixes.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializePublicAdvertisedPrefixList(data: any): PublicAdvertisedPrefixList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializePublicAdvertisedPrefix(item))) : undefined,
  };
}

function deserializePublicAdvertisedPrefixList(data: any): PublicAdvertisedPrefixList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializePublicAdvertisedPrefix(item))) : undefined,
  };
}

/**
 * Represents a CIDR range which can be used to assign addresses.
 */
export interface PublicAdvertisedPrefixPublicDelegatedPrefix {
  /**
   * The IP address range of the public delegated prefix
   */
  ipRange?: string;
  /**
   * The name of the public delegated prefix
   */
  name?: string;
  /**
   * The project number of the public delegated prefix
   */
  project?: string;
  /**
   * The region of the public delegated prefix if it is regional. If absent,
   * the prefix is global.
   */
  region?: string;
  /**
   * The status of the public delegated prefix. Possible values are:
   * INITIALIZING: The public delegated prefix is being initialized and
   * addresses cannot be created yet. ANNOUNCED: The public delegated prefix is
   * active.
   */
  status?: string;
}

/**
 * A PublicDelegatedPrefix resource represents an IP block within a
 * PublicAdvertisedPrefix that is configured within a single cloud scope (global
 * or region). IPs in the block can be allocated to resources within that scope.
 * Public delegated prefixes may be further broken up into smaller IP blocks in
 * the same scope as the parent block.
 */
export interface PublicDelegatedPrefix {
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * Fingerprint of this resource. A hash of the contents stored in this
   * object. This field is used in optimistic locking. This field will be
   * ignored when inserting a new PublicDelegatedPrefix. An up-to-date
   * fingerprint must be provided in order to update the PublicDelegatedPrefix,
   * otherwise the request will fail with error 412 conditionNotMet. To see the
   * latest fingerprint, make a get() request to retrieve a
   * PublicDelegatedPrefix.
   */
  fingerprint?: Uint8Array;
  /**
   * [Output Only] The unique identifier for the resource type. The server
   * generates this identifier.
   */
  id?: bigint;
  /**
   * The IPv4 address range, in CIDR format, represented by this public
   * delegated prefix.
   */
  ipCidrRange?: string;
  /**
   * If true, the prefix will be live migrated.
   */
  isLiveMigration?: boolean;
  /**
   * [Output Only] Type of the resource. Always compute#publicDelegatedPrefix
   * for public delegated prefixes.
   */
  kind?: string;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * The URL of parent prefix. Either PublicAdvertisedPrefix or
   * PublicDelegatedPrefix.
   */
  parentPrefix?: string;
  /**
   * The list of sub public delegated prefixes that exist for this public
   * delegated prefix.
   */
  publicDelegatedSubPrefixs?: PublicDelegatedPrefixPublicDelegatedSubPrefix[];
  /**
   * [Output Only] URL of the region where the public delegated prefix resides.
   * This field applies only to the region resource. You must specify this field
   * as part of the HTTP request URL. It is not settable as a field in the
   * request body.
   */
  region?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * [Output Only] The status of the public delegated prefix, which can be one
   * of following values: - `INITIALIZING` The public delegated prefix is being
   * initialized and addresses cannot be created yet. - `READY_TO_ANNOUNCE` The
   * public delegated prefix is a live migration prefix and is active. -
   * `ANNOUNCED` The public delegated prefix is active. - `DELETING` The public
   * delegated prefix is being deprovsioned.
   */
  status?:  | "ANNOUNCED" | "DELETING" | "INITIALIZING" | "READY_TO_ANNOUNCE";
}

function serializePublicDelegatedPrefix(data: any): PublicDelegatedPrefix {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializePublicDelegatedPrefix(data: any): PublicDelegatedPrefix {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface PublicDelegatedPrefixAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of PublicDelegatedPrefixesScopedList resources.
   */
  items?: {
    [key: string]: PublicDelegatedPrefixesScopedList
  };
  /**
   * [Output Only] Type of the resource. Always
   * compute#publicDelegatedPrefixAggregatedList for aggregated lists of public
   * delegated prefixes.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializePublicDelegatedPrefixAggregatedList(data: any): PublicDelegatedPrefixAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializePublicDelegatedPrefixesScopedList(v)]))) : undefined,
  };
}

function deserializePublicDelegatedPrefixAggregatedList(data: any): PublicDelegatedPrefixAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializePublicDelegatedPrefixesScopedList(v)]))) : undefined,
  };
}

/**
 * Additional options for Compute#publicDelegatedPrefixesAggregatedList.
 */
export interface PublicDelegatedPrefixesAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#publicDelegatedPrefixesDelete.
 */
export interface PublicDelegatedPrefixesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#publicDelegatedPrefixesInsert.
 */
export interface PublicDelegatedPrefixesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#publicDelegatedPrefixesList.
 */
export interface PublicDelegatedPrefixesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#publicDelegatedPrefixesPatch.
 */
export interface PublicDelegatedPrefixesPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface PublicDelegatedPrefixesScopedList {
  /**
   * [Output Only] A list of PublicDelegatedPrefixes contained in this scope.
   */
  publicDelegatedPrefixes?: PublicDelegatedPrefix[];
  /**
   * [Output Only] Informational warning which replaces the list of public
   * delegated prefixes when the list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializePublicDelegatedPrefixesScopedList(data: any): PublicDelegatedPrefixesScopedList {
  return {
    ...data,
    publicDelegatedPrefixes: data["publicDelegatedPrefixes"] !== undefined ? data["publicDelegatedPrefixes"].map((item: any) => (serializePublicDelegatedPrefix(item))) : undefined,
  };
}

function deserializePublicDelegatedPrefixesScopedList(data: any): PublicDelegatedPrefixesScopedList {
  return {
    ...data,
    publicDelegatedPrefixes: data["publicDelegatedPrefixes"] !== undefined ? data["publicDelegatedPrefixes"].map((item: any) => (deserializePublicDelegatedPrefix(item))) : undefined,
  };
}

export interface PublicDelegatedPrefixList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of PublicDelegatedPrefix resources.
   */
  items?: PublicDelegatedPrefix[];
  /**
   * [Output Only] Type of the resource. Always
   * compute#publicDelegatedPrefixList for public delegated prefixes.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializePublicDelegatedPrefixList(data: any): PublicDelegatedPrefixList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializePublicDelegatedPrefix(item))) : undefined,
  };
}

function deserializePublicDelegatedPrefixList(data: any): PublicDelegatedPrefixList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializePublicDelegatedPrefix(item))) : undefined,
  };
}

/**
 * Represents a sub PublicDelegatedPrefix.
 */
export interface PublicDelegatedPrefixPublicDelegatedSubPrefix {
  /**
   * Name of the project scoping this PublicDelegatedSubPrefix.
   */
  delegateeProject?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * The IPv4 address range, in CIDR format, represented by this sub public
   * delegated prefix.
   */
  ipCidrRange?: string;
  /**
   * Whether the sub prefix is delegated to create Address resources in the
   * delegatee project.
   */
  isAddress?: boolean;
  /**
   * The name of the sub public delegated prefix.
   */
  name?: string;
  /**
   * [Output Only] The region of the sub public delegated prefix if it is
   * regional. If absent, the sub prefix is global.
   */
  region?: string;
  /**
   * [Output Only] The status of the sub public delegated prefix.
   */
  status?:  | "ACTIVE" | "INACTIVE";
}

/**
 * A quotas entry.
 */
export interface Quota {
  /**
   * [Output Only] Quota limit for this metric.
   */
  limit?: number;
  /**
   * [Output Only] Name of the quota metric.
   */
  metric?:  | "A2_CPUS" | "AFFINITY_GROUPS" | "AUTOSCALERS" | "BACKEND_BUCKETS" | "BACKEND_SERVICES" | "C2D_CPUS" | "C2_CPUS" | "C3_CPUS" | "COMMITMENTS" | "COMMITTED_A2_CPUS" | "COMMITTED_C2D_CPUS" | "COMMITTED_C2_CPUS" | "COMMITTED_C3_CPUS" | "COMMITTED_CPUS" | "COMMITTED_E2_CPUS" | "COMMITTED_LICENSES" | "COMMITTED_LOCAL_SSD_TOTAL_GB" | "COMMITTED_M3_CPUS" | "COMMITTED_MEMORY_OPTIMIZED_CPUS" | "COMMITTED_N2A_CPUS" | "COMMITTED_N2D_CPUS" | "COMMITTED_N2_CPUS" | "COMMITTED_NVIDIA_A100_80GB_GPUS" | "COMMITTED_NVIDIA_A100_GPUS" | "COMMITTED_NVIDIA_K80_GPUS" | "COMMITTED_NVIDIA_P100_GPUS" | "COMMITTED_NVIDIA_P4_GPUS" | "COMMITTED_NVIDIA_T4_GPUS" | "COMMITTED_NVIDIA_V100_GPUS" | "COMMITTED_T2A_CPUS" | "COMMITTED_T2D_CPUS" | "CPUS" | "CPUS_ALL_REGIONS" | "DISKS_TOTAL_GB" | "E2_CPUS" | "EXTERNAL_MANAGED_FORWARDING_RULES" | "EXTERNAL_NETWORK_LB_FORWARDING_RULES" | "EXTERNAL_PROTOCOL_FORWARDING_RULES" | "EXTERNAL_VPN_GATEWAYS" | "FIREWALLS" | "FORWARDING_RULES" | "GLOBAL_EXTERNAL_MANAGED_BACKEND_SERVICES" | "GLOBAL_EXTERNAL_MANAGED_FORWARDING_RULES" | "GLOBAL_EXTERNAL_PROXY_LB_BACKEND_SERVICES" | "GLOBAL_INTERNAL_ADDRESSES" | "GLOBAL_INTERNAL_MANAGED_BACKEND_SERVICES" | "GLOBAL_INTERNAL_TRAFFIC_DIRECTOR_BACKEND_SERVICES" | "GPUS_ALL_REGIONS" | "HEALTH_CHECKS" | "IMAGES" | "INSTANCES" | "INSTANCE_GROUPS" | "INSTANCE_GROUP_MANAGERS" | "INSTANCE_TEMPLATES" | "INTERCONNECTS" | "INTERCONNECT_ATTACHMENTS_PER_REGION" | "INTERCONNECT_ATTACHMENTS_TOTAL_MBPS" | "INTERCONNECT_TOTAL_GBPS" | "INTERNAL_ADDRESSES" | "INTERNAL_TRAFFIC_DIRECTOR_FORWARDING_RULES" | "IN_PLACE_SNAPSHOTS" | "IN_USE_ADDRESSES" | "IN_USE_BACKUP_SCHEDULES" | "IN_USE_SNAPSHOT_SCHEDULES" | "LOCAL_SSD_TOTAL_GB" | "M1_CPUS" | "M2_CPUS" | "M3_CPUS" | "MACHINE_IMAGES" | "N2A_CPUS" | "N2D_CPUS" | "N2_CPUS" | "NETWORKS" | "NETWORK_ATTACHMENTS" | "NETWORK_ENDPOINT_GROUPS" | "NETWORK_FIREWALL_POLICIES" | "NODE_GROUPS" | "NODE_TEMPLATES" | "NVIDIA_A100_80GB_GPUS" | "NVIDIA_A100_GPUS" | "NVIDIA_K80_GPUS" | "NVIDIA_P100_GPUS" | "NVIDIA_P100_VWS_GPUS" | "NVIDIA_P4_GPUS" | "NVIDIA_P4_VWS_GPUS" | "NVIDIA_T4_GPUS" | "NVIDIA_T4_VWS_GPUS" | "NVIDIA_V100_GPUS" | "PACKET_MIRRORINGS" | "PD_EXTREME_TOTAL_PROVISIONED_IOPS" | "PREEMPTIBLE_CPUS" | "PREEMPTIBLE_LOCAL_SSD_GB" | "PREEMPTIBLE_NVIDIA_A100_80GB_GPUS" | "PREEMPTIBLE_NVIDIA_A100_GPUS" | "PREEMPTIBLE_NVIDIA_K80_GPUS" | "PREEMPTIBLE_NVIDIA_P100_GPUS" | "PREEMPTIBLE_NVIDIA_P100_VWS_GPUS" | "PREEMPTIBLE_NVIDIA_P4_GPUS" | "PREEMPTIBLE_NVIDIA_P4_VWS_GPUS" | "PREEMPTIBLE_NVIDIA_T4_GPUS" | "PREEMPTIBLE_NVIDIA_T4_VWS_GPUS" | "PREEMPTIBLE_NVIDIA_V100_GPUS" | "PSC_ILB_CONSUMER_FORWARDING_RULES_PER_PRODUCER_NETWORK" | "PSC_INTERNAL_LB_FORWARDING_RULES" | "PUBLIC_ADVERTISED_PREFIXES" | "PUBLIC_DELEGATED_PREFIXES" | "REGIONAL_AUTOSCALERS" | "REGIONAL_EXTERNAL_MANAGED_BACKEND_SERVICES" | "REGIONAL_EXTERNAL_NETWORK_LB_BACKEND_SERVICES" | "REGIONAL_INSTANCE_GROUP_MANAGERS" | "REGIONAL_INTERNAL_LB_BACKEND_SERVICES" | "REGIONAL_INTERNAL_MANAGED_BACKEND_SERVICES" | "RESERVATIONS" | "RESOURCE_POLICIES" | "ROUTERS" | "ROUTES" | "SECURITY_POLICIES" | "SECURITY_POLICIES_PER_REGION" | "SECURITY_POLICY_CEVAL_RULES" | "SECURITY_POLICY_RULES" | "SECURITY_POLICY_RULES_PER_REGION" | "SERVICE_ATTACHMENTS" | "SNAPSHOTS" | "SSD_TOTAL_GB" | "SSL_CERTIFICATES" | "STATIC_ADDRESSES" | "STATIC_BYOIP_ADDRESSES" | "STATIC_EXTERNAL_IPV6_ADDRESS_RANGES" | "SUBNETWORKS" | "T2A_CPUS" | "T2D_CPUS" | "TARGET_HTTPS_PROXIES" | "TARGET_HTTP_PROXIES" | "TARGET_INSTANCES" | "TARGET_POOLS" | "TARGET_SSL_PROXIES" | "TARGET_TCP_PROXIES" | "TARGET_VPN_GATEWAYS" | "URL_MAPS" | "VPN_GATEWAYS" | "VPN_TUNNELS" | "XPN_SERVICE_PROJECTS";
  /**
   * [Output Only] Owning resource. This is the resource on which this quota is
   * applied.
   */
  owner?: string;
  /**
   * [Output Only] Current usage of this metric.
   */
  usage?: number;
}

/**
 * Additional details for quota exceeded error for resource quota.
 */
export interface QuotaExceededInfo {
  /**
   * The map holding related quota dimensions.
   */
  dimensions?: {
    [key: string]: string
  };
  /**
   * Current effective quota limit. The limit's unit depends on the quota type
   * or metric.
   */
  limit?: number;
  /**
   * The name of the quota limit.
   */
  limitName?: string;
  /**
   * The Compute Engine quota metric name.
   */
  metricName?: string;
}

/**
 * Represents a reference to a resource.
 */
export interface Reference {
  /**
   * [Output Only] Type of the resource. Always compute#reference for
   * references.
   */
  kind?: string;
  /**
   * A description of the reference type with no implied semantics. Possible
   * values include: 1. MEMBER_OF
   */
  referenceType?: string;
  /**
   * URL of the resource which refers to the target.
   */
  referrer?: string;
  /**
   * URL of the resource to which this reference points.
   */
  target?: string;
}

/**
 * Represents a Region resource. A region is a geographical area where a
 * resource is located. For more information, read Regions and Zones.
 */
export interface Region {
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * [Output Only] The deprecation status associated with this region.
   */
  deprecated?: DeprecationStatus;
  /**
   * [Output Only] Textual description of the resource.
   */
  description?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of the resource. Always compute#region for regions.
   */
  kind?: string;
  /**
   * [Output Only] Name of the resource.
   */
  name?: string;
  /**
   * [Output Only] Quotas assigned to this region.
   */
  quotas?: Quota[];
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Status of the region, either UP or DOWN.
   */
  status?:  | "DOWN" | "UP";
  /**
   * [Output Only] Reserved for future use.
   */
  supportsPzs?: boolean;
  /**
   * [Output Only] A list of zones available in this region, in the form of
   * resource URLs.
   */
  zones?: string[];
}

function serializeRegion(data: any): Region {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeRegion(data: any): Region {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

/**
 * Contains a list of autoscalers.
 */
export interface RegionAutoscalerList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of Autoscaler resources.
   */
  items?: Autoscaler[];
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeRegionAutoscalerList(data: any): RegionAutoscalerList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeAutoscaler(item))) : undefined,
  };
}

function deserializeRegionAutoscalerList(data: any): RegionAutoscalerList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeAutoscaler(item))) : undefined,
  };
}

/**
 * Additional options for Compute#regionAutoscalersDelete.
 */
export interface RegionAutoscalersDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionAutoscalersInsert.
 */
export interface RegionAutoscalersInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionAutoscalersList.
 */
export interface RegionAutoscalersListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#regionAutoscalersPatch.
 */
export interface RegionAutoscalersPatchOptions {
  /**
   * Name of the autoscaler to patch.
   */
  autoscaler?: string;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionAutoscalersUpdate.
 */
export interface RegionAutoscalersUpdateOptions {
  /**
   * Name of the autoscaler to update.
   */
  autoscaler?: string;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionBackendServicesDelete.
 */
export interface RegionBackendServicesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionBackendServicesGetIamPolicy.
 */
export interface RegionBackendServicesGetIamPolicyOptions {
  /**
   * Requested IAM Policy version.
   */
  optionsRequestedPolicyVersion?: number;
}

/**
 * Additional options for Compute#regionBackendServicesInsert.
 */
export interface RegionBackendServicesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionBackendServicesList.
 */
export interface RegionBackendServicesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#regionBackendServicesPatch.
 */
export interface RegionBackendServicesPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionBackendServicesUpdate.
 */
export interface RegionBackendServicesUpdateOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionCommitmentsAggregatedList.
 */
export interface RegionCommitmentsAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#regionCommitmentsInsert.
 */
export interface RegionCommitmentsInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionCommitmentsList.
 */
export interface RegionCommitmentsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#regionCommitmentsUpdate.
 */
export interface RegionCommitmentsUpdateOptions {
  paths?: string;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
  /**
   * update_mask indicates fields to be updated as part of this request.
   */
  updateMask?: string /* FieldMask */;
}

function serializeRegionCommitmentsUpdateOptions(data: any): RegionCommitmentsUpdateOptions {
  return {
    ...data,
    updateMask: data["updateMask"] !== undefined ? data["updateMask"] : undefined,
  };
}

function deserializeRegionCommitmentsUpdateOptions(data: any): RegionCommitmentsUpdateOptions {
  return {
    ...data,
    updateMask: data["updateMask"] !== undefined ? data["updateMask"] : undefined,
  };
}

/**
 * Additional options for Compute#regionDisksAddResourcePolicies.
 */
export interface RegionDisksAddResourcePoliciesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface RegionDisksAddResourcePoliciesRequest {
  /**
   * Resource policies to be added to this disk.
   */
  resourcePolicies?: string[];
}

/**
 * Additional options for Compute#regionDisksCreateSnapshot.
 */
export interface RegionDisksCreateSnapshotOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionDisksDelete.
 */
export interface RegionDisksDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionDisksGetIamPolicy.
 */
export interface RegionDisksGetIamPolicyOptions {
  /**
   * Requested IAM Policy version.
   */
  optionsRequestedPolicyVersion?: number;
}

/**
 * Additional options for Compute#regionDisksInsert.
 */
export interface RegionDisksInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
  /**
   * Source image to restore onto a disk. This field is optional.
   */
  sourceImage?: string;
}

/**
 * Additional options for Compute#regionDisksList.
 */
export interface RegionDisksListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#regionDisksRemoveResourcePolicies.
 */
export interface RegionDisksRemoveResourcePoliciesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface RegionDisksRemoveResourcePoliciesRequest {
  /**
   * Resource policies to be removed from this disk.
   */
  resourcePolicies?: string[];
}

/**
 * Additional options for Compute#regionDisksResize.
 */
export interface RegionDisksResizeOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface RegionDisksResizeRequest {
  /**
   * The new size of the regional persistent disk, which is specified in GB.
   */
  sizeGb?: bigint;
}

function serializeRegionDisksResizeRequest(data: any): RegionDisksResizeRequest {
  return {
    ...data,
    sizeGb: data["sizeGb"] !== undefined ? String(data["sizeGb"]) : undefined,
  };
}

function deserializeRegionDisksResizeRequest(data: any): RegionDisksResizeRequest {
  return {
    ...data,
    sizeGb: data["sizeGb"] !== undefined ? BigInt(data["sizeGb"]) : undefined,
  };
}

/**
 * Additional options for Compute#regionDisksSetLabels.
 */
export interface RegionDisksSetLabelsOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionDisksUpdate.
 */
export interface RegionDisksUpdateOptions {
  paths?: string;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
  /**
   * update_mask indicates fields to be updated as part of this request.
   */
  updateMask?: string /* FieldMask */;
}

function serializeRegionDisksUpdateOptions(data: any): RegionDisksUpdateOptions {
  return {
    ...data,
    updateMask: data["updateMask"] !== undefined ? data["updateMask"] : undefined,
  };
}

function deserializeRegionDisksUpdateOptions(data: any): RegionDisksUpdateOptions {
  return {
    ...data,
    updateMask: data["updateMask"] !== undefined ? data["updateMask"] : undefined,
  };
}

export interface RegionDiskTypeList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of DiskType resources.
   */
  items?: DiskType[];
  /**
   * [Output Only] Type of resource. Always compute#regionDiskTypeList for
   * region disk types.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeRegionDiskTypeList(data: any): RegionDiskTypeList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeDiskType(item))) : undefined,
  };
}

function deserializeRegionDiskTypeList(data: any): RegionDiskTypeList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeDiskType(item))) : undefined,
  };
}

/**
 * Additional options for Compute#regionDiskTypesList.
 */
export interface RegionDiskTypesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#regionHealthChecksDelete.
 */
export interface RegionHealthChecksDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionHealthCheckServicesDelete.
 */
export interface RegionHealthCheckServicesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionHealthCheckServicesInsert.
 */
export interface RegionHealthCheckServicesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionHealthCheckServicesList.
 */
export interface RegionHealthCheckServicesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#regionHealthCheckServicesPatch.
 */
export interface RegionHealthCheckServicesPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionHealthChecksInsert.
 */
export interface RegionHealthChecksInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionHealthChecksList.
 */
export interface RegionHealthChecksListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#regionHealthChecksPatch.
 */
export interface RegionHealthChecksPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionHealthChecksUpdate.
 */
export interface RegionHealthChecksUpdateOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Contains a list of InstanceGroup resources.
 */
export interface RegionInstanceGroupList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of InstanceGroup resources.
   */
  items?: InstanceGroup[];
  /**
   * The resource type.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeRegionInstanceGroupList(data: any): RegionInstanceGroupList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeInstanceGroup(item))) : undefined,
  };
}

function deserializeRegionInstanceGroupList(data: any): RegionInstanceGroupList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeInstanceGroup(item))) : undefined,
  };
}

/**
 * RegionInstanceGroupManagers.deletePerInstanceConfigs
 */
export interface RegionInstanceGroupManagerDeleteInstanceConfigReq {
  /**
   * The list of instance names for which we want to delete per-instance
   * configs on this managed instance group.
   */
  names?: string[];
}

/**
 * Contains a list of managed instance groups.
 */
export interface RegionInstanceGroupManagerList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of InstanceGroupManager resources.
   */
  items?: InstanceGroupManager[];
  /**
   * [Output Only] The resource type, which is always
   * compute#instanceGroupManagerList for a list of managed instance groups that
   * exist in th regional scope.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeRegionInstanceGroupManagerList(data: any): RegionInstanceGroupManagerList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeInstanceGroupManager(item))) : undefined,
  };
}

function deserializeRegionInstanceGroupManagerList(data: any): RegionInstanceGroupManagerList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeInstanceGroupManager(item))) : undefined,
  };
}

/**
 * RegionInstanceGroupManagers.patchPerInstanceConfigs
 */
export interface RegionInstanceGroupManagerPatchInstanceConfigReq {
  /**
   * The list of per-instance configurations to insert or patch on this managed
   * instance group.
   */
  perInstanceConfigs?: PerInstanceConfig[];
}

function serializeRegionInstanceGroupManagerPatchInstanceConfigReq(data: any): RegionInstanceGroupManagerPatchInstanceConfigReq {
  return {
    ...data,
    perInstanceConfigs: data["perInstanceConfigs"] !== undefined ? data["perInstanceConfigs"].map((item: any) => (serializePerInstanceConfig(item))) : undefined,
  };
}

function deserializeRegionInstanceGroupManagerPatchInstanceConfigReq(data: any): RegionInstanceGroupManagerPatchInstanceConfigReq {
  return {
    ...data,
    perInstanceConfigs: data["perInstanceConfigs"] !== undefined ? data["perInstanceConfigs"].map((item: any) => (deserializePerInstanceConfig(item))) : undefined,
  };
}

/**
 * Additional options for Compute#regionInstanceGroupManagersAbandonInstances.
 */
export interface RegionInstanceGroupManagersAbandonInstancesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface RegionInstanceGroupManagersAbandonInstancesRequest {
  /**
   * The URLs of one or more instances to abandon. This can be a full URL or a
   * partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
   */
  instances?: string[];
}

/**
 * RegionInstanceGroupManagers.applyUpdatesToInstances
 */
export interface RegionInstanceGroupManagersApplyUpdatesRequest {
  /**
   * Flag to update all instances instead of specified list of instances. If
   * the flag is set to true then the instances may not be specified in the
   * request.
   */
  allInstances?: boolean;
  /**
   * The list of URLs of one or more instances for which you want to apply
   * updates. Each URL can be a full URL or a partial URL, such as
   * zones/[ZONE]/instances/[INSTANCE_NAME].
   */
  instances?: string[];
  /**
   * The minimal action that you want to perform on each instance during the
   * update: - REPLACE: At minimum, delete the instance and create it again. -
   * RESTART: Stop the instance and start it again. - REFRESH: Do not stop the
   * instance. - NONE: Do not disrupt the instance at all. By default, the
   * minimum action is NONE. If your update requires a more disruptive action
   * than you set with this flag, the necessary action is performed to execute
   * the update.
   */
  minimalAction?:  | "NONE" | "REFRESH" | "REPLACE" | "RESTART";
  /**
   * The most disruptive action that you want to perform on each instance
   * during the update: - REPLACE: Delete the instance and create it again. -
   * RESTART: Stop the instance and start it again. - REFRESH: Do not stop the
   * instance. - NONE: Do not disrupt the instance at all. By default, the most
   * disruptive allowed action is REPLACE. If your update requires a more
   * disruptive action than you set with this flag, the update request will
   * fail.
   */
  mostDisruptiveAllowedAction?:  | "NONE" | "REFRESH" | "REPLACE" | "RESTART";
}

/**
 * Additional options for Compute#regionInstanceGroupManagersCreateInstances.
 */
export interface RegionInstanceGroupManagersCreateInstancesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * RegionInstanceGroupManagers.createInstances
 */
export interface RegionInstanceGroupManagersCreateInstancesRequest {
  /**
   * [Required] List of specifications of per-instance configs.
   */
  instances?: PerInstanceConfig[];
}

function serializeRegionInstanceGroupManagersCreateInstancesRequest(data: any): RegionInstanceGroupManagersCreateInstancesRequest {
  return {
    ...data,
    instances: data["instances"] !== undefined ? data["instances"].map((item: any) => (serializePerInstanceConfig(item))) : undefined,
  };
}

function deserializeRegionInstanceGroupManagersCreateInstancesRequest(data: any): RegionInstanceGroupManagersCreateInstancesRequest {
  return {
    ...data,
    instances: data["instances"] !== undefined ? data["instances"].map((item: any) => (deserializePerInstanceConfig(item))) : undefined,
  };
}

/**
 * Additional options for Compute#regionInstanceGroupManagersDeleteInstances.
 */
export interface RegionInstanceGroupManagersDeleteInstancesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface RegionInstanceGroupManagersDeleteInstancesRequest {
  /**
   * The URLs of one or more instances to delete. This can be a full URL or a
   * partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
   */
  instances?: string[];
  /**
   * Specifies whether the request should proceed despite the inclusion of
   * instances that are not members of the group or that are already in the
   * process of being deleted or abandoned. If this field is set to `false` and
   * such an instance is specified in the request, the operation fails. The
   * operation always fails if the request contains a malformed instance URL or
   * a reference to an instance that exists in a zone or region other than the
   * group's zone or region.
   */
  skipInstancesOnValidationError?: boolean;
}

/**
 * Additional options for Compute#regionInstanceGroupManagersDelete.
 */
export interface RegionInstanceGroupManagersDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionInstanceGroupManagersInsert.
 */
export interface RegionInstanceGroupManagersInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionInstanceGroupManagersListErrors.
 */
export interface RegionInstanceGroupManagersListErrorsOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface RegionInstanceGroupManagersListErrorsResponse {
  /**
   * [Output Only] The list of errors of the managed instance group.
   */
  items?: InstanceManagedByIgmError[];
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
}

export interface RegionInstanceGroupManagersListInstanceConfigsResp {
  /**
   * [Output Only] The list of PerInstanceConfig.
   */
  items?: PerInstanceConfig[];
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeRegionInstanceGroupManagersListInstanceConfigsResp(data: any): RegionInstanceGroupManagersListInstanceConfigsResp {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializePerInstanceConfig(item))) : undefined,
  };
}

function deserializeRegionInstanceGroupManagersListInstanceConfigsResp(data: any): RegionInstanceGroupManagersListInstanceConfigsResp {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializePerInstanceConfig(item))) : undefined,
  };
}

export interface RegionInstanceGroupManagersListInstancesResponse {
  /**
   * A list of managed instances.
   */
  managedInstances?: ManagedInstance[];
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
}

function serializeRegionInstanceGroupManagersListInstancesResponse(data: any): RegionInstanceGroupManagersListInstancesResponse {
  return {
    ...data,
    managedInstances: data["managedInstances"] !== undefined ? data["managedInstances"].map((item: any) => (serializeManagedInstance(item))) : undefined,
  };
}

function deserializeRegionInstanceGroupManagersListInstancesResponse(data: any): RegionInstanceGroupManagersListInstancesResponse {
  return {
    ...data,
    managedInstances: data["managedInstances"] !== undefined ? data["managedInstances"].map((item: any) => (deserializeManagedInstance(item))) : undefined,
  };
}

/**
 * Additional options for
 * Compute#regionInstanceGroupManagersListManagedInstances.
 */
export interface RegionInstanceGroupManagersListManagedInstancesOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#regionInstanceGroupManagersList.
 */
export interface RegionInstanceGroupManagersListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for
 * Compute#regionInstanceGroupManagersListPerInstanceConfigs.
 */
export interface RegionInstanceGroupManagersListPerInstanceConfigsOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#regionInstanceGroupManagersPatch.
 */
export interface RegionInstanceGroupManagersPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for
 * Compute#regionInstanceGroupManagersPatchPerInstanceConfigs.
 */
export interface RegionInstanceGroupManagersPatchPerInstanceConfigsOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionInstanceGroupManagersRecreateInstances.
 */
export interface RegionInstanceGroupManagersRecreateInstancesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface RegionInstanceGroupManagersRecreateRequest {
  /**
   * The URLs of one or more instances to recreate. This can be a full URL or a
   * partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
   */
  instances?: string[];
}

/**
 * Additional options for Compute#regionInstanceGroupManagersResize.
 */
export interface RegionInstanceGroupManagersResizeOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
  /**
   * Number of instances that should exist in this instance group manager.
   */
  size: number;
}

/**
 * Additional options for
 * Compute#regionInstanceGroupManagersSetInstanceTemplate.
 */
export interface RegionInstanceGroupManagersSetInstanceTemplateOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionInstanceGroupManagersSetTargetPools.
 */
export interface RegionInstanceGroupManagersSetTargetPoolsOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface RegionInstanceGroupManagersSetTargetPoolsRequest {
  /**
   * Fingerprint of the target pools information, which is a hash of the
   * contents. This field is used for optimistic locking when you update the
   * target pool entries. This field is optional.
   */
  fingerprint?: Uint8Array;
  /**
   * The URL of all TargetPool resources to which instances in the
   * instanceGroup field are added. The target pools automatically apply to all
   * of the instances in the managed instance group.
   */
  targetPools?: string[];
}

function serializeRegionInstanceGroupManagersSetTargetPoolsRequest(data: any): RegionInstanceGroupManagersSetTargetPoolsRequest {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
  };
}

function deserializeRegionInstanceGroupManagersSetTargetPoolsRequest(data: any): RegionInstanceGroupManagersSetTargetPoolsRequest {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
  };
}

export interface RegionInstanceGroupManagersSetTemplateRequest {
  /**
   * URL of the InstanceTemplate resource from which all new instances will be
   * created.
   */
  instanceTemplate?: string;
}

/**
 * Additional options for
 * Compute#regionInstanceGroupManagersUpdatePerInstanceConfigs.
 */
export interface RegionInstanceGroupManagersUpdatePerInstanceConfigsOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * RegionInstanceGroupManagers.updatePerInstanceConfigs
 */
export interface RegionInstanceGroupManagerUpdateInstanceConfigReq {
  /**
   * The list of per-instance configurations to insert or patch on this managed
   * instance group.
   */
  perInstanceConfigs?: PerInstanceConfig[];
}

function serializeRegionInstanceGroupManagerUpdateInstanceConfigReq(data: any): RegionInstanceGroupManagerUpdateInstanceConfigReq {
  return {
    ...data,
    perInstanceConfigs: data["perInstanceConfigs"] !== undefined ? data["perInstanceConfigs"].map((item: any) => (serializePerInstanceConfig(item))) : undefined,
  };
}

function deserializeRegionInstanceGroupManagerUpdateInstanceConfigReq(data: any): RegionInstanceGroupManagerUpdateInstanceConfigReq {
  return {
    ...data,
    perInstanceConfigs: data["perInstanceConfigs"] !== undefined ? data["perInstanceConfigs"].map((item: any) => (deserializePerInstanceConfig(item))) : undefined,
  };
}

export interface RegionInstanceGroupsListInstances {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of InstanceWithNamedPorts resources.
   */
  items?: InstanceWithNamedPorts[];
  /**
   * The resource type.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

/**
 * Additional options for Compute#regionInstanceGroupsListInstances.
 */
export interface RegionInstanceGroupsListInstancesOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface RegionInstanceGroupsListInstancesRequest {
  /**
   * Instances in which state should be returned. Valid options are: 'ALL',
   * 'RUNNING'. By default, it lists all instances.
   */
  instanceState?:  | "ALL" | "RUNNING";
  /**
   * Name of port user is interested in. It is optional. If it is set, only
   * information about this ports will be returned. If it is not set, all the
   * named ports will be returned. Always lists all instances.
   */
  portName?: string;
}

/**
 * Additional options for Compute#regionInstanceGroupsList.
 */
export interface RegionInstanceGroupsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#regionInstanceGroupsSetNamedPorts.
 */
export interface RegionInstanceGroupsSetNamedPortsOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface RegionInstanceGroupsSetNamedPortsRequest {
  /**
   * The fingerprint of the named ports information for this instance group.
   * Use this optional property to prevent conflicts when multiple users change
   * the named ports settings concurrently. Obtain the fingerprint with the
   * instanceGroups.get method. Then, include the fingerprint in your request to
   * ensure that you do not overwrite changes that were applied from another
   * concurrent request.
   */
  fingerprint?: Uint8Array;
  /**
   * The list of named ports to set for this instance group.
   */
  namedPorts?: NamedPort[];
}

function serializeRegionInstanceGroupsSetNamedPortsRequest(data: any): RegionInstanceGroupsSetNamedPortsRequest {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
  };
}

function deserializeRegionInstanceGroupsSetNamedPortsRequest(data: any): RegionInstanceGroupsSetNamedPortsRequest {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
  };
}

/**
 * Additional options for Compute#regionInstancesBulkInsert.
 */
export interface RegionInstancesBulkInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionInstanceTemplatesDelete.
 */
export interface RegionInstanceTemplatesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionInstanceTemplatesInsert.
 */
export interface RegionInstanceTemplatesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionInstanceTemplatesList.
 */
export interface RegionInstanceTemplatesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Contains a list of region resources.
 */
export interface RegionList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of Region resources.
   */
  items?: Region[];
  /**
   * [Output Only] Type of resource. Always compute#regionList for lists of
   * regions.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeRegionList(data: any): RegionList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeRegion(item))) : undefined,
  };
}

function deserializeRegionList(data: any): RegionList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeRegion(item))) : undefined,
  };
}

/**
 * Additional options for Compute#regionNetworkEndpointGroupsDelete.
 */
export interface RegionNetworkEndpointGroupsDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionNetworkEndpointGroupsInsert.
 */
export interface RegionNetworkEndpointGroupsInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionNetworkEndpointGroupsList.
 */
export interface RegionNetworkEndpointGroupsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#regionNetworkFirewallPoliciesAddAssociation.
 */
export interface RegionNetworkFirewallPoliciesAddAssociationOptions {
  /**
   * Indicates whether or not to replace it if an association already exists.
   * This is false by default, in which case an error will be returned if an
   * association already exists.
   */
  replaceExistingAssociation?: boolean;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionNetworkFirewallPoliciesAddRule.
 */
export interface RegionNetworkFirewallPoliciesAddRuleOptions {
  /**
   * When rule.priority is not specified, auto choose a unused priority between
   * minPriority and maxPriority>. This field is exclusive with rule.priority.
   */
  maxPriority?: number;
  /**
   * When rule.priority is not specified, auto choose a unused priority between
   * minPriority and maxPriority>. This field is exclusive with rule.priority.
   */
  minPriority?: number;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionNetworkFirewallPoliciesCloneRules.
 */
export interface RegionNetworkFirewallPoliciesCloneRulesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
  /**
   * The firewall policy from which to copy rules.
   */
  sourceFirewallPolicy?: string;
}

/**
 * Additional options for Compute#regionNetworkFirewallPoliciesDelete.
 */
export interface RegionNetworkFirewallPoliciesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionNetworkFirewallPoliciesGetAssociation.
 */
export interface RegionNetworkFirewallPoliciesGetAssociationOptions {
  /**
   * The name of the association to get from the firewall policy.
   */
  name?: string;
}

/**
 * Additional options for
 * Compute#regionNetworkFirewallPoliciesGetEffectiveFirewalls.
 */
export interface RegionNetworkFirewallPoliciesGetEffectiveFirewallsOptions {
  /**
   * Network reference
   */
  network: string;
}

export interface RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponse {
  /**
   * Effective firewalls from firewall policy.
   */
  firewallPolicys?: RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseEffectiveFirewallPolicy[];
  /**
   * Effective firewalls on the network.
   */
  firewalls?: Firewall[];
}

function serializeRegionNetworkFirewallPoliciesGetEffectiveFirewallsResponse(data: any): RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponse {
  return {
    ...data,
    firewalls: data["firewalls"] !== undefined ? data["firewalls"].map((item: any) => (serializeFirewall(item))) : undefined,
  };
}

function deserializeRegionNetworkFirewallPoliciesGetEffectiveFirewallsResponse(data: any): RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponse {
  return {
    ...data,
    firewalls: data["firewalls"] !== undefined ? data["firewalls"].map((item: any) => (deserializeFirewall(item))) : undefined,
  };
}

export interface RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseEffectiveFirewallPolicy {
  /**
   * [Output Only] The display name of the firewall policy.
   */
  displayName?: string;
  /**
   * [Output Only] The name of the firewall policy.
   */
  name?: string;
  /**
   * The rules that apply to the network.
   */
  rules?: FirewallPolicyRule[];
  /**
   * [Output Only] The type of the firewall policy. Can be one of HIERARCHY,
   * NETWORK, NETWORK_REGIONAL.
   */
  type?:  | "HIERARCHY" | "NETWORK" | "NETWORK_REGIONAL" | "UNSPECIFIED";
}

/**
 * Additional options for Compute#regionNetworkFirewallPoliciesGetIamPolicy.
 */
export interface RegionNetworkFirewallPoliciesGetIamPolicyOptions {
  /**
   * Requested IAM Policy version.
   */
  optionsRequestedPolicyVersion?: number;
}

/**
 * Additional options for Compute#regionNetworkFirewallPoliciesGetRule.
 */
export interface RegionNetworkFirewallPoliciesGetRuleOptions {
  /**
   * The priority of the rule to get from the firewall policy.
   */
  priority?: number;
}

/**
 * Additional options for Compute#regionNetworkFirewallPoliciesInsert.
 */
export interface RegionNetworkFirewallPoliciesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionNetworkFirewallPoliciesList.
 */
export interface RegionNetworkFirewallPoliciesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#regionNetworkFirewallPoliciesPatch.
 */
export interface RegionNetworkFirewallPoliciesPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionNetworkFirewallPoliciesPatchRule.
 */
export interface RegionNetworkFirewallPoliciesPatchRuleOptions {
  /**
   * The priority of the rule to patch.
   */
  priority?: number;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for
 * Compute#regionNetworkFirewallPoliciesRemoveAssociation.
 */
export interface RegionNetworkFirewallPoliciesRemoveAssociationOptions {
  /**
   * Name for the association that will be removed.
   */
  name?: string;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionNetworkFirewallPoliciesRemoveRule.
 */
export interface RegionNetworkFirewallPoliciesRemoveRuleOptions {
  /**
   * The priority of the rule to remove from the firewall policy.
   */
  priority?: number;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionNotificationEndpointsDelete.
 */
export interface RegionNotificationEndpointsDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionNotificationEndpointsInsert.
 */
export interface RegionNotificationEndpointsInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionNotificationEndpointsList.
 */
export interface RegionNotificationEndpointsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#regionOperationsList.
 */
export interface RegionOperationsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#regionSecurityPoliciesDelete.
 */
export interface RegionSecurityPoliciesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionSecurityPoliciesInsert.
 */
export interface RegionSecurityPoliciesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
  /**
   * If true, the request will not be committed.
   */
  validateOnly?: boolean;
}

/**
 * Additional options for Compute#regionSecurityPoliciesList.
 */
export interface RegionSecurityPoliciesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#regionSecurityPoliciesPatch.
 */
export interface RegionSecurityPoliciesPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface RegionSetLabelsRequest {
  /**
   * The fingerprint of the previous set of labels for this resource, used to
   * detect conflicts. The fingerprint is initially generated by Compute Engine
   * and changes after every request to modify or update labels. You must always
   * provide an up-to-date fingerprint hash in order to update or change labels.
   * Make a get() request to the resource to get the latest fingerprint.
   */
  labelFingerprint?: Uint8Array;
  /**
   * The labels to set for this resource.
   */
  labels?: {
    [key: string]: string
  };
}

function serializeRegionSetLabelsRequest(data: any): RegionSetLabelsRequest {
  return {
    ...data,
    labelFingerprint: data["labelFingerprint"] !== undefined ? encodeBase64(data["labelFingerprint"]) : undefined,
  };
}

function deserializeRegionSetLabelsRequest(data: any): RegionSetLabelsRequest {
  return {
    ...data,
    labelFingerprint: data["labelFingerprint"] !== undefined ? decodeBase64(data["labelFingerprint"] as string) : undefined,
  };
}

export interface RegionSetPolicyRequest {
  /**
   * Flatten Policy to create a backwacd compatible wire-format. Deprecated.
   * Use 'policy' to specify bindings.
   */
  bindings?: Binding[];
  /**
   * Flatten Policy to create a backward compatible wire-format. Deprecated.
   * Use 'policy' to specify the etag.
   */
  etag?: Uint8Array;
  /**
   * REQUIRED: The complete policy to be applied to the 'resource'. The size of
   * the policy is limited to a few 10s of KB. An empty policy is in general a
   * valid policy but certain services (like Projects) might reject them.
   */
  policy?: Policy;
}

function serializeRegionSetPolicyRequest(data: any): RegionSetPolicyRequest {
  return {
    ...data,
    etag: data["etag"] !== undefined ? encodeBase64(data["etag"]) : undefined,
    policy: data["policy"] !== undefined ? serializePolicy(data["policy"]) : undefined,
  };
}

function deserializeRegionSetPolicyRequest(data: any): RegionSetPolicyRequest {
  return {
    ...data,
    etag: data["etag"] !== undefined ? decodeBase64(data["etag"] as string) : undefined,
    policy: data["policy"] !== undefined ? deserializePolicy(data["policy"]) : undefined,
  };
}

/**
 * Additional options for Compute#regionsList.
 */
export interface RegionsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#regionSslCertificatesDelete.
 */
export interface RegionSslCertificatesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionSslCertificatesInsert.
 */
export interface RegionSslCertificatesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionSslCertificatesList.
 */
export interface RegionSslCertificatesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#regionSslPoliciesDelete.
 */
export interface RegionSslPoliciesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionSslPoliciesInsert.
 */
export interface RegionSslPoliciesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionSslPoliciesListAvailableFeatures.
 */
export interface RegionSslPoliciesListAvailableFeaturesOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#regionSslPoliciesList.
 */
export interface RegionSslPoliciesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#regionSslPoliciesPatch.
 */
export interface RegionSslPoliciesPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionTargetHttpProxiesDelete.
 */
export interface RegionTargetHttpProxiesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionTargetHttpProxiesInsert.
 */
export interface RegionTargetHttpProxiesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionTargetHttpProxiesList.
 */
export interface RegionTargetHttpProxiesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#regionTargetHttpProxiesSetUrlMap.
 */
export interface RegionTargetHttpProxiesSetUrlMapOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionTargetHttpsProxiesDelete.
 */
export interface RegionTargetHttpsProxiesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionTargetHttpsProxiesInsert.
 */
export interface RegionTargetHttpsProxiesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionTargetHttpsProxiesList.
 */
export interface RegionTargetHttpsProxiesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#regionTargetHttpsProxiesPatch.
 */
export interface RegionTargetHttpsProxiesPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionTargetHttpsProxiesSetSslCertificates.
 */
export interface RegionTargetHttpsProxiesSetSslCertificatesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface RegionTargetHttpsProxiesSetSslCertificatesRequest {
  /**
   * New set of SslCertificate resources to associate with this
   * TargetHttpsProxy resource.
   */
  sslCertificates?: string[];
}

/**
 * Additional options for Compute#regionTargetHttpsProxiesSetUrlMap.
 */
export interface RegionTargetHttpsProxiesSetUrlMapOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionTargetTcpProxiesDelete.
 */
export interface RegionTargetTcpProxiesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionTargetTcpProxiesInsert.
 */
export interface RegionTargetTcpProxiesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionTargetTcpProxiesList.
 */
export interface RegionTargetTcpProxiesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#regionUrlMapsDelete.
 */
export interface RegionUrlMapsDeleteOptions {
  /**
   * begin_interface: MixerMutationRequestBuilder Request ID to support
   * idempotency.
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionUrlMapsInsert.
 */
export interface RegionUrlMapsInsertOptions {
  /**
   * begin_interface: MixerMutationRequestBuilder Request ID to support
   * idempotency.
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionUrlMapsList.
 */
export interface RegionUrlMapsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#regionUrlMapsPatch.
 */
export interface RegionUrlMapsPatchOptions {
  /**
   * begin_interface: MixerMutationRequestBuilder Request ID to support
   * idempotency.
   */
  requestId?: string;
}

/**
 * Additional options for Compute#regionUrlMapsUpdate.
 */
export interface RegionUrlMapsUpdateOptions {
  /**
   * begin_interface: MixerMutationRequestBuilder Request ID to support
   * idempotency.
   */
  requestId?: string;
}

export interface RegionUrlMapsValidateRequest {
  /**
   * Content of the UrlMap to be validated.
   */
  resource?: UrlMap;
}

function serializeRegionUrlMapsValidateRequest(data: any): RegionUrlMapsValidateRequest {
  return {
    ...data,
    resource: data["resource"] !== undefined ? serializeUrlMap(data["resource"]) : undefined,
  };
}

function deserializeRegionUrlMapsValidateRequest(data: any): RegionUrlMapsValidateRequest {
  return {
    ...data,
    resource: data["resource"] !== undefined ? deserializeUrlMap(data["resource"]) : undefined,
  };
}

/**
 * A policy that specifies how requests intended for the route's backends are
 * shadowed to a separate mirrored backend service. The load balancer doesn't
 * wait for responses from the shadow service. Before sending traffic to the
 * shadow service, the host or authority header is suffixed with -shadow.
 */
export interface RequestMirrorPolicy {
  /**
   * The full or partial URL to the BackendService resource being mirrored to.
   * The backend service configured for a mirroring policy must reference
   * backends that are of the same type as the original backend service matched
   * in the URL map. Serverless NEG backends are not currently supported as a
   * mirrored backend service.
   */
  backendService?: string;
}

/**
 * Represents a reservation resource. A reservation ensures that capacity is
 * held in a specific zone even if the reserved VMs are not running. For more
 * information, read Reserving zonal resources.
 */
export interface Reservation {
  /**
   * [Output Only] Full or partial URL to a parent commitment. This field
   * displays for reservations that are tied to a commitment.
   */
  commitment?: string;
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of the resource. Always compute#reservations for
   * reservations.
   */
  kind?: string;
  /**
   * The name of the resource, provided by the client when initially creating
   * the resource. The resource name must be 1-63 characters long, and comply
   * with RFC1035. Specifically, the name must be 1-63 characters long and match
   * the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first
   * character must be a lowercase letter, and all following characters must be
   * a dash, lowercase letter, or digit, except the last character, which cannot
   * be a dash.
   */
  name?: string;
  /**
   * Resource policies to be added to this reservation. The key is defined by
   * user, and the value is resource policy url. This is to define placement
   * policy with reservation.
   */
  resourcePolicies?: {
    [key: string]: string
  };
  /**
   * [Output Only] Status information for Reservation resource.
   */
  resourceStatus?: AllocationResourceStatus;
  /**
   * [Output Only] Reserved for future use.
   */
  satisfiesPzs?: boolean;
  /**
   * [Output Only] Server-defined fully-qualified URL for this resource.
   */
  selfLink?: string;
  /**
   * Specify share-settings to create a shared reservation. This property is
   * optional. For more information about the syntax and options for this field
   * and its subfields, see the guide for creating a shared reservation.
   */
  shareSettings?: ShareSettings;
  /**
   * Reservation for instances with specific machine shapes.
   */
  specificReservation?: AllocationSpecificSKUReservation;
  /**
   * Indicates whether the reservation can be consumed by VMs with affinity for
   * "any" reservation. If the field is set, then only VMs that target the
   * reservation by name can consume from this reservation.
   */
  specificReservationRequired?: boolean;
  /**
   * [Output Only] The status of the reservation.
   */
  status?:  | "CREATING" | "DELETING" | "INVALID" | "READY" | "UPDATING";
  /**
   * Zone in which the reservation resides. A zone must be provided if the
   * reservation is created within a commitment.
   */
  zone?: string;
}

function serializeReservation(data: any): Reservation {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
    specificReservation: data["specificReservation"] !== undefined ? serializeAllocationSpecificSKUReservation(data["specificReservation"]) : undefined,
  };
}

function deserializeReservation(data: any): Reservation {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
    specificReservation: data["specificReservation"] !== undefined ? deserializeAllocationSpecificSKUReservation(data["specificReservation"]) : undefined,
  };
}

/**
 * Specifies the reservations that this instance can consume from.
 */
export interface ReservationAffinity {
  /**
   * Specifies the type of reservation from which this instance can consume
   * resources: ANY_RESERVATION (default), SPECIFIC_RESERVATION, or
   * NO_RESERVATION. See Consuming reserved instances for examples.
   */
  consumeReservationType?:  | "ANY_RESERVATION" | "NO_RESERVATION" | "SPECIFIC_RESERVATION" | "UNSPECIFIED";
  /**
   * Corresponds to the label key of a reservation resource. To target a
   * SPECIFIC_RESERVATION by name, specify googleapis.com/reservation-name as
   * the key and specify the name of your reservation as its value.
   */
  key?: string;
  /**
   * Corresponds to the label values of a reservation resource. This can be
   * either a name to a reservation in the same project or
   * "projects/different-project/reservations/some-reservation-name" to target a
   * shared reservation in the same zone but in a different project.
   */
  values?: string[];
}

/**
 * Contains a list of reservations.
 */
export interface ReservationAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of Allocation resources.
   */
  items?: {
    [key: string]: ReservationsScopedList
  };
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeReservationAggregatedList(data: any): ReservationAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeReservationsScopedList(v)]))) : undefined,
  };
}

function deserializeReservationAggregatedList(data: any): ReservationAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeReservationsScopedList(v)]))) : undefined,
  };
}

export interface ReservationList {
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: string;
  /**
   * [Output Only] A list of Allocation resources.
   */
  items?: Reservation[];
  /**
   * [Output Only] Type of resource.Always compute#reservationsList for listsof
   * reservations
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeReservationList(data: any): ReservationList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeReservation(item))) : undefined,
  };
}

function deserializeReservationList(data: any): ReservationList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeReservation(item))) : undefined,
  };
}

/**
 * Additional options for Compute#reservationsAggregatedList.
 */
export interface ReservationsAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#reservationsDelete.
 */
export interface ReservationsDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#reservationsGetIamPolicy.
 */
export interface ReservationsGetIamPolicyOptions {
  /**
   * Requested IAM Policy version.
   */
  optionsRequestedPolicyVersion?: number;
}

/**
 * Additional options for Compute#reservationsInsert.
 */
export interface ReservationsInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#reservationsList.
 */
export interface ReservationsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#reservationsResize.
 */
export interface ReservationsResizeOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface ReservationsResizeRequest {
  /**
   * Number of allocated resources can be resized with minimum = 1 and maximum
   * = 1000.
   */
  specificSkuCount?: bigint;
}

function serializeReservationsResizeRequest(data: any): ReservationsResizeRequest {
  return {
    ...data,
    specificSkuCount: data["specificSkuCount"] !== undefined ? String(data["specificSkuCount"]) : undefined,
  };
}

function deserializeReservationsResizeRequest(data: any): ReservationsResizeRequest {
  return {
    ...data,
    specificSkuCount: data["specificSkuCount"] !== undefined ? BigInt(data["specificSkuCount"]) : undefined,
  };
}

export interface ReservationsScopedList {
  /**
   * A list of reservations contained in this scope.
   */
  reservations?: Reservation[];
  /**
   * Informational warning which replaces the list of reservations when the
   * list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeReservationsScopedList(data: any): ReservationsScopedList {
  return {
    ...data,
    reservations: data["reservations"] !== undefined ? data["reservations"].map((item: any) => (serializeReservation(item))) : undefined,
  };
}

function deserializeReservationsScopedList(data: any): ReservationsScopedList {
  return {
    ...data,
    reservations: data["reservations"] !== undefined ? data["reservations"].map((item: any) => (deserializeReservation(item))) : undefined,
  };
}

/**
 * Additional options for Compute#reservationsUpdate.
 */
export interface ReservationsUpdateOptions {
  paths?: string;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
  /**
   * Update_mask indicates fields to be updated as part of this request.
   */
  updateMask?: string /* FieldMask */;
}

function serializeReservationsUpdateOptions(data: any): ReservationsUpdateOptions {
  return {
    ...data,
    updateMask: data["updateMask"] !== undefined ? data["updateMask"] : undefined,
  };
}

function deserializeReservationsUpdateOptions(data: any): ReservationsUpdateOptions {
  return {
    ...data,
    updateMask: data["updateMask"] !== undefined ? data["updateMask"] : undefined,
  };
}

/**
 * Commitment for a particular resource (a Commitment is composed of one or
 * more of these).
 */
export interface ResourceCommitment {
  /**
   * Name of the accelerator type resource. Applicable only when the type is
   * ACCELERATOR.
   */
  acceleratorType?: string;
  /**
   * The amount of the resource purchased (in a type-dependent unit, such as
   * bytes). For vCPUs, this can just be an integer. For memory, this must be
   * provided in MB. Memory must be a multiple of 256 MB, with up to 6.5GB of
   * memory per every vCPU.
   */
  amount?: bigint;
  /**
   * Type of resource for which this commitment applies. Possible values are
   * VCPU, MEMORY, LOCAL_SSD, and ACCELERATOR.
   */
  type?:  | "ACCELERATOR" | "LOCAL_SSD" | "MEMORY" | "UNSPECIFIED" | "VCPU";
}

function serializeResourceCommitment(data: any): ResourceCommitment {
  return {
    ...data,
    amount: data["amount"] !== undefined ? String(data["amount"]) : undefined,
  };
}

function deserializeResourceCommitment(data: any): ResourceCommitment {
  return {
    ...data,
    amount: data["amount"] !== undefined ? BigInt(data["amount"]) : undefined,
  };
}

export interface ResourceGroupReference {
  /**
   * A URI referencing one of the instance groups or network endpoint groups
   * listed in the backend service.
   */
  group?: string;
}

/**
 * Additional options for Compute#resourcePoliciesAggregatedList.
 */
export interface ResourcePoliciesAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#resourcePoliciesDelete.
 */
export interface ResourcePoliciesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#resourcePoliciesGetIamPolicy.
 */
export interface ResourcePoliciesGetIamPolicyOptions {
  /**
   * Requested IAM Policy version.
   */
  optionsRequestedPolicyVersion?: number;
}

/**
 * Additional options for Compute#resourcePoliciesInsert.
 */
export interface ResourcePoliciesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#resourcePoliciesList.
 */
export interface ResourcePoliciesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface ResourcePoliciesScopedList {
  /**
   * A list of resourcePolicies contained in this scope.
   */
  resourcePolicies?: ResourcePolicy[];
  /**
   * Informational warning which replaces the list of resourcePolicies when the
   * list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeResourcePoliciesScopedList(data: any): ResourcePoliciesScopedList {
  return {
    ...data,
    resourcePolicies: data["resourcePolicies"] !== undefined ? data["resourcePolicies"].map((item: any) => (serializeResourcePolicy(item))) : undefined,
  };
}

function deserializeResourcePoliciesScopedList(data: any): ResourcePoliciesScopedList {
  return {
    ...data,
    resourcePolicies: data["resourcePolicies"] !== undefined ? data["resourcePolicies"].map((item: any) => (deserializeResourcePolicy(item))) : undefined,
  };
}

/**
 * Represents a Resource Policy resource. You can use resource policies to
 * schedule actions for some Compute Engine resources. For example, you can use
 * them to schedule persistent disk snapshots.
 */
export interface ResourcePolicy {
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  description?: string;
  /**
   * Resource policy for instances for placement configuration.
   */
  groupPlacementPolicy?: ResourcePolicyGroupPlacementPolicy;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * Resource policy for scheduling instance operations.
   */
  instanceSchedulePolicy?: ResourcePolicyInstanceSchedulePolicy;
  /**
   * [Output Only] Type of the resource. Always compute#resource_policies for
   * resource policies.
   */
  kind?: string;
  /**
   * The name of the resource, provided by the client when initially creating
   * the resource. The resource name must be 1-63 characters long, and comply
   * with RFC1035. Specifically, the name must be 1-63 characters long and match
   * the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first
   * character must be a lowercase letter, and all following characters must be
   * a dash, lowercase letter, or digit, except the last character, which cannot
   * be a dash.
   */
  name?: string;
  region?: string;
  /**
   * [Output Only] The system status of the resource policy.
   */
  resourceStatus?: ResourcePolicyResourceStatus;
  /**
   * [Output Only] Server-defined fully-qualified URL for this resource.
   */
  selfLink?: string;
  /**
   * Resource policy for persistent disks for creating snapshots.
   */
  snapshotSchedulePolicy?: ResourcePolicySnapshotSchedulePolicy;
  /**
   * [Output Only] The status of resource policy creation.
   */
  status?:  | "CREATING" | "DELETING" | "EXPIRED" | "INVALID" | "READY";
}

function serializeResourcePolicy(data: any): ResourcePolicy {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeResourcePolicy(data: any): ResourcePolicy {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

/**
 * Contains a list of resourcePolicies.
 */
export interface ResourcePolicyAggregatedList {
  etag?: string;
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of ResourcePolicy resources.
   */
  items?: {
    [key: string]: ResourcePoliciesScopedList
  };
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeResourcePolicyAggregatedList(data: any): ResourcePolicyAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeResourcePoliciesScopedList(v)]))) : undefined,
  };
}

function deserializeResourcePolicyAggregatedList(data: any): ResourcePolicyAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeResourcePoliciesScopedList(v)]))) : undefined,
  };
}

/**
 * Time window specified for daily operations.
 */
export interface ResourcePolicyDailyCycle {
  /**
   * Defines a schedule with units measured in days. The value determines how
   * many days pass between the start of each cycle.
   */
  daysInCycle?: number;
  /**
   * [Output only] A predetermined duration for the window, automatically
   * chosen to be the smallest possible in the given scenario.
   */
  duration?: string;
  /**
   * Start time of the window. This must be in UTC format that resolves to one
   * of 00:00, 04:00, 08:00, 12:00, 16:00, or 20:00. For example, both 13:00-5
   * and 08:00 are valid.
   */
  startTime?: string;
}

/**
 * A GroupPlacementPolicy specifies resource placement configuration. It
 * specifies the failure bucket separation as well as network locality
 */
export interface ResourcePolicyGroupPlacementPolicy {
  /**
   * The number of availability domains to spread instances across. If two
   * instances are in different availability domain, they are not in the same
   * low latency network.
   */
  availabilityDomainCount?: number;
  /**
   * Specifies network collocation
   */
  collocation?:  | "COLLOCATED" | "UNSPECIFIED_COLLOCATION";
  /**
   * Number of VMs in this placement group. Google does not recommend that you
   * use this field unless you use a compact policy and you want your policy to
   * work only if it contains this exact number of VMs.
   */
  vmCount?: number;
}

/**
 * Time window specified for hourly operations.
 */
export interface ResourcePolicyHourlyCycle {
  /**
   * [Output only] Duration of the time window, automatically chosen to be
   * smallest possible in the given scenario.
   */
  duration?: string;
  /**
   * Defines a schedule with units measured in hours. The value determines how
   * many hours pass between the start of each cycle.
   */
  hoursInCycle?: number;
  /**
   * Time within the window to start the operations. It must be in format
   * "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
   */
  startTime?: string;
}

/**
 * An InstanceSchedulePolicy specifies when and how frequent certain operations
 * are performed on the instance.
 */
export interface ResourcePolicyInstanceSchedulePolicy {
  /**
   * The expiration time of the schedule. The timestamp is an RFC3339 string.
   */
  expirationTime?: string;
  /**
   * The start time of the schedule. The timestamp is an RFC3339 string.
   */
  startTime?: string;
  /**
   * Specifies the time zone to be used in interpreting Schedule.schedule. The
   * value of this field must be a time zone name from the tz database:
   * https://wikipedia.org/wiki/Tz_database.
   */
  timeZone?: string;
  /**
   * Specifies the schedule for starting instances.
   */
  vmStartSchedule?: ResourcePolicyInstanceSchedulePolicySchedule;
  /**
   * Specifies the schedule for stopping instances.
   */
  vmStopSchedule?: ResourcePolicyInstanceSchedulePolicySchedule;
}

/**
 * Schedule for an instance operation.
 */
export interface ResourcePolicyInstanceSchedulePolicySchedule {
  /**
   * Specifies the frequency for the operation, using the unix-cron format.
   */
  schedule?: string;
}

export interface ResourcePolicyList {
  etag?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: string;
  /**
   * [Output Only] A list of ResourcePolicy resources.
   */
  items?: ResourcePolicy[];
  /**
   * [Output Only] Type of resource.Always compute#resourcePoliciesList for
   * listsof resourcePolicies
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeResourcePolicyList(data: any): ResourcePolicyList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeResourcePolicy(item))) : undefined,
  };
}

function deserializeResourcePolicyList(data: any): ResourcePolicyList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeResourcePolicy(item))) : undefined,
  };
}

/**
 * Contains output only fields. Use this sub-message for all output fields set
 * on ResourcePolicy. The internal structure of this "status" field should mimic
 * the structure of ResourcePolicy proto specification.
 */
export interface ResourcePolicyResourceStatus {
  /**
   * [Output Only] Specifies a set of output values reffering to the
   * instance_schedule_policy system status. This field should have the same
   * name as corresponding policy field.
   */
  instanceSchedulePolicy?: ResourcePolicyResourceStatusInstanceSchedulePolicyStatus;
}

export interface ResourcePolicyResourceStatusInstanceSchedulePolicyStatus {
  /**
   * [Output Only] The last time the schedule successfully ran. The timestamp
   * is an RFC3339 string.
   */
  lastRunStartTime?: string;
  /**
   * [Output Only] The next time the schedule is planned to run. The actual
   * time might be slightly different. The timestamp is an RFC3339 string.
   */
  nextRunStartTime?: string;
}

/**
 * A snapshot schedule policy specifies when and how frequently snapshots are
 * to be created for the target disk. Also specifies how many and how long these
 * scheduled snapshots should be retained.
 */
export interface ResourcePolicySnapshotSchedulePolicy {
  /**
   * Retention policy applied to snapshots created by this resource policy.
   */
  retentionPolicy?: ResourcePolicySnapshotSchedulePolicyRetentionPolicy;
  /**
   * A Vm Maintenance Policy specifies what kind of infrastructure maintenance
   * we are allowed to perform on this VM and when. Schedule that is applied to
   * disks covered by this policy.
   */
  schedule?: ResourcePolicySnapshotSchedulePolicySchedule;
  /**
   * Properties with which snapshots are created such as labels, encryption
   * keys.
   */
  snapshotProperties?: ResourcePolicySnapshotSchedulePolicySnapshotProperties;
}

/**
 * Policy for retention of scheduled snapshots.
 */
export interface ResourcePolicySnapshotSchedulePolicyRetentionPolicy {
  /**
   * Maximum age of the snapshot that is allowed to be kept.
   */
  maxRetentionDays?: number;
  /**
   * Specifies the behavior to apply to scheduled snapshots when the source
   * disk is deleted.
   */
  onSourceDiskDelete?:  | "APPLY_RETENTION_POLICY" | "KEEP_AUTO_SNAPSHOTS" | "UNSPECIFIED_ON_SOURCE_DISK_DELETE";
}

/**
 * A schedule for disks where the schedueled operations are performed.
 */
export interface ResourcePolicySnapshotSchedulePolicySchedule {
  dailySchedule?: ResourcePolicyDailyCycle;
  hourlySchedule?: ResourcePolicyHourlyCycle;
  weeklySchedule?: ResourcePolicyWeeklyCycle;
}

/**
 * Specified snapshot properties for scheduled snapshots created by this
 * policy.
 */
export interface ResourcePolicySnapshotSchedulePolicySnapshotProperties {
  /**
   * Chain name that the snapshot is created in.
   */
  chainName?: string;
  /**
   * Indication to perform a 'guest aware' snapshot.
   */
  guestFlush?: boolean;
  /**
   * Labels to apply to scheduled snapshots. These can be later modified by the
   * setLabels method. Label values may be empty.
   */
  labels?: {
    [key: string]: string
  };
  /**
   * Cloud Storage bucket storage location of the auto snapshot (regional or
   * multi-regional).
   */
  storageLocations?: string[];
}

/**
 * Time window specified for weekly operations.
 */
export interface ResourcePolicyWeeklyCycle {
  /**
   * Up to 7 intervals/windows, one for each day of the week.
   */
  dayOfWeeks?: ResourcePolicyWeeklyCycleDayOfWeek[];
}

export interface ResourcePolicyWeeklyCycleDayOfWeek {
  /**
   * Defines a schedule that runs on specific days of the week. Specify one or
   * more days. The following options are available: MONDAY, TUESDAY, WEDNESDAY,
   * THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   */
  day?:  | "FRIDAY" | "INVALID" | "MONDAY" | "SATURDAY" | "SUNDAY" | "THURSDAY" | "TUESDAY" | "WEDNESDAY";
  /**
   * [Output only] Duration of the time window, automatically chosen to be
   * smallest possible in the given scenario.
   */
  duration?: string;
  /**
   * Time within the window to start the operations. It must be in format
   * "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
   */
  startTime?: string;
}

/**
 * Contains output only fields. Use this sub-message for actual values set on
 * Instance attributes as compared to the value requested by the user (intent)
 * in their instance CRUD calls.
 */
export interface ResourceStatus {
  /**
   * [Output Only] An opaque ID of the host on which the VM is running.
   */
  physicalHost?: string;
}

/**
 * Represents a Route resource. A route defines a path from VM instances in the
 * VPC network to a specific destination. This destination can be inside or
 * outside the VPC network. For more information, read the Routes overview.
 */
export interface Route {
  /**
   * [Output Only] AS path.
   */
  asPaths?: RouteAsPath[];
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this field when you
   * create the resource.
   */
  description?: string;
  /**
   * The destination range of outgoing packets that this route applies to. Both
   * IPv4 and IPv6 are supported.
   */
  destRange?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of this resource. Always compute#routes for Route
   * resources.
   */
  kind?: string;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a
   * lowercase letter, and all following characters (except for the last
   * character) must be a dash, lowercase letter, or digit. The last character
   * must be a lowercase letter or digit.
   */
  name?: string;
  /**
   * Fully-qualified URL of the network that this route applies to.
   */
  network?: string;
  /**
   * The URL to a gateway that should handle matching packets. You can only
   * specify the internet gateway using a full or partial valid URL: projects/
   * project/global/gateways/default-internet-gateway
   */
  nextHopGateway?: string;
  /**
   * The URL to a forwarding rule of type loadBalancingScheme=INTERNAL that
   * should handle matching packets or the IP address of the forwarding Rule.
   * For example, the following are all valid URLs: - 10.128.0.56 -
   * https://www.googleapis.com/compute/v1/projects/project/regions/region
   * /forwardingRules/forwardingRule -
   * regions/region/forwardingRules/forwardingRule
   */
  nextHopIlb?: string;
  /**
   * The URL to an instance that should handle matching packets. You can
   * specify this as a full or partial URL. For example:
   * https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/
   */
  nextHopInstance?: string;
  /**
   * The network IP address of an instance that should handle matching packets.
   * Only IPv4 is supported.
   */
  nextHopIp?: string;
  /**
   * The URL of the local network if it should handle matching packets.
   */
  nextHopNetwork?: string;
  /**
   * [Output Only] The network peering name that should handle matching
   * packets, which should conform to RFC1035.
   */
  nextHopPeering?: string;
  /**
   * The URL to a VpnTunnel that should handle matching packets.
   */
  nextHopVpnTunnel?: string;
  /**
   * The priority of this route. Priority is used to break ties in cases where
   * there is more than one matching route of equal prefix length. In cases
   * where multiple routes have equal prefix length, the one with the
   * lowest-numbered priority value wins. The default value is `1000`. The
   * priority value must be from `0` to `65535`, inclusive.
   */
  priority?: number;
  /**
   * [Output only] The status of the route.
   */
  routeStatus?:  | "ACTIVE" | "DROPPED" | "INACTIVE" | "PENDING";
  /**
   * [Output Only] The type of this route, which can be one of the following
   * values: - 'TRANSIT' for a transit route that this router learned from
   * another Cloud Router and will readvertise to one of its BGP peers -
   * 'SUBNET' for a route from a subnet of the VPC - 'BGP' for a route learned
   * from a BGP peer of this router - 'STATIC' for a static route
   */
  routeType?:  | "BGP" | "STATIC" | "SUBNET" | "TRANSIT";
  /**
   * [Output Only] Server-defined fully-qualified URL for this resource.
   */
  selfLink?: string;
  /**
   * A list of instance tags to which this route applies.
   */
  tags?: string[];
  /**
   * [Output Only] If potential misconfigurations are detected for this route,
   * this field will be populated with warning messages.
   */
  warnings?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  }[];
}

function serializeRoute(data: any): Route {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeRoute(data: any): Route {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface RouteAsPath {
  /**
   * [Output Only] The AS numbers of the AS Path.
   */
  asLists?: number[];
  /**
   * [Output Only] The type of the AS Path, which can be one of the following
   * values: - 'AS_SET': unordered set of autonomous systems that the route in
   * has traversed - 'AS_SEQUENCE': ordered set of autonomous systems that the
   * route has traversed - 'AS_CONFED_SEQUENCE': ordered set of Member
   * Autonomous Systems in the local confederation that the route has traversed
   * - 'AS_CONFED_SET': unordered set of Member Autonomous Systems in the local
   * confederation that the route has traversed
   */
  pathSegmentType?:  | "AS_CONFED_SEQUENCE" | "AS_CONFED_SET" | "AS_SEQUENCE" | "AS_SET";
}

/**
 * Contains a list of Route resources.
 */
export interface RouteList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of Route resources.
   */
  items?: Route[];
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeRouteList(data: any): RouteList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeRoute(item))) : undefined,
  };
}

function deserializeRouteList(data: any): RouteList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeRoute(item))) : undefined,
  };
}

/**
 * Represents a Cloud Router resource. For more information about Cloud Router,
 * read the Cloud Router overview.
 */
export interface Router {
  /**
   * BGP information specific to this router.
   */
  bgp?: RouterBgp;
  /**
   * BGP information that must be configured into the routing stack to
   * establish BGP peering. This information must specify the peer ASN and
   * either the interface name, IP address, or peer IP address. Please refer to
   * RFC4273.
   */
  bgpPeers?: RouterBgpPeer[];
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * Indicates if a router is dedicated for use with encrypted VLAN attachments
   * (interconnectAttachments).
   */
  encryptedInterconnectRouter?: boolean;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * Router interfaces. Each interface requires either one linked resource,
   * (for example, linkedVpnTunnel), or IP address and IP address range (for
   * example, ipRange), or both.
   */
  interfaces?: RouterInterface[];
  /**
   * [Output Only] Type of resource. Always compute#router for routers.
   */
  kind?: string;
  /**
   * Keys used for MD5 authentication.
   */
  md5AuthenticationKeys?: RouterMd5AuthenticationKey[];
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * A list of NAT services created in this router.
   */
  nats?: RouterNat[];
  /**
   * URI of the network to which this router belongs.
   */
  network?: string;
  /**
   * [Output Only] URI of the region where the router resides. You must specify
   * this field as part of the HTTP request URL. It is not settable as a field
   * in the request body.
   */
  region?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
}

function serializeRouter(data: any): Router {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeRouter(data: any): Router {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

/**
 * Description-tagged IP ranges for the router to advertise.
 */
export interface RouterAdvertisedIpRange {
  /**
   * User-specified description for the IP range.
   */
  description?: string;
  /**
   * The IP range to advertise. The value must be a CIDR-formatted string.
   */
  range?: string;
}

/**
 * Contains a list of routers.
 */
export interface RouterAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of Router resources.
   */
  items?: {
    [key: string]: RoutersScopedList
  };
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeRouterAggregatedList(data: any): RouterAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeRoutersScopedList(v)]))) : undefined,
  };
}

function deserializeRouterAggregatedList(data: any): RouterAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeRoutersScopedList(v)]))) : undefined,
  };
}

export interface RouterBgp {
  /**
   * User-specified list of prefix groups to advertise in custom mode. This
   * field can only be populated if advertise_mode is CUSTOM and is advertised
   * to all peers of the router. These groups will be advertised in addition to
   * any specified prefixes. Leave this field blank to advertise no custom
   * groups.
   */
  advertisedGroups?:  | "ALL_SUBNETS"[];
  /**
   * User-specified list of individual IP ranges to advertise in custom mode.
   * This field can only be populated if advertise_mode is CUSTOM and is
   * advertised to all peers of the router. These IP ranges will be advertised
   * in addition to any specified groups. Leave this field blank to advertise no
   * custom IP ranges.
   */
  advertisedIpRanges?: RouterAdvertisedIpRange[];
  /**
   * User-specified flag to indicate which mode to use for advertisement. The
   * options are DEFAULT or CUSTOM.
   */
  advertiseMode?:  | "CUSTOM" | "DEFAULT";
  /**
   * Local BGP Autonomous System Number (ASN). Must be an RFC6996 private ASN,
   * either 16-bit or 32-bit. The value will be fixed for this router resource.
   * All VPN tunnels that link to this router will have the same local ASN.
   */
  asn?: number;
  /**
   * The interval in seconds between BGP keepalive messages that are sent to
   * the peer. Hold time is three times the interval at which keepalive messages
   * are sent, and the hold time is the maximum number of seconds allowed to
   * elapse between successive keepalive messages that BGP receives from a peer.
   * BGP will use the smaller of either the local hold time value or the peer's
   * hold time value as the hold time for the BGP connection between the two
   * peers. If set, this value must be between 20 and 60. The default is 20.
   */
  keepaliveInterval?: number;
}

export interface RouterBgpPeer {
  /**
   * User-specified list of prefix groups to advertise in custom mode, which
   * currently supports the following option: - ALL_SUBNETS: Advertises all of
   * the router's own VPC subnets. This excludes any routes learned for subnets
   * that use VPC Network Peering. Note that this field can only be populated if
   * advertise_mode is CUSTOM and overrides the list defined for the router (in
   * the "bgp" message). These groups are advertised in addition to any
   * specified prefixes. Leave this field blank to advertise no custom groups.
   */
  advertisedGroups?:  | "ALL_SUBNETS"[];
  /**
   * User-specified list of individual IP ranges to advertise in custom mode.
   * This field can only be populated if advertise_mode is CUSTOM and overrides
   * the list defined for the router (in the "bgp" message). These IP ranges are
   * advertised in addition to any specified groups. Leave this field blank to
   * advertise no custom IP ranges.
   */
  advertisedIpRanges?: RouterAdvertisedIpRange[];
  /**
   * The priority of routes advertised to this BGP peer. Where there is more
   * than one matching route of maximum length, the routes with the lowest
   * priority value win.
   */
  advertisedRoutePriority?: number;
  /**
   * User-specified flag to indicate which mode to use for advertisement.
   */
  advertiseMode?:  | "CUSTOM" | "DEFAULT";
  /**
   * BFD configuration for the BGP peering.
   */
  bfd?: RouterBgpPeerBfd;
  /**
   * The status of the BGP peer connection. If set to FALSE, any active session
   * with the peer is terminated and all associated routing information is
   * removed. If set to TRUE, the peer connection can be established with
   * routing information. The default is TRUE.
   */
  enable?:  | "FALSE" | "TRUE";
  /**
   * Enable IPv6 traffic over BGP Peer. If not specified, it is disabled by
   * default.
   */
  enableIpv6?: boolean;
  /**
   * Name of the interface the BGP peer is associated with.
   */
  interfaceName?: string;
  /**
   * IP address of the interface inside Google Cloud Platform. Only IPv4 is
   * supported.
   */
  ipAddress?: string;
  /**
   * IPv6 address of the interface inside Google Cloud Platform.
   */
  ipv6NexthopAddress?: string;
  /**
   * [Output Only] The resource that configures and manages this BGP peer. -
   * MANAGED_BY_USER is the default value and can be managed by you or other
   * users - MANAGED_BY_ATTACHMENT is a BGP peer that is configured and managed
   * by Cloud Interconnect, specifically by an InterconnectAttachment of type
   * PARTNER. Google automatically creates, updates, and deletes this type of
   * BGP peer when the PARTNER InterconnectAttachment is created, updated, or
   * deleted.
   */
  managementType?:  | "MANAGED_BY_ATTACHMENT" | "MANAGED_BY_USER";
  /**
   * Present if MD5 authentication is enabled for the peering. Must be the name
   * of one of the entries in the Router.md5_authentication_keys. The field must
   * comply with RFC1035.
   */
  md5AuthenticationKeyName?: string;
  /**
   * Name of this BGP peer. The name must be 1-63 characters long, and comply
   * with RFC1035. Specifically, the name must be 1-63 characters long and match
   * the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first
   * character must be a lowercase letter, and all following characters must be
   * a dash, lowercase letter, or digit, except the last character, which cannot
   * be a dash.
   */
  name?: string;
  /**
   * Peer BGP Autonomous System Number (ASN). Each BGP interface may use a
   * different value.
   */
  peerAsn?: number;
  /**
   * IP address of the BGP interface outside Google Cloud Platform. Only IPv4
   * is supported.
   */
  peerIpAddress?: string;
  /**
   * IPv6 address of the BGP interface outside Google Cloud Platform.
   */
  peerIpv6NexthopAddress?: string;
  /**
   * URI of the VM instance that is used as third-party router appliances such
   * as Next Gen Firewalls, Virtual Routers, or Router Appliances. The VM
   * instance must be located in zones contained in the same region as this
   * Cloud Router. The VM instance is the peer side of the BGP session.
   */
  routerApplianceInstance?: string;
}

export interface RouterBgpPeerBfd {
  /**
   * The minimum interval, in milliseconds, between BFD control packets
   * received from the peer router. The actual value is negotiated between the
   * two routers and is equal to the greater of this value and the transmit
   * interval of the other router. If set, this value must be between 1000 and
   * 30000. The default is 1000.
   */
  minReceiveInterval?: number;
  /**
   * The minimum interval, in milliseconds, between BFD control packets
   * transmitted to the peer router. The actual value is negotiated between the
   * two routers and is equal to the greater of this value and the corresponding
   * receive interval of the other router. If set, this value must be between
   * 1000 and 30000. The default is 1000.
   */
  minTransmitInterval?: number;
  /**
   * The number of consecutive BFD packets that must be missed before BFD
   * declares that a peer is unavailable. If set, the value must be a value
   * between 5 and 16. The default is 5.
   */
  multiplier?: number;
  /**
   * The BFD session initialization mode for this BGP peer. If set to ACTIVE,
   * the Cloud Router will initiate the BFD session for this BGP peer. If set to
   * PASSIVE, the Cloud Router will wait for the peer router to initiate the BFD
   * session for this BGP peer. If set to DISABLED, BFD is disabled for this BGP
   * peer. The default is DISABLED.
   */
  sessionInitializationMode?:  | "ACTIVE" | "DISABLED" | "PASSIVE";
}

export interface RouterInterface {
  /**
   * IP address and range of the interface. The IP range must be in the RFC3927
   * link-local IP address space. The value must be a CIDR-formatted string, for
   * example: 169.254.0.1/30. NOTE: Do not truncate the address as it represents
   * the IP address of the interface.
   */
  ipRange?: string;
  /**
   * URI of the linked Interconnect attachment. It must be in the same region
   * as the router. Each interface can have one linked resource, which can be a
   * VPN tunnel, an Interconnect attachment, or a virtual machine instance.
   */
  linkedInterconnectAttachment?: string;
  /**
   * URI of the linked VPN tunnel, which must be in the same region as the
   * router. Each interface can have one linked resource, which can be a VPN
   * tunnel, an Interconnect attachment, or a virtual machine instance.
   */
  linkedVpnTunnel?: string;
  /**
   * [Output Only] The resource that configures and manages this interface. -
   * MANAGED_BY_USER is the default value and can be managed directly by users.
   * - MANAGED_BY_ATTACHMENT is an interface that is configured and managed by
   * Cloud Interconnect, specifically, by an InterconnectAttachment of type
   * PARTNER. Google automatically creates, updates, and deletes this type of
   * interface when the PARTNER InterconnectAttachment is created, updated, or
   * deleted.
   */
  managementType?:  | "MANAGED_BY_ATTACHMENT" | "MANAGED_BY_USER";
  /**
   * Name of this interface entry. The name must be 1-63 characters long, and
   * comply with RFC1035. Specifically, the name must be 1-63 characters long
   * and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
   * the first character must be a lowercase letter, and all following
   * characters must be a dash, lowercase letter, or digit, except the last
   * character, which cannot be a dash.
   */
  name?: string;
  /**
   * The regional private internal IP address that is used to establish BGP
   * sessions to a VM instance acting as a third-party Router Appliance, such as
   * a Next Gen Firewall, a Virtual Router, or an SD-WAN VM.
   */
  privateIpAddress?: string;
  /**
   * Name of the interface that will be redundant with the current interface
   * you are creating. The redundantInterface must belong to the same Cloud
   * Router as the interface here. To establish the BGP session to a Router
   * Appliance VM, you must create two BGP peers. The two BGP peers must be
   * attached to two separate interfaces that are redundant with each other. The
   * redundant_interface must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the redundant_interface must be 1-63 characters long and
   * match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the
   * first character must be a lowercase letter, and all following characters
   * must be a dash, lowercase letter, or digit, except the last character,
   * which cannot be a dash.
   */
  redundantInterface?: string;
  /**
   * The URI of the subnetwork resource that this interface belongs to, which
   * must be in the same region as the Cloud Router. When you establish a BGP
   * session to a VM instance using this interface, the VM instance must belong
   * to the same subnetwork as the subnetwork specified here.
   */
  subnetwork?: string;
}

/**
 * Contains a list of Router resources.
 */
export interface RouterList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of Router resources.
   */
  items?: Router[];
  /**
   * [Output Only] Type of resource. Always compute#router for routers.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeRouterList(data: any): RouterList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeRouter(item))) : undefined,
  };
}

function deserializeRouterList(data: any): RouterList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeRouter(item))) : undefined,
  };
}

export interface RouterMd5AuthenticationKey {
  /**
   * [Input only] Value of the key. For patch and update calls, it can be
   * skipped to copy the value from the previous configuration. This is allowed
   * if the key with the same name existed before the operation. Maximum length
   * is 80 characters. Can only contain printable ASCII characters.
   */
  key?: string;
  /**
   * Name used to identify the key. Must be unique within a router. Must be
   * referenced by at least one bgpPeer. Must comply with RFC1035.
   */
  name?: string;
}

/**
 * Represents a Nat resource. It enables the VMs within the specified
 * subnetworks to access Internet without external IP addresses. It specifies a
 * list of subnetworks (and the ranges within) that want to use NAT. Customers
 * can also provide the external IPs that would be used for NAT. GCP would
 * auto-allocate ephemeral IPs if no external IPs are provided.
 */
export interface RouterNat {
  /**
   * A list of URLs of the IP resources to be drained. These IPs must be valid
   * static external IPs that have been assigned to the NAT. These IPs should be
   * used for updating/patching a NAT only.
   */
  drainNatIps?: string[];
  /**
   * Enable Dynamic Port Allocation. If not specified, it is disabled by
   * default. If set to true, - Dynamic Port Allocation will be enabled on this
   * NAT config. - enableEndpointIndependentMapping cannot be set to true. - If
   * minPorts is set, minPortsPerVm must be set to a power of two greater than
   * or equal to 32. If minPortsPerVm is not set, a minimum of 32 ports will be
   * allocated to a VM from this NAT config.
   */
  enableDynamicPortAllocation?: boolean;
  enableEndpointIndependentMapping?: boolean;
  /**
   * List of NAT-ted endpoint types supported by the Nat Gateway. If the list
   * is empty, then it will be equivalent to include ENDPOINT_TYPE_VM
   */
  endpointTypes?:  | "ENDPOINT_TYPE_SWG" | "ENDPOINT_TYPE_VM"[];
  /**
   * Timeout (in seconds) for ICMP connections. Defaults to 30s if not set.
   */
  icmpIdleTimeoutSec?: number;
  /**
   * Configure logging on this NAT.
   */
  logConfig?: RouterNatLogConfig;
  /**
   * Maximum number of ports allocated to a VM from this NAT config when
   * Dynamic Port Allocation is enabled. If Dynamic Port Allocation is not
   * enabled, this field has no effect. If Dynamic Port Allocation is enabled,
   * and this field is set, it must be set to a power of two greater than
   * minPortsPerVm, or 64 if minPortsPerVm is not set. If Dynamic Port
   * Allocation is enabled and this field is not set, a maximum of 65536 ports
   * will be allocated to a VM from this NAT config.
   */
  maxPortsPerVm?: number;
  /**
   * Minimum number of ports allocated to a VM from this NAT config. If not
   * set, a default number of ports is allocated to a VM. This is rounded up to
   * the nearest power of 2. For example, if the value of this field is 50, at
   * least 64 ports are allocated to a VM.
   */
  minPortsPerVm?: number;
  /**
   * Unique name of this Nat service. The name must be 1-63 characters long and
   * comply with RFC1035.
   */
  name?: string;
  /**
   * Specify the NatIpAllocateOption, which can take one of the following
   * values: - MANUAL_ONLY: Uses only Nat IP addresses provided by customers.
   * When there are not enough specified Nat IPs, the Nat service fails for new
   * VMs. - AUTO_ONLY: Nat IPs are allocated by Google Cloud Platform; customers
   * can't specify any Nat IPs. When choosing AUTO_ONLY, then nat_ip should be
   * empty.
   */
  natIpAllocateOption?:  | "AUTO_ONLY" | "MANUAL_ONLY";
  /**
   * A list of URLs of the IP resources used for this Nat service. These IP
   * addresses must be valid static external IP addresses assigned to the
   * project.
   */
  natIps?: string[];
  /**
   * A list of rules associated with this NAT.
   */
  rules?: RouterNatRule[];
  /**
   * Specify the Nat option, which can take one of the following values: -
   * ALL_SUBNETWORKS_ALL_IP_RANGES: All of the IP ranges in every Subnetwork are
   * allowed to Nat. - ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES: All of the primary
   * IP ranges in every Subnetwork are allowed to Nat. - LIST_OF_SUBNETWORKS: A
   * list of Subnetworks are allowed to Nat (specified in the field subnetwork
   * below) The default is SUBNETWORK_IP_RANGE_TO_NAT_OPTION_UNSPECIFIED. Note
   * that if this field contains ALL_SUBNETWORKS_ALL_IP_RANGES or
   * ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES, then there should not be any other
   * Router.Nat section in any Router for this network in this region.
   */
  sourceSubnetworkIpRangesToNat?:  | "ALL_SUBNETWORKS_ALL_IP_RANGES" | "ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES" | "LIST_OF_SUBNETWORKS";
  /**
   * A list of Subnetwork resources whose traffic should be translated by NAT
   * Gateway. It is used only when LIST_OF_SUBNETWORKS is selected for the
   * SubnetworkIpRangeToNatOption above.
   */
  subnetworks?: RouterNatSubnetworkToNat[];
  /**
   * Timeout (in seconds) for TCP established connections. Defaults to 1200s if
   * not set.
   */
  tcpEstablishedIdleTimeoutSec?: number;
  /**
   * Timeout (in seconds) for TCP connections that are in TIME_WAIT state.
   * Defaults to 120s if not set.
   */
  tcpTimeWaitTimeoutSec?: number;
  /**
   * Timeout (in seconds) for TCP transitory connections. Defaults to 30s if
   * not set.
   */
  tcpTransitoryIdleTimeoutSec?: number;
  /**
   * Timeout (in seconds) for UDP connections. Defaults to 30s if not set.
   */
  udpIdleTimeoutSec?: number;
}

/**
 * Configuration of logging on a NAT.
 */
export interface RouterNatLogConfig {
  /**
   * Indicates whether or not to export logs. This is false by default.
   */
  enable?: boolean;
  /**
   * Specify the desired filtering of logs on this NAT. If unspecified, logs
   * are exported for all connections handled by this NAT. This option can take
   * one of the following values: - ERRORS_ONLY: Export logs only for connection
   * failures. - TRANSLATIONS_ONLY: Export logs only for successful connections.
   * - ALL: Export logs for all connections, successful and unsuccessful.
   */
  filter?:  | "ALL" | "ERRORS_ONLY" | "TRANSLATIONS_ONLY";
}

export interface RouterNatRule {
  /**
   * The action to be enforced for traffic that matches this rule.
   */
  action?: RouterNatRuleAction;
  /**
   * An optional description of this rule.
   */
  description?: string;
  /**
   * CEL expression that specifies the match condition that egress traffic from
   * a VM is evaluated against. If it evaluates to true, the corresponding
   * `action` is enforced. The following examples are valid match expressions
   * for public NAT: "inIpRange(destination.ip, '1.1.0.0/16') ||
   * inIpRange(destination.ip, '2.2.0.0/16')" "destination.ip == '1.1.0.1' ||
   * destination.ip == '8.8.8.8'" The following example is a valid match
   * expression for private NAT: "nexthop.hub ==
   * 'https://networkconnectivity.googleapis.com/v1alpha1/projects/my-project/global/hub/hub-1'"
   */
  match?: string;
  /**
   * An integer uniquely identifying a rule in the list. The rule number must
   * be a positive value between 0 and 65000, and must be unique among rules
   * within a NAT.
   */
  ruleNumber?: number;
}

export interface RouterNatRuleAction {
  /**
   * A list of URLs of the IP resources used for this NAT rule. These IP
   * addresses must be valid static external IP addresses assigned to the
   * project. This field is used for public NAT.
   */
  sourceNatActiveIps?: string[];
  /**
   * A list of URLs of the IP resources to be drained. These IPs must be valid
   * static external IPs that have been assigned to the NAT. These IPs should be
   * used for updating/patching a NAT rule only. This field is used for public
   * NAT.
   */
  sourceNatDrainIps?: string[];
}

/**
 * Defines the IP ranges that want to use NAT for a subnetwork.
 */
export interface RouterNatSubnetworkToNat {
  /**
   * URL for the subnetwork resource that will use NAT.
   */
  name?: string;
  /**
   * A list of the secondary ranges of the Subnetwork that are allowed to use
   * NAT. This can be populated only if "LIST_OF_SECONDARY_IP_RANGES" is one of
   * the values in source_ip_ranges_to_nat.
   */
  secondaryIpRangeNames?: string[];
  /**
   * Specify the options for NAT ranges in the Subnetwork. All options of a
   * single value are valid except NAT_IP_RANGE_OPTION_UNSPECIFIED. The only
   * valid option with multiple values is: ["PRIMARY_IP_RANGE",
   * "LIST_OF_SECONDARY_IP_RANGES"] Default: [ALL_IP_RANGES]
   */
  sourceIpRangesToNat?:  | "ALL_IP_RANGES" | "LIST_OF_SECONDARY_IP_RANGES" | "PRIMARY_IP_RANGE"[];
}

/**
 * Additional options for Compute#routersAggregatedList.
 */
export interface RoutersAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#routersDelete.
 */
export interface RoutersDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#routersGetNatMappingInfo.
 */
export interface RoutersGetNatMappingInfoOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#routersInsert.
 */
export interface RoutersInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#routersList.
 */
export interface RoutersListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#routersPatch.
 */
export interface RoutersPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface RoutersPreviewResponse {
  /**
   * Preview of given router.
   */
  resource?: Router;
}

function serializeRoutersPreviewResponse(data: any): RoutersPreviewResponse {
  return {
    ...data,
    resource: data["resource"] !== undefined ? serializeRouter(data["resource"]) : undefined,
  };
}

function deserializeRoutersPreviewResponse(data: any): RoutersPreviewResponse {
  return {
    ...data,
    resource: data["resource"] !== undefined ? deserializeRouter(data["resource"]) : undefined,
  };
}

export interface RoutersScopedList {
  /**
   * A list of routers contained in this scope.
   */
  routers?: Router[];
  /**
   * Informational warning which replaces the list of routers when the list is
   * empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeRoutersScopedList(data: any): RoutersScopedList {
  return {
    ...data,
    routers: data["routers"] !== undefined ? data["routers"].map((item: any) => (serializeRouter(item))) : undefined,
  };
}

function deserializeRoutersScopedList(data: any): RoutersScopedList {
  return {
    ...data,
    routers: data["routers"] !== undefined ? data["routers"].map((item: any) => (deserializeRouter(item))) : undefined,
  };
}

export interface RouterStatus {
  /**
   * Best routes for this router's network.
   */
  bestRoutes?: Route[];
  /**
   * Best routes learned by this router.
   */
  bestRoutesForRouter?: Route[];
  bgpPeerStatus?: RouterStatusBgpPeerStatus[];
  natStatus?: RouterStatusNatStatus[];
  /**
   * URI of the network to which this router belongs.
   */
  network?: string;
}

function serializeRouterStatus(data: any): RouterStatus {
  return {
    ...data,
    bestRoutes: data["bestRoutes"] !== undefined ? data["bestRoutes"].map((item: any) => (serializeRoute(item))) : undefined,
    bestRoutesForRouter: data["bestRoutesForRouter"] !== undefined ? data["bestRoutesForRouter"].map((item: any) => (serializeRoute(item))) : undefined,
    bgpPeerStatus: data["bgpPeerStatus"] !== undefined ? data["bgpPeerStatus"].map((item: any) => (serializeRouterStatusBgpPeerStatus(item))) : undefined,
  };
}

function deserializeRouterStatus(data: any): RouterStatus {
  return {
    ...data,
    bestRoutes: data["bestRoutes"] !== undefined ? data["bestRoutes"].map((item: any) => (deserializeRoute(item))) : undefined,
    bestRoutesForRouter: data["bestRoutesForRouter"] !== undefined ? data["bestRoutesForRouter"].map((item: any) => (deserializeRoute(item))) : undefined,
    bgpPeerStatus: data["bgpPeerStatus"] !== undefined ? data["bgpPeerStatus"].map((item: any) => (deserializeRouterStatusBgpPeerStatus(item))) : undefined,
  };
}

export interface RouterStatusBgpPeerStatus {
  /**
   * Routes that were advertised to the remote BGP peer
   */
  advertisedRoutes?: Route[];
  bfdStatus?: BfdStatus;
  /**
   * Enable IPv6 traffic over BGP Peer. If not specified, it is disabled by
   * default.
   */
  enableIpv6?: boolean;
  /**
   * IP address of the local BGP interface.
   */
  ipAddress?: string;
  /**
   * IPv6 address of the local BGP interface.
   */
  ipv6NexthopAddress?: string;
  /**
   * URL of the VPN tunnel that this BGP peer controls.
   */
  linkedVpnTunnel?: string;
  /**
   * Informs whether MD5 authentication is enabled on this BGP peer.
   */
  md5AuthEnabled?: boolean;
  /**
   * Name of this BGP peer. Unique within the Routers resource.
   */
  name?: string;
  /**
   * Number of routes learned from the remote BGP Peer.
   */
  numLearnedRoutes?: number;
  /**
   * IP address of the remote BGP interface.
   */
  peerIpAddress?: string;
  /**
   * IPv6 address of the remote BGP interface.
   */
  peerIpv6NexthopAddress?: string;
  /**
   * [Output only] URI of the VM instance that is used as third-party router
   * appliances such as Next Gen Firewalls, Virtual Routers, or Router
   * Appliances. The VM instance is the peer side of the BGP session.
   */
  routerApplianceInstance?: string;
  /**
   * The state of the BGP session. For a list of possible values for this
   * field, see BGP session states.
   */
  state?: string;
  /**
   * Status of the BGP peer: {UP, DOWN}
   */
  status?:  | "DOWN" | "UNKNOWN" | "UP";
  /**
   * Indicates why particular status was returned.
   */
  statusReason?:  | "MD5_AUTH_INTERNAL_PROBLEM" | "STATUS_REASON_UNSPECIFIED";
  /**
   * Time this session has been up. Format: 14 years, 51 weeks, 6 days, 23
   * hours, 59 minutes, 59 seconds
   */
  uptime?: string;
  /**
   * Time this session has been up, in seconds. Format: 145
   */
  uptimeSeconds?: string;
}

function serializeRouterStatusBgpPeerStatus(data: any): RouterStatusBgpPeerStatus {
  return {
    ...data,
    advertisedRoutes: data["advertisedRoutes"] !== undefined ? data["advertisedRoutes"].map((item: any) => (serializeRoute(item))) : undefined,
    bfdStatus: data["bfdStatus"] !== undefined ? serializeBfdStatus(data["bfdStatus"]) : undefined,
  };
}

function deserializeRouterStatusBgpPeerStatus(data: any): RouterStatusBgpPeerStatus {
  return {
    ...data,
    advertisedRoutes: data["advertisedRoutes"] !== undefined ? data["advertisedRoutes"].map((item: any) => (deserializeRoute(item))) : undefined,
    bfdStatus: data["bfdStatus"] !== undefined ? deserializeBfdStatus(data["bfdStatus"]) : undefined,
  };
}

/**
 * Status of a NAT contained in this router.
 */
export interface RouterStatusNatStatus {
  /**
   * A list of IPs auto-allocated for NAT. Example: ["1.1.1.1", "129.2.16.89"]
   */
  autoAllocatedNatIps?: string[];
  /**
   * A list of IPs auto-allocated for NAT that are in drain mode. Example:
   * ["1.1.1.1", "179.12.26.133"].
   */
  drainAutoAllocatedNatIps?: string[];
  /**
   * A list of IPs user-allocated for NAT that are in drain mode. Example:
   * ["1.1.1.1", "179.12.26.133"].
   */
  drainUserAllocatedNatIps?: string[];
  /**
   * The number of extra IPs to allocate. This will be greater than 0 only if
   * user-specified IPs are NOT enough to allow all configured VMs to use NAT.
   * This value is meaningful only when auto-allocation of NAT IPs is *not*
   * used.
   */
  minExtraNatIpsNeeded?: number;
  /**
   * Unique name of this NAT.
   */
  name?: string;
  /**
   * Number of VM endpoints (i.e., Nics) that can use NAT.
   */
  numVmEndpointsWithNatMappings?: number;
  /**
   * Status of rules in this NAT.
   */
  ruleStatus?: RouterStatusNatStatusNatRuleStatus[];
  /**
   * A list of fully qualified URLs of reserved IP address resources.
   */
  userAllocatedNatIpResources?: string[];
  /**
   * A list of IPs user-allocated for NAT. They will be raw IP strings like
   * "179.12.26.133".
   */
  userAllocatedNatIps?: string[];
}

/**
 * Status of a NAT Rule contained in this NAT.
 */
export interface RouterStatusNatStatusNatRuleStatus {
  /**
   * A list of active IPs for NAT. Example: ["1.1.1.1", "179.12.26.133"].
   */
  activeNatIps?: string[];
  /**
   * A list of IPs for NAT that are in drain mode. Example: ["1.1.1.1",
   * "179.12.26.133"].
   */
  drainNatIps?: string[];
  /**
   * The number of extra IPs to allocate. This will be greater than 0 only if
   * the existing IPs in this NAT Rule are NOT enough to allow all configured
   * VMs to use NAT.
   */
  minExtraIpsNeeded?: number;
  /**
   * Number of VM endpoints (i.e., NICs) that have NAT Mappings from this NAT
   * Rule.
   */
  numVmEndpointsWithNatMappings?: number;
  /**
   * Rule number of the rule.
   */
  ruleNumber?: number;
}

export interface RouterStatusResponse {
  /**
   * Type of resource.
   */
  kind?: string;
  result?: RouterStatus;
}

function serializeRouterStatusResponse(data: any): RouterStatusResponse {
  return {
    ...data,
    result: data["result"] !== undefined ? serializeRouterStatus(data["result"]) : undefined,
  };
}

function deserializeRouterStatusResponse(data: any): RouterStatusResponse {
  return {
    ...data,
    result: data["result"] !== undefined ? deserializeRouterStatus(data["result"]) : undefined,
  };
}

/**
 * Additional options for Compute#routersUpdate.
 */
export interface RoutersUpdateOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#routesDelete.
 */
export interface RoutesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#routesInsert.
 */
export interface RoutesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#routesList.
 */
export interface RoutesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * This is deprecated and has no effect. Do not use.
 */
export interface Rule {
  /**
   * This is deprecated and has no effect. Do not use.
   */
  action?:  | "ALLOW" | "ALLOW_WITH_LOG" | "DENY" | "DENY_WITH_LOG" | "LOG" | "NO_ACTION";
  /**
   * This is deprecated and has no effect. Do not use.
   */
  conditions?: Condition[];
  /**
   * This is deprecated and has no effect. Do not use.
   */
  description?: string;
  /**
   * This is deprecated and has no effect. Do not use.
   */
  ins?: string[];
  /**
   * This is deprecated and has no effect. Do not use.
   */
  logConfigs?: LogConfig[];
  /**
   * This is deprecated and has no effect. Do not use.
   */
  notIns?: string[];
  /**
   * This is deprecated and has no effect. Do not use.
   */
  permissions?: string[];
}

/**
 * DEPRECATED: Please use compute#savedDisk instead. An instance-attached disk
 * resource.
 */
export interface SavedAttachedDisk {
  /**
   * Specifies whether the disk will be auto-deleted when the instance is
   * deleted (but not when the disk is detached from the instance).
   */
  autoDelete?: boolean;
  /**
   * Indicates that this is a boot disk. The virtual machine will use the first
   * partition of the disk for its root filesystem.
   */
  boot?: boolean;
  /**
   * Specifies the name of the disk attached to the source instance.
   */
  deviceName?: string;
  /**
   * The encryption key for the disk.
   */
  diskEncryptionKey?: CustomerEncryptionKey;
  /**
   * The size of the disk in base-2 GB.
   */
  diskSizeGb?: bigint;
  /**
   * [Output Only] URL of the disk type resource. For example: projects/project
   * /zones/zone/diskTypes/pd-standard or pd-ssd
   */
  diskType?: string;
  /**
   * A list of features to enable on the guest operating system. Applicable
   * only for bootable images. Read Enabling guest operating system features to
   * see a list of available options.
   */
  guestOsFeatures?: GuestOsFeature[];
  /**
   * Specifies zero-based index of the disk that is attached to the source
   * instance.
   */
  index?: number;
  /**
   * Specifies the disk interface to use for attaching this disk, which is
   * either SCSI or NVME.
   */
  interface?:  | "NVME" | "SCSI";
  /**
   * [Output Only] Type of the resource. Always compute#attachedDisk for
   * attached disks.
   */
  kind?: string;
  /**
   * [Output Only] Any valid publicly visible licenses.
   */
  licenses?: string[];
  /**
   * The mode in which this disk is attached to the source instance, either
   * READ_WRITE or READ_ONLY.
   */
  mode?:  | "READ_ONLY" | "READ_WRITE";
  /**
   * Specifies a URL of the disk attached to the source instance.
   */
  source?: string;
  /**
   * [Output Only] A size of the storage used by the disk's snapshot by this
   * machine image.
   */
  storageBytes?: bigint;
  /**
   * [Output Only] An indicator whether storageBytes is in a stable state or it
   * is being adjusted as a result of shared storage reallocation. This status
   * can either be UPDATING, meaning the size of the snapshot is being updated,
   * or UP_TO_DATE, meaning the size of the snapshot is up-to-date.
   */
  storageBytesStatus?:  | "UPDATING" | "UP_TO_DATE";
  /**
   * Specifies the type of the attached disk, either SCRATCH or PERSISTENT.
   */
  type?:  | "PERSISTENT" | "SCRATCH";
}

function serializeSavedAttachedDisk(data: any): SavedAttachedDisk {
  return {
    ...data,
    diskSizeGb: data["diskSizeGb"] !== undefined ? String(data["diskSizeGb"]) : undefined,
    storageBytes: data["storageBytes"] !== undefined ? String(data["storageBytes"]) : undefined,
  };
}

function deserializeSavedAttachedDisk(data: any): SavedAttachedDisk {
  return {
    ...data,
    diskSizeGb: data["diskSizeGb"] !== undefined ? BigInt(data["diskSizeGb"]) : undefined,
    storageBytes: data["storageBytes"] !== undefined ? BigInt(data["storageBytes"]) : undefined,
  };
}

/**
 * An instance-attached disk resource.
 */
export interface SavedDisk {
  /**
   * [Output Only] The architecture of the attached disk.
   */
  architecture?:  | "ARCHITECTURE_UNSPECIFIED" | "ARM64" | "X86_64";
  /**
   * [Output Only] Type of the resource. Always compute#savedDisk for attached
   * disks.
   */
  kind?: string;
  /**
   * Specifies a URL of the disk attached to the source instance.
   */
  sourceDisk?: string;
  /**
   * [Output Only] Size of the individual disk snapshot used by this machine
   * image.
   */
  storageBytes?: bigint;
  /**
   * [Output Only] An indicator whether storageBytes is in a stable state or it
   * is being adjusted as a result of shared storage reallocation. This status
   * can either be UPDATING, meaning the size of the snapshot is being updated,
   * or UP_TO_DATE, meaning the size of the snapshot is up-to-date.
   */
  storageBytesStatus?:  | "UPDATING" | "UP_TO_DATE";
}

function serializeSavedDisk(data: any): SavedDisk {
  return {
    ...data,
    storageBytes: data["storageBytes"] !== undefined ? String(data["storageBytes"]) : undefined,
  };
}

function deserializeSavedDisk(data: any): SavedDisk {
  return {
    ...data,
    storageBytes: data["storageBytes"] !== undefined ? BigInt(data["storageBytes"]) : undefined,
  };
}

export interface ScalingScheduleStatus {
  /**
   * [Output Only] The last time the scaling schedule became active. Note: this
   * is a timestamp when a schedule actually became active, not when it was
   * planned to do so. The timestamp is in RFC3339 text format.
   */
  lastStartTime?: string;
  /**
   * [Output Only] The next time the scaling schedule is to become active.
   * Note: this is a timestamp when a schedule is planned to run, but the actual
   * time might be slightly different. The timestamp is in RFC3339 text format.
   */
  nextStartTime?: string;
  /**
   * [Output Only] The current state of a scaling schedule.
   */
  state?:  | "ACTIVE" | "DISABLED" | "OBSOLETE" | "READY";
}

/**
 * Sets the scheduling options for an Instance.
 */
export interface Scheduling {
  /**
   * Specifies whether the instance should be automatically restarted if it is
   * terminated by Compute Engine (not terminated by a user). You can only set
   * the automatic restart option for standard instances. Preemptible instances
   * cannot be automatically restarted. By default, this is set to true so an
   * instance is automatically restarted if it is terminated by Compute Engine.
   */
  automaticRestart?: boolean;
  /**
   * Specifies the termination action for the instance.
   */
  instanceTerminationAction?:  | "DELETE" | "INSTANCE_TERMINATION_ACTION_UNSPECIFIED" | "STOP";
  /**
   * An opaque location hint used to place the instance close to other
   * resources. This field is for use by internal tools that use the public API.
   */
  locationHint?: string;
  /**
   * The minimum number of virtual CPUs this instance will consume when running
   * on a sole-tenant node.
   */
  minNodeCpus?: number;
  /**
   * A set of node affinity and anti-affinity configurations. Refer to
   * Configuring node affinity for more information. Overrides
   * reservationAffinity.
   */
  nodeAffinities?: SchedulingNodeAffinity[];
  /**
   * Defines the maintenance behavior for this instance. For standard
   * instances, the default behavior is MIGRATE. For preemptible instances, the
   * default and only possible behavior is TERMINATE. For more information, see
   * Set VM host maintenance policy.
   */
  onHostMaintenance?:  | "MIGRATE" | "TERMINATE";
  /**
   * Defines whether the instance is preemptible. This can only be set during
   * instance creation or while the instance is stopped and therefore, in a
   * `TERMINATED` state. See Instance Life Cycle for more information on the
   * possible instance states.
   */
  preemptible?: boolean;
  /**
   * Specifies the provisioning model of the instance.
   */
  provisioningModel?:  | "SPOT" | "STANDARD";
}

/**
 * Node Affinity: the configuration of desired nodes onto which this Instance
 * could be scheduled.
 */
export interface SchedulingNodeAffinity {
  /**
   * Corresponds to the label key of Node resource.
   */
  key?: string;
  /**
   * Defines the operation of node selection. Valid operators are IN for
   * affinity and NOT_IN for anti-affinity.
   */
  operator?:  | "IN" | "NOT_IN" | "OPERATOR_UNSPECIFIED";
  /**
   * Corresponds to the label values of Node resource.
   */
  values?: string[];
}

/**
 * An instance's screenshot.
 */
export interface Screenshot {
  /**
   * [Output Only] The Base64-encoded screenshot data.
   */
  contents?: string;
  /**
   * [Output Only] Type of the resource. Always compute#screenshot for the
   * screenshots.
   */
  kind?: string;
}

/**
 * Additional options for Compute#securityPoliciesAddRule.
 */
export interface SecurityPoliciesAddRuleOptions {
  /**
   * If true, the request will not be committed.
   */
  validateOnly?: boolean;
}

export interface SecurityPoliciesAggregatedList {
  etag?: string;
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of SecurityPoliciesScopedList resources.
   */
  items?: {
    [key: string]: SecurityPoliciesScopedList
  };
  /**
   * [Output Only] Type of resource. Always
   * compute#securityPolicyAggregatedList for lists of Security Policies.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeSecurityPoliciesAggregatedList(data: any): SecurityPoliciesAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeSecurityPoliciesScopedList(v)]))) : undefined,
  };
}

function deserializeSecurityPoliciesAggregatedList(data: any): SecurityPoliciesAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeSecurityPoliciesScopedList(v)]))) : undefined,
  };
}

/**
 * Additional options for Compute#securityPoliciesAggregatedList.
 */
export interface SecurityPoliciesAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#securityPoliciesDelete.
 */
export interface SecurityPoliciesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#securityPoliciesGetRule.
 */
export interface SecurityPoliciesGetRuleOptions {
  /**
   * The priority of the rule to get from the security policy.
   */
  priority?: number;
}

/**
 * Additional options for Compute#securityPoliciesInsert.
 */
export interface SecurityPoliciesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
  /**
   * If true, the request will not be committed.
   */
  validateOnly?: boolean;
}

/**
 * Additional options for Compute#securityPoliciesList.
 */
export interface SecurityPoliciesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for
 * Compute#securityPoliciesListPreconfiguredExpressionSets.
 */
export interface SecurityPoliciesListPreconfiguredExpressionSetsOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface SecurityPoliciesListPreconfiguredExpressionSetsResponse {
  preconfiguredExpressionSets?: SecurityPoliciesWafConfig;
}

/**
 * Additional options for Compute#securityPoliciesPatch.
 */
export interface SecurityPoliciesPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#securityPoliciesPatchRule.
 */
export interface SecurityPoliciesPatchRuleOptions {
  /**
   * The priority of the rule to patch.
   */
  priority?: number;
  /**
   * If true, the request will not be committed.
   */
  validateOnly?: boolean;
}

/**
 * Additional options for Compute#securityPoliciesRemoveRule.
 */
export interface SecurityPoliciesRemoveRuleOptions {
  /**
   * The priority of the rule to remove from the security policy.
   */
  priority?: number;
}

export interface SecurityPoliciesScopedList {
  /**
   * A list of SecurityPolicies contained in this scope.
   */
  securityPolicies?: SecurityPolicy[];
  /**
   * Informational warning which replaces the list of security policies when
   * the list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeSecurityPoliciesScopedList(data: any): SecurityPoliciesScopedList {
  return {
    ...data,
    securityPolicies: data["securityPolicies"] !== undefined ? data["securityPolicies"].map((item: any) => (serializeSecurityPolicy(item))) : undefined,
  };
}

function deserializeSecurityPoliciesScopedList(data: any): SecurityPoliciesScopedList {
  return {
    ...data,
    securityPolicies: data["securityPolicies"] !== undefined ? data["securityPolicies"].map((item: any) => (deserializeSecurityPolicy(item))) : undefined,
  };
}

export interface SecurityPoliciesWafConfig {
  wafRules?: PreconfiguredWafSet;
}

/**
 * Represents a Google Cloud Armor security policy resource. Only external
 * backend services that use load balancers can reference a security policy. For
 * more information, see Google Cloud Armor security policy overview.
 */
export interface SecurityPolicy {
  adaptiveProtectionConfig?: SecurityPolicyAdaptiveProtectionConfig;
  advancedOptionsConfig?: SecurityPolicyAdvancedOptionsConfig;
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  ddosProtectionConfig?: SecurityPolicyDdosProtectionConfig;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * Specifies a fingerprint for this resource, which is essentially a hash of
   * the metadata's contents and used for optimistic locking. The fingerprint is
   * initially generated by Compute Engine and changes after every request to
   * modify or update metadata. You must always provide an up-to-date
   * fingerprint hash in order to update or change metadata, otherwise the
   * request will fail with error 412 conditionNotMet. To see the latest
   * fingerprint, make get() request to the security policy.
   */
  fingerprint?: Uint8Array;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output only] Type of the resource. Always compute#securityPolicyfor
   * security policies
   */
  kind?: string;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  recaptchaOptionsConfig?: SecurityPolicyRecaptchaOptionsConfig;
  /**
   * [Output Only] URL of the region where the regional security policy
   * resides. This field is not applicable to global security policies.
   */
  region?: string;
  /**
   * A list of rules that belong to this policy. There must always be a default
   * rule which is a rule with priority 2147483647 and match all condition (for
   * the match condition this means match "*" for srcIpRanges and for the
   * networkMatch condition every field must be either match "*" or not set). If
   * no rules are provided when creating a security policy, a default rule with
   * action "allow" will be added.
   */
  rules?: SecurityPolicyRule[];
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * The type indicates the intended use of the security policy. - CLOUD_ARMOR:
   * Cloud Armor backend security policies can be configured to filter incoming
   * HTTP requests targeting backend services. They filter requests before they
   * hit the origin servers. - CLOUD_ARMOR_EDGE: Cloud Armor edge security
   * policies can be configured to filter incoming HTTP requests targeting
   * backend services (including Cloud CDN-enabled) as well as backend buckets
   * (Cloud Storage). They filter requests before the request is served from
   * Google's cache. - CLOUD_ARMOR_INTERNAL_SERVICE: Cloud Armor internal
   * service policies can be configured to filter HTTP requests targeting
   * services managed by Traffic Director in a service mesh. They filter
   * requests before the request is served from the application. -
   * CLOUD_ARMOR_NETWORK: Cloud Armor network policies can be configured to
   * filter packets targeting network load balancing resources such as backend
   * services, target pools, target instances, and instances with external IPs.
   * They filter requests before the request is served from the application.
   * This field can be set only at resource creation time.
   */
  type?:  | "CLOUD_ARMOR" | "CLOUD_ARMOR_EDGE" | "CLOUD_ARMOR_NETWORK";
}

function serializeSecurityPolicy(data: any): SecurityPolicy {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeSecurityPolicy(data: any): SecurityPolicy {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

/**
 * Configuration options for Cloud Armor Adaptive Protection (CAAP).
 */
export interface SecurityPolicyAdaptiveProtectionConfig {
  /**
   * If set to true, enables Cloud Armor Machine Learning.
   */
  layer7DdosDefenseConfig?: SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfig;
}

/**
 * Configuration options for L7 DDoS detection.
 */
export interface SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfig {
  /**
   * If set to true, enables CAAP for L7 DDoS detection.
   */
  enable?: boolean;
  /**
   * Rule visibility can be one of the following: STANDARD - opaque rules.
   * (default) PREMIUM - transparent rules.
   */
  ruleVisibility?:  | "PREMIUM" | "STANDARD";
}

export interface SecurityPolicyAdvancedOptionsConfig {
  /**
   * Custom configuration to apply the JSON parsing. Only applicable when
   * json_parsing is set to STANDARD.
   */
  jsonCustomConfig?: SecurityPolicyAdvancedOptionsConfigJsonCustomConfig;
  jsonParsing?:  | "DISABLED" | "STANDARD";
  logLevel?:  | "NORMAL" | "VERBOSE";
}

export interface SecurityPolicyAdvancedOptionsConfigJsonCustomConfig {
  /**
   * A list of custom Content-Type header values to apply the JSON parsing. As
   * per RFC 1341, a Content-Type header value has the following format:
   * Content-Type := type "/" subtype *[";" parameter] When configuring a custom
   * Content-Type header value, only the type/subtype needs to be specified, and
   * the parameters should be excluded.
   */
  contentTypes?: string[];
}

export interface SecurityPolicyDdosProtectionConfig {
  ddosProtection?:  | "ADVANCED" | "STANDARD";
}

export interface SecurityPolicyList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of SecurityPolicy resources.
   */
  items?: SecurityPolicy[];
  /**
   * [Output Only] Type of resource. Always compute#securityPolicyList for
   * listsof securityPolicies
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeSecurityPolicyList(data: any): SecurityPolicyList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeSecurityPolicy(item))) : undefined,
  };
}

function deserializeSecurityPolicyList(data: any): SecurityPolicyList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeSecurityPolicy(item))) : undefined,
  };
}

export interface SecurityPolicyRecaptchaOptionsConfig {
  /**
   * An optional field to supply a reCAPTCHA site key to be used for all the
   * rules using the redirect action with the type of GOOGLE_RECAPTCHA under the
   * security policy. The specified site key needs to be created from the
   * reCAPTCHA API. The user is responsible for the validity of the specified
   * site key. If not specified, a Google-managed site key is used.
   */
  redirectSiteKey?: string;
}

export interface SecurityPolicyReference {
  securityPolicy?: string;
}

/**
 * Represents a rule that describes one or more match conditions along with the
 * action to be taken when traffic matches this condition (allow or deny).
 */
export interface SecurityPolicyRule {
  /**
   * The Action to perform when the rule is matched. The following are the
   * valid actions: - allow: allow access to target. - deny(STATUS): deny access
   * to target, returns the HTTP response code specified. Valid values for
   * `STATUS` are 403, 404, and 502. - rate_based_ban: limit client traffic to
   * the configured threshold and ban the client if the traffic exceeds the
   * threshold. Configure parameters for this action in RateLimitOptions.
   * Requires rate_limit_options to be set. - redirect: redirect to a different
   * target. This can either be an internal reCAPTCHA redirect, or an external
   * URL-based redirect via a 302 response. Parameters for this action can be
   * configured via redirectOptions. - throttle: limit client traffic to the
   * configured threshold. Configure parameters for this action in
   * rateLimitOptions. Requires rate_limit_options to be set for this.
   */
  action?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * Optional, additional actions that are performed on headers.
   */
  headerAction?: SecurityPolicyRuleHttpHeaderAction;
  /**
   * [Output only] Type of the resource. Always compute#securityPolicyRule for
   * security policy rules
   */
  kind?: string;
  /**
   * A match condition that incoming traffic is evaluated against. If it
   * evaluates to true, the corresponding 'action' is enforced.
   */
  match?: SecurityPolicyRuleMatcher;
  /**
   * Preconfigured WAF configuration to be applied for the rule. If the rule
   * does not evaluate preconfigured WAF rules, i.e., if
   * evaluatePreconfiguredWaf() is not used, this field will have no effect.
   */
  preconfiguredWafConfig?: SecurityPolicyRulePreconfiguredWafConfig;
  /**
   * If set to true, the specified action is not enforced.
   */
  preview?: boolean;
  /**
   * An integer indicating the priority of a rule in the list. The priority
   * must be a positive value between 0 and 2147483647. Rules are evaluated from
   * highest to lowest priority where 0 is the highest priority and 2147483647
   * is the lowest priority.
   */
  priority?: number;
  /**
   * Must be specified if the action is "rate_based_ban" or "throttle". Cannot
   * be specified for any other actions.
   */
  rateLimitOptions?: SecurityPolicyRuleRateLimitOptions;
  /**
   * Parameters defining the redirect action. Cannot be specified for any other
   * actions.
   */
  redirectOptions?: SecurityPolicyRuleRedirectOptions;
}

export interface SecurityPolicyRuleHttpHeaderAction {
  /**
   * The list of request headers to add or overwrite if they're already
   * present.
   */
  requestHeadersToAdds?: SecurityPolicyRuleHttpHeaderActionHttpHeaderOption[];
}

export interface SecurityPolicyRuleHttpHeaderActionHttpHeaderOption {
  /**
   * The name of the header to set.
   */
  headerName?: string;
  /**
   * The value to set the named header to.
   */
  headerValue?: string;
}

/**
 * Represents a match condition that incoming traffic is evaluated against.
 * Exactly one field must be specified.
 */
export interface SecurityPolicyRuleMatcher {
  /**
   * The configuration options available when specifying versioned_expr. This
   * field must be specified if versioned_expr is specified and cannot be
   * specified if versioned_expr is not specified.
   */
  config?: SecurityPolicyRuleMatcherConfig;
  /**
   * User defined CEVAL expression. A CEVAL expression is used to specify match
   * criteria such as origin.ip, source.region_code and contents in the request
   * header.
   */
  expr?: Expr;
  /**
   * Preconfigured versioned expression. If this field is specified, config
   * must also be specified. Available preconfigured expressions along with
   * their requirements are: SRC_IPS_V1 - must specify the corresponding
   * src_ip_range field in config.
   */
  versionedExpr?:  | "SRC_IPS_V1";
}

export interface SecurityPolicyRuleMatcherConfig {
  /**
   * CIDR IP address range. Maximum number of src_ip_ranges allowed is 10.
   */
  srcIpRanges?: string[];
}

export interface SecurityPolicyRulePreconfiguredWafConfig {
  /**
   * A list of exclusions to apply during preconfigured WAF evaluation.
   */
  exclusions?: SecurityPolicyRulePreconfiguredWafConfigExclusion[];
}

export interface SecurityPolicyRulePreconfiguredWafConfigExclusion {
  /**
   * A list of request cookie names whose value will be excluded from
   * inspection during preconfigured WAF evaluation.
   */
  requestCookiesToExclude?: SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParams[];
  /**
   * A list of request header names whose value will be excluded from
   * inspection during preconfigured WAF evaluation.
   */
  requestHeadersToExclude?: SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParams[];
  /**
   * A list of request query parameter names whose value will be excluded from
   * inspection during preconfigured WAF evaluation. Note that the parameter can
   * be in the query string or in the POST body.
   */
  requestQueryParamsToExclude?: SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParams[];
  /**
   * A list of request URIs from the request line to be excluded from
   * inspection during preconfigured WAF evaluation. When specifying this field,
   * the query or fragment part should be excluded.
   */
  requestUrisToExclude?: SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParams[];
  /**
   * A list of target rule IDs under the WAF rule set to apply the
   * preconfigured WAF exclusion. If omitted, it refers to all the rule IDs
   * under the WAF rule set.
   */
  targetRuleIds?: string[];
  /**
   * Target WAF rule set to apply the preconfigured WAF exclusion.
   */
  targetRuleSet?: string;
}

export interface SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParams {
  /**
   * The match operator for the field.
   */
  op?:  | "CONTAINS" | "ENDS_WITH" | "EQUALS" | "EQUALS_ANY" | "STARTS_WITH";
  /**
   * The value of the field.
   */
  val?: string;
}

export interface SecurityPolicyRuleRateLimitOptions {
  /**
   * Can only be specified if the action for the rule is "rate_based_ban". If
   * specified, determines the time (in seconds) the traffic will continue to be
   * banned by the rate limit after the rate falls below the threshold.
   */
  banDurationSec?: number;
  /**
   * Can only be specified if the action for the rule is "rate_based_ban". If
   * specified, the key will be banned for the configured 'ban_duration_sec'
   * when the number of requests that exceed the 'rate_limit_threshold' also
   * exceed this 'ban_threshold'.
   */
  banThreshold?: SecurityPolicyRuleRateLimitOptionsThreshold;
  /**
   * Action to take for requests that are under the configured rate limit
   * threshold. Valid option is "allow" only.
   */
  conformAction?: string;
  /**
   * Determines the key to enforce the rate_limit_threshold on. Possible values
   * are: - ALL: A single rate limit threshold is applied to all the requests
   * matching this rule. This is the default value if "enforceOnKey" is not
   * configured. - IP: The source IP address of the request is the key. Each IP
   * has this limit enforced separately. - HTTP_HEADER: The value of the HTTP
   * header whose name is configured under "enforceOnKeyName". The key value is
   * truncated to the first 128 bytes of the header value. If no such header is
   * present in the request, the key type defaults to ALL. - XFF_IP: The first
   * IP address (i.e. the originating client IP address) specified in the list
   * of IPs under X-Forwarded-For HTTP header. If no such header is present or
   * the value is not a valid IP, the key defaults to the source IP address of
   * the request i.e. key type IP. - HTTP_COOKIE: The value of the HTTP cookie
   * whose name is configured under "enforceOnKeyName". The key value is
   * truncated to the first 128 bytes of the cookie value. If no such cookie is
   * present in the request, the key type defaults to ALL. - HTTP_PATH: The URL
   * path of the HTTP request. The key value is truncated to the first 128
   * bytes. - SNI: Server name indication in the TLS session of the HTTPS
   * request. The key value is truncated to the first 128 bytes. The key type
   * defaults to ALL on a HTTP session. - REGION_CODE: The country/region from
   * which the request originates.
   */
  enforceOnKey?:  | "ALL" | "HTTP_COOKIE" | "HTTP_HEADER" | "HTTP_PATH" | "IP" | "REGION_CODE" | "SNI" | "XFF_IP";
  /**
   * Rate limit key name applicable only for the following key types:
   * HTTP_HEADER -- Name of the HTTP header whose value is taken as the key
   * value. HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the
   * key value.
   */
  enforceOnKeyName?: string;
  /**
   * Action to take for requests that are above the configured rate limit
   * threshold, to either deny with a specified HTTP response code, or redirect
   * to a different endpoint. Valid options are `deny(STATUS)`, where valid
   * values for `STATUS` are 403, 404, 429, and 502, and `redirect`, where the
   * redirect parameters come from `exceedRedirectOptions` below.
   */
  exceedAction?: string;
  /**
   * Parameters defining the redirect action that is used as the exceed action.
   * Cannot be specified if the exceed action is not redirect.
   */
  exceedRedirectOptions?: SecurityPolicyRuleRedirectOptions;
  /**
   * Threshold at which to begin ratelimiting.
   */
  rateLimitThreshold?: SecurityPolicyRuleRateLimitOptionsThreshold;
}

export interface SecurityPolicyRuleRateLimitOptionsThreshold {
  /**
   * Number of HTTP(S) requests for calculating the threshold.
   */
  count?: number;
  /**
   * Interval over which the threshold is computed.
   */
  intervalSec?: number;
}

export interface SecurityPolicyRuleRedirectOptions {
  /**
   * Target for the redirect action. This is required if the type is
   * EXTERNAL_302 and cannot be specified for GOOGLE_RECAPTCHA.
   */
  target?: string;
  /**
   * Type of the redirect action.
   */
  type?:  | "EXTERNAL_302" | "GOOGLE_RECAPTCHA";
}

/**
 * The authentication and authorization settings for a BackendService.
 */
export interface SecuritySettings {
  /**
   * Optional. A URL referring to a networksecurity.ClientTlsPolicy resource
   * that describes how clients should authenticate with this service's
   * backends. clientTlsPolicy only applies to a global BackendService with the
   * loadBalancingScheme set to INTERNAL_SELF_MANAGED. If left blank,
   * communications are not encrypted. Note: This field currently has no impact.
   */
  clientTlsPolicy?: string;
  /**
   * Optional. A list of Subject Alternative Names (SANs) that the client
   * verifies during a mutual TLS handshake with an server/endpoint for this
   * BackendService. When the server presents its X.509 certificate to the
   * client, the client inspects the certificate's subjectAltName field. If the
   * field contains one of the specified values, the communication continues.
   * Otherwise, it fails. This additional check enables the client to verify
   * that the server is authorized to run the requested service. Note that the
   * contents of the server certificate's subjectAltName field are configured by
   * the Public Key Infrastructure which provisions server identities. Only
   * applies to a global BackendService with loadBalancingScheme set to
   * INTERNAL_SELF_MANAGED. Only applies when BackendService has an attached
   * clientTlsPolicy with clientCertificate (mTLS mode). Note: This field
   * currently has no impact.
   */
  subjectAltNames?: string[];
}

/**
 * An instance serial console output.
 */
export interface SerialPortOutput {
  /**
   * [Output Only] The contents of the console output.
   */
  contents?: string;
  /**
   * [Output Only] Type of the resource. Always compute#serialPortOutput for
   * serial port output.
   */
  kind?: string;
  /**
   * [Output Only] The position of the next byte of content, regardless of
   * whether the content exists, following the output returned in the `contents`
   * property. Use this value in the next request as the start parameter.
   */
  next?: bigint;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * The starting byte position of the output that was returned. This should
   * match the start parameter sent with the request. If the serial console
   * output exceeds the size of the buffer (1 MB), older output is overwritten
   * by newer content. The output start value will indicate the byte position of
   * the output that was returned, which might be different than the `start`
   * value that was specified in the request.
   */
  start?: bigint;
}

function serializeSerialPortOutput(data: any): SerialPortOutput {
  return {
    ...data,
    next: data["next"] !== undefined ? String(data["next"]) : undefined,
    start: data["start"] !== undefined ? String(data["start"]) : undefined,
  };
}

function deserializeSerialPortOutput(data: any): SerialPortOutput {
  return {
    ...data,
    next: data["next"] !== undefined ? BigInt(data["next"]) : undefined,
    start: data["start"] !== undefined ? BigInt(data["start"]) : undefined,
  };
}

export interface ServerBinding {
  type?:  | "RESTART_NODE_ON_ANY_SERVER" | "RESTART_NODE_ON_MINIMAL_SERVERS" | "SERVER_BINDING_TYPE_UNSPECIFIED";
}

/**
 * A service account.
 */
export interface ServiceAccount {
  /**
   * Email address of the service account.
   */
  email?: string;
  /**
   * The list of scopes to be made available for this service account.
   */
  scopes?: string[];
}

/**
 * Represents a ServiceAttachment resource. A service attachment represents a
 * service that a producer has exposed. It encapsulates the load balancer which
 * fronts the service runs and a list of NAT IP ranges that the producers uses
 * to represent the consumers connecting to the service. next tag = 20
 */
export interface ServiceAttachment {
  /**
   * [Output Only] An array of connections for all the consumers connected to
   * this service attachment.
   */
  connectedEndpoints?: ServiceAttachmentConnectedEndpoint[];
  /**
   * The connection preference of service attachment. The value can be set to
   * ACCEPT_AUTOMATIC. An ACCEPT_AUTOMATIC service attachment is one that always
   * accepts the connection from consumer forwarding rules.
   */
  connectionPreference?:  | "ACCEPT_AUTOMATIC" | "ACCEPT_MANUAL" | "CONNECTION_PREFERENCE_UNSPECIFIED";
  /**
   * Projects that are allowed to connect to this service attachment.
   */
  consumerAcceptLists?: ServiceAttachmentConsumerProjectLimit[];
  /**
   * Projects that are not allowed to connect to this service attachment. The
   * project can be specified using its id or number.
   */
  consumerRejectLists?: string[];
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * If specified, the domain name will be used during the integration between
   * the PSC connected endpoints and the Cloud DNS. For example, this is a valid
   * domain name: "p.mycompany.com.". Current max number of domain names
   * supported is 1.
   */
  domainNames?: string[];
  /**
   * If true, enable the proxy protocol which is for supplying client TCP/IP
   * address data in TCP connections that traverse proxies on their way to
   * destination servers.
   */
  enableProxyProtocol?: boolean;
  /**
   * Fingerprint of this resource. A hash of the contents stored in this
   * object. This field is used in optimistic locking. This field will be
   * ignored when inserting a ServiceAttachment. An up-to-date fingerprint must
   * be provided in order to patch/update the ServiceAttachment; otherwise, the
   * request will fail with error 412 conditionNotMet. To see the latest
   * fingerprint, make a get() request to retrieve the ServiceAttachment.
   */
  fingerprint?: Uint8Array;
  /**
   * [Output Only] The unique identifier for the resource type. The server
   * generates this identifier.
   */
  id?: bigint;
  /**
   * [Output Only] Type of the resource. Always compute#serviceAttachment for
   * service attachments.
   */
  kind?: string;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * An array of URLs where each entry is the URL of a subnet provided by the
   * service producer to use for NAT in this service attachment.
   */
  natSubnets?: string[];
  /**
   * The URL of a forwarding rule with loadBalancingScheme INTERNAL* that is
   * serving the endpoint identified by this service attachment.
   */
  producerForwardingRule?: string;
  /**
   * [Output Only] An 128-bit global unique ID of the PSC service attachment.
   */
  pscServiceAttachmentId?: Uint128;
  /**
   * [Output Only] URL of the region where the service attachment resides. This
   * field applies only to the region resource. You must specify this field as
   * part of the HTTP request URL. It is not settable as a field in the request
   * body.
   */
  region?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * The URL of a service serving the endpoint identified by this service
   * attachment.
   */
  targetService?: string;
}

function serializeServiceAttachment(data: any): ServiceAttachment {
  return {
    ...data,
    connectedEndpoints: data["connectedEndpoints"] !== undefined ? data["connectedEndpoints"].map((item: any) => (serializeServiceAttachmentConnectedEndpoint(item))) : undefined,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
    pscServiceAttachmentId: data["pscServiceAttachmentId"] !== undefined ? serializeUint128(data["pscServiceAttachmentId"]) : undefined,
  };
}

function deserializeServiceAttachment(data: any): ServiceAttachment {
  return {
    ...data,
    connectedEndpoints: data["connectedEndpoints"] !== undefined ? data["connectedEndpoints"].map((item: any) => (deserializeServiceAttachmentConnectedEndpoint(item))) : undefined,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
    pscServiceAttachmentId: data["pscServiceAttachmentId"] !== undefined ? deserializeUint128(data["pscServiceAttachmentId"]) : undefined,
  };
}

/**
 * Contains a list of ServiceAttachmentsScopedList.
 */
export interface ServiceAttachmentAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of ServiceAttachmentsScopedList resources.
   */
  items?: {
    [key: string]: ServiceAttachmentsScopedList
  };
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeServiceAttachmentAggregatedList(data: any): ServiceAttachmentAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeServiceAttachmentsScopedList(v)]))) : undefined,
  };
}

function deserializeServiceAttachmentAggregatedList(data: any): ServiceAttachmentAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeServiceAttachmentsScopedList(v)]))) : undefined,
  };
}

/**
 * [Output Only] A connection connected to this service attachment.
 */
export interface ServiceAttachmentConnectedEndpoint {
  /**
   * The url of a connected endpoint.
   */
  endpoint?: string;
  /**
   * The PSC connection id of the connected endpoint.
   */
  pscConnectionId?: bigint;
  /**
   * The status of a connected endpoint to this service attachment.
   */
  status?:  | "ACCEPTED" | "CLOSED" | "NEEDS_ATTENTION" | "PENDING" | "REJECTED" | "STATUS_UNSPECIFIED";
}

function serializeServiceAttachmentConnectedEndpoint(data: any): ServiceAttachmentConnectedEndpoint {
  return {
    ...data,
    pscConnectionId: data["pscConnectionId"] !== undefined ? String(data["pscConnectionId"]) : undefined,
  };
}

function deserializeServiceAttachmentConnectedEndpoint(data: any): ServiceAttachmentConnectedEndpoint {
  return {
    ...data,
    pscConnectionId: data["pscConnectionId"] !== undefined ? BigInt(data["pscConnectionId"]) : undefined,
  };
}

export interface ServiceAttachmentConsumerProjectLimit {
  /**
   * The value of the limit to set.
   */
  connectionLimit?: number;
  /**
   * The network URL for the network to set the limit for.
   */
  networkUrl?: string;
  /**
   * The project id or number for the project to set the limit for.
   */
  projectIdOrNum?: string;
}

export interface ServiceAttachmentList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of ServiceAttachment resources.
   */
  items?: ServiceAttachment[];
  /**
   * [Output Only] Type of the resource. Always compute#serviceAttachment for
   * service attachments.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeServiceAttachmentList(data: any): ServiceAttachmentList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeServiceAttachment(item))) : undefined,
  };
}

function deserializeServiceAttachmentList(data: any): ServiceAttachmentList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeServiceAttachment(item))) : undefined,
  };
}

/**
 * Additional options for Compute#serviceAttachmentsAggregatedList.
 */
export interface ServiceAttachmentsAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#serviceAttachmentsDelete.
 */
export interface ServiceAttachmentsDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#serviceAttachmentsGetIamPolicy.
 */
export interface ServiceAttachmentsGetIamPolicyOptions {
  /**
   * Requested IAM Policy version.
   */
  optionsRequestedPolicyVersion?: number;
}

/**
 * Additional options for Compute#serviceAttachmentsInsert.
 */
export interface ServiceAttachmentsInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#serviceAttachmentsList.
 */
export interface ServiceAttachmentsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#serviceAttachmentsPatch.
 */
export interface ServiceAttachmentsPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface ServiceAttachmentsScopedList {
  /**
   * A list of ServiceAttachments contained in this scope.
   */
  serviceAttachments?: ServiceAttachment[];
  /**
   * Informational warning which replaces the list of service attachments when
   * the list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeServiceAttachmentsScopedList(data: any): ServiceAttachmentsScopedList {
  return {
    ...data,
    serviceAttachments: data["serviceAttachments"] !== undefined ? data["serviceAttachments"].map((item: any) => (serializeServiceAttachment(item))) : undefined,
  };
}

function deserializeServiceAttachmentsScopedList(data: any): ServiceAttachmentsScopedList {
  return {
    ...data,
    serviceAttachments: data["serviceAttachments"] !== undefined ? data["serviceAttachments"].map((item: any) => (deserializeServiceAttachment(item))) : undefined,
  };
}

/**
 * The share setting for reservations and sole tenancy node groups.
 */
export interface ShareSettings {
  /**
   * A map of project id and project config. This is only valid when
   * share_type's value is SPECIFIC_PROJECTS.
   */
  projectMap?: {
    [key: string]: ShareSettingsProjectConfig
  };
  /**
   * Type of sharing for this shared-reservation
   */
  shareType?:  | "LOCAL" | "ORGANIZATION" | "SHARE_TYPE_UNSPECIFIED" | "SPECIFIC_PROJECTS";
}

/**
 * Config for each project in the share settings.
 */
export interface ShareSettingsProjectConfig {
  /**
   * The project ID, should be same as the key of this project config in the
   * parent map.
   */
  projectId?: string;
}

/**
 * A set of Shielded Instance options.
 */
export interface ShieldedInstanceConfig {
  /**
   * Defines whether the instance has integrity monitoring enabled. Enabled by
   * default.
   */
  enableIntegrityMonitoring?: boolean;
  /**
   * Defines whether the instance has Secure Boot enabled. Disabled by default.
   */
  enableSecureBoot?: boolean;
  /**
   * Defines whether the instance has the vTPM enabled. Enabled by default.
   */
  enableVtpm?: boolean;
}

/**
 * A Shielded Instance Identity.
 */
export interface ShieldedInstanceIdentity {
  /**
   * An Endorsement Key (EK) made by the RSA 2048 algorithm issued to the
   * Shielded Instance's vTPM.
   */
  encryptionKey?: ShieldedInstanceIdentityEntry;
  /**
   * [Output Only] Type of the resource. Always
   * compute#shieldedInstanceIdentity for shielded Instance identity entry.
   */
  kind?: string;
  /**
   * An Attestation Key (AK) made by the RSA 2048 algorithm issued to the
   * Shielded Instance's vTPM.
   */
  signingKey?: ShieldedInstanceIdentityEntry;
}

/**
 * A Shielded Instance Identity Entry.
 */
export interface ShieldedInstanceIdentityEntry {
  /**
   * A PEM-encoded X.509 certificate. This field can be empty.
   */
  ekCert?: string;
  /**
   * A PEM-encoded public key.
   */
  ekPub?: string;
}

/**
 * The policy describes the baseline against which Instance boot integrity is
 * measured.
 */
export interface ShieldedInstanceIntegrityPolicy {
  /**
   * Updates the integrity policy baseline using the measurements from the VM
   * instance's most recent boot.
   */
  updateAutoLearnPolicy?: boolean;
}

/**
 * Represents a customer-supplied Signing Key used by Cloud CDN Signed URLs
 */
export interface SignedUrlKey {
  /**
   * Name of the key. The name must be 1-63 characters long, and comply with
   * RFC1035. Specifically, the name must be 1-63 characters long and match the
   * regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first
   * character must be a lowercase letter, and all following characters must be
   * a dash, lowercase letter, or digit, except the last character, which cannot
   * be a dash.
   */
  keyName?: string;
  /**
   * 128-bit key value used for signing the URL. The key value must be a valid
   * RFC 4648 Section 5 base64url encoded string.
   */
  keyValue?: string;
}

/**
 * Represents a Persistent Disk Snapshot resource. You can use snapshots to
 * back up data on a regular interval. For more information, read Creating
 * persistent disk snapshots.
 */
export interface Snapshot {
  /**
   * [Output Only] The architecture of the snapshot. Valid values are ARM64 or
   * X86_64.
   */
  architecture?:  | "ARCHITECTURE_UNSPECIFIED" | "ARM64" | "X86_64";
  /**
   * [Output Only] Set to true if snapshots are automatically created by
   * applying resource policy on the target disk.
   */
  autoCreated?: boolean;
  /**
   * Creates the new snapshot in the snapshot chain labeled with the specified
   * name. The chain name must be 1-63 characters long and comply with RFC1035.
   * This is an uncommon option only for advanced service owners who needs to
   * create separate snapshot chains, for example, for chargeback tracking. When
   * you describe your snapshot resource, this field is visible only if it has a
   * non-empty value.
   */
  chainName?: string;
  /**
   * [Output Only] Size in bytes of the snapshot at creation time.
   */
  creationSizeBytes?: bigint;
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * [Output Only] Size of the source disk, specified in GB.
   */
  diskSizeGb?: bigint;
  /**
   * [Output Only] Number of bytes downloaded to restore a snapshot to a disk.
   */
  downloadBytes?: bigint;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of the resource. Always compute#snapshot for Snapshot
   * resources.
   */
  kind?: string;
  /**
   * A fingerprint for the labels being applied to this snapshot, which is
   * essentially a hash of the labels set used for optimistic locking. The
   * fingerprint is initially generated by Compute Engine and changes after
   * every request to modify or update labels. You must always provide an
   * up-to-date fingerprint hash in order to update or change labels, otherwise
   * the request will fail with error 412 conditionNotMet. To see the latest
   * fingerprint, make a get() request to retrieve a snapshot.
   */
  labelFingerprint?: Uint8Array;
  /**
   * Labels to apply to this snapshot. These can be later modified by the
   * setLabels method. Label values may be empty.
   */
  labels?: {
    [key: string]: string
  };
  /**
   * [Output Only] Integer license codes indicating which licenses are attached
   * to this snapshot.
   */
  licenseCodes?: bigint[];
  /**
   * [Output Only] A list of public visible licenses that apply to this
   * snapshot. This can be because the original image had licenses attached
   * (such as a Windows image).
   */
  licenses?: string[];
  /**
   * An opaque location hint used to place the snapshot close to other
   * resources. This field is for use by internal tools that use the public API.
   */
  locationHint?: string;
  /**
   * Name of the resource; provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * [Output Only] Reserved for future use.
   */
  satisfiesPzs?: boolean;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * Encrypts the snapshot using a customer-supplied encryption key. After you
   * encrypt a snapshot using a customer-supplied key, you must provide the same
   * key if you use the snapshot later. For example, you must provide the
   * encryption key when you create a disk from the encrypted snapshot in a
   * future request. Customer-supplied encryption keys do not protect access to
   * metadata of the snapshot. If you do not provide an encryption key when
   * creating the snapshot, then the snapshot will be encrypted using an
   * automatically generated key and you do not need to provide a key to use the
   * snapshot later.
   */
  snapshotEncryptionKey?: CustomerEncryptionKey;
  /**
   * Indicates the type of the snapshot.
   */
  snapshotType?:  | "ARCHIVE" | "STANDARD";
  /**
   * The source disk used to create this snapshot.
   */
  sourceDisk?: string;
  /**
   * The customer-supplied encryption key of the source disk. Required if the
   * source disk is protected by a customer-supplied encryption key.
   */
  sourceDiskEncryptionKey?: CustomerEncryptionKey;
  /**
   * [Output Only] The ID value of the disk used to create this snapshot. This
   * value may be used to determine whether the snapshot was taken from the
   * current or a previous instance of a given disk name.
   */
  sourceDiskId?: string;
  /**
   * [Output Only] URL of the resource policy which created this scheduled
   * snapshot.
   */
  sourceSnapshotSchedulePolicy?: string;
  /**
   * [Output Only] ID of the resource policy which created this scheduled
   * snapshot.
   */
  sourceSnapshotSchedulePolicyId?: string;
  /**
   * [Output Only] The status of the snapshot. This can be CREATING, DELETING,
   * FAILED, READY, or UPLOADING.
   */
  status?:  | "CREATING" | "DELETING" | "FAILED" | "READY" | "UPLOADING";
  /**
   * [Output Only] A size of the storage used by the snapshot. As snapshots
   * share storage, this number is expected to change with snapshot
   * creation/deletion.
   */
  storageBytes?: bigint;
  /**
   * [Output Only] An indicator whether storageBytes is in a stable state or it
   * is being adjusted as a result of shared storage reallocation. This status
   * can either be UPDATING, meaning the size of the snapshot is being updated,
   * or UP_TO_DATE, meaning the size of the snapshot is up-to-date.
   */
  storageBytesStatus?:  | "UPDATING" | "UP_TO_DATE";
  /**
   * Cloud Storage bucket storage location of the snapshot (regional or
   * multi-regional).
   */
  storageLocations?: string[];
}

function serializeSnapshot(data: any): Snapshot {
  return {
    ...data,
    creationSizeBytes: data["creationSizeBytes"] !== undefined ? String(data["creationSizeBytes"]) : undefined,
    diskSizeGb: data["diskSizeGb"] !== undefined ? String(data["diskSizeGb"]) : undefined,
    downloadBytes: data["downloadBytes"] !== undefined ? String(data["downloadBytes"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
    labelFingerprint: data["labelFingerprint"] !== undefined ? encodeBase64(data["labelFingerprint"]) : undefined,
    licenseCodes: data["licenseCodes"] !== undefined ? data["licenseCodes"].map((item: any) => (String(item))) : undefined,
    storageBytes: data["storageBytes"] !== undefined ? String(data["storageBytes"]) : undefined,
  };
}

function deserializeSnapshot(data: any): Snapshot {
  return {
    ...data,
    creationSizeBytes: data["creationSizeBytes"] !== undefined ? BigInt(data["creationSizeBytes"]) : undefined,
    diskSizeGb: data["diskSizeGb"] !== undefined ? BigInt(data["diskSizeGb"]) : undefined,
    downloadBytes: data["downloadBytes"] !== undefined ? BigInt(data["downloadBytes"]) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
    labelFingerprint: data["labelFingerprint"] !== undefined ? decodeBase64(data["labelFingerprint"] as string) : undefined,
    licenseCodes: data["licenseCodes"] !== undefined ? data["licenseCodes"].map((item: any) => (BigInt(item))) : undefined,
    storageBytes: data["storageBytes"] !== undefined ? BigInt(data["storageBytes"]) : undefined,
  };
}

/**
 * Contains a list of Snapshot resources.
 */
export interface SnapshotList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of Snapshot resources.
   */
  items?: Snapshot[];
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeSnapshotList(data: any): SnapshotList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeSnapshot(item))) : undefined,
  };
}

function deserializeSnapshotList(data: any): SnapshotList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeSnapshot(item))) : undefined,
  };
}

/**
 * Additional options for Compute#snapshotsDelete.
 */
export interface SnapshotsDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#snapshotsGetIamPolicy.
 */
export interface SnapshotsGetIamPolicyOptions {
  /**
   * Requested IAM Policy version.
   */
  optionsRequestedPolicyVersion?: number;
}

/**
 * Additional options for Compute#snapshotsInsert.
 */
export interface SnapshotsInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#snapshotsList.
 */
export interface SnapshotsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface SourceDiskEncryptionKey {
  /**
   * The customer-supplied encryption key of the source disk. Required if the
   * source disk is protected by a customer-supplied encryption key.
   */
  diskEncryptionKey?: CustomerEncryptionKey;
  /**
   * URL of the disk attached to the source instance. This can be a full or
   * valid partial URL. For example, the following are valid values: -
   * https://www.googleapis.com/compute/v1/projects/project/zones/zone
   * /disks/disk - projects/project/zones/zone/disks/disk -
   * zones/zone/disks/disk
   */
  sourceDisk?: string;
}

/**
 * A specification of the parameters to use when creating the instance template
 * from a source instance.
 */
export interface SourceInstanceParams {
  /**
   * Attached disks configuration. If not provided, defaults are applied: For
   * boot disk and any other R/W disks, the source images for each disk will be
   * used. For read-only disks, they will be attached in read-only mode. Local
   * SSD disks will be created as blank volumes.
   */
  diskConfigs?: DiskInstantiationConfig[];
}

/**
 * DEPRECATED: Please use compute#instanceProperties instead. New properties
 * will not be added to this field.
 */
export interface SourceInstanceProperties {
  /**
   * Enables instances created based on this machine image to send packets with
   * source IP addresses other than their own and receive packets with
   * destination IP addresses other than their own. If these instances will be
   * used as an IP gateway or it will be set as the next-hop in a Route
   * resource, specify true. If unsure, leave this set to false. See the Enable
   * IP forwarding documentation for more information.
   */
  canIpForward?: boolean;
  /**
   * Whether the instance created from this machine image should be protected
   * against deletion.
   */
  deletionProtection?: boolean;
  /**
   * An optional text description for the instances that are created from this
   * machine image.
   */
  description?: string;
  /**
   * An array of disks that are associated with the instances that are created
   * from this machine image.
   */
  disks?: SavedAttachedDisk[];
  /**
   * A list of guest accelerator cards' type and count to use for instances
   * created from this machine image.
   */
  guestAccelerators?: AcceleratorConfig[];
  /**
   * KeyRevocationActionType of the instance. Supported options are "STOP" and
   * "NONE". The default value is "NONE" if it is not specified.
   */
  keyRevocationActionType?:  | "KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED" | "NONE" | "STOP";
  /**
   * Labels to apply to instances that are created from this machine image.
   */
  labels?: {
    [key: string]: string
  };
  /**
   * The machine type to use for instances that are created from this machine
   * image.
   */
  machineType?: string;
  /**
   * The metadata key/value pairs to assign to instances that are created from
   * this machine image. These pairs can consist of custom metadata or
   * predefined keys. See Project and instance metadata for more information.
   */
  metadata?: Metadata;
  /**
   * Minimum cpu/platform to be used by instances created from this machine
   * image. The instance may be scheduled on the specified or newer
   * cpu/platform. Applicable values are the friendly names of CPU platforms,
   * such as minCpuPlatform: "Intel Haswell" or minCpuPlatform: "Intel Sandy
   * Bridge". For more information, read Specifying a Minimum CPU Platform.
   */
  minCpuPlatform?: string;
  /**
   * An array of network access configurations for this interface.
   */
  networkInterfaces?: NetworkInterface[];
  /**
   * Specifies the scheduling options for the instances that are created from
   * this machine image.
   */
  scheduling?: Scheduling;
  /**
   * A list of service accounts with specified scopes. Access tokens for these
   * service accounts are available to the instances that are created from this
   * machine image. Use metadata queries to obtain the access tokens for these
   * instances.
   */
  serviceAccounts?: ServiceAccount[];
  /**
   * A list of tags to apply to the instances that are created from this
   * machine image. The tags identify valid sources or targets for network
   * firewalls. The setTags method can modify this list of tags. Each tag within
   * the list must comply with RFC1035.
   */
  tags?: Tags;
}

function serializeSourceInstanceProperties(data: any): SourceInstanceProperties {
  return {
    ...data,
    disks: data["disks"] !== undefined ? data["disks"].map((item: any) => (serializeSavedAttachedDisk(item))) : undefined,
    metadata: data["metadata"] !== undefined ? serializeMetadata(data["metadata"]) : undefined,
    networkInterfaces: data["networkInterfaces"] !== undefined ? data["networkInterfaces"].map((item: any) => (serializeNetworkInterface(item))) : undefined,
    tags: data["tags"] !== undefined ? serializeTags(data["tags"]) : undefined,
  };
}

function deserializeSourceInstanceProperties(data: any): SourceInstanceProperties {
  return {
    ...data,
    disks: data["disks"] !== undefined ? data["disks"].map((item: any) => (deserializeSavedAttachedDisk(item))) : undefined,
    metadata: data["metadata"] !== undefined ? deserializeMetadata(data["metadata"]) : undefined,
    networkInterfaces: data["networkInterfaces"] !== undefined ? data["networkInterfaces"].map((item: any) => (deserializeNetworkInterface(item))) : undefined,
    tags: data["tags"] !== undefined ? deserializeTags(data["tags"]) : undefined,
  };
}

/**
 * Represents an SSL Certificate resource. Google Compute Engine has two SSL
 * Certificate resources: *
 * [Global](/compute/docs/reference/rest/v1/sslCertificates) *
 * [Regional](/compute/docs/reference/rest/v1/regionSslCertificates) The
 * sslCertificates are used by: - external HTTPS load balancers - SSL proxy load
 * balancers The regionSslCertificates are used by internal HTTPS load
 * balancers. Optionally, certificate file contents that you upload can contain
 * a set of up to five PEM-encoded certificates. The API call creates an object
 * (sslCertificate) that holds this data. You can use SSL keys and certificates
 * to secure connections to a load balancer. For more information, read Creating
 * and using SSL certificates, SSL certificates quotas and limits, and
 * Troubleshooting SSL certificates.
 */
export interface SslCertificate {
  /**
   * A value read into memory from a certificate file. The certificate file
   * must be in PEM format. The certificate chain must be no greater than 5
   * certs long. The chain must include at least one intermediate cert.
   */
  certificate?: string;
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * [Output Only] Expire time of the certificate. RFC3339
   */
  expireTime?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of the resource. Always compute#sslCertificate for SSL
   * certificates.
   */
  kind?: string;
  /**
   * Configuration and status of a managed SSL certificate.
   */
  managed?: SslCertificateManagedSslCertificate;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * A value read into memory from a write-only private key file. The private
   * key file must be in PEM format. For security, only insert requests include
   * this field.
   */
  privateKey?: string;
  /**
   * [Output Only] URL of the region where the regional SSL Certificate
   * resides. This field is not applicable to global SSL Certificate.
   */
  region?: string;
  /**
   * [Output only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * Configuration and status of a self-managed SSL certificate.
   */
  selfManaged?: SslCertificateSelfManagedSslCertificate;
  /**
   * [Output Only] Domains associated with the certificate via Subject
   * Alternative Name.
   */
  subjectAlternativeNames?: string[];
  /**
   * (Optional) Specifies the type of SSL certificate, either "SELF_MANAGED" or
   * "MANAGED". If not specified, the certificate is self-managed and the fields
   * certificate and private_key are used.
   */
  type?:  | "MANAGED" | "SELF_MANAGED" | "TYPE_UNSPECIFIED";
}

function serializeSslCertificate(data: any): SslCertificate {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeSslCertificate(data: any): SslCertificate {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface SslCertificateAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of SslCertificatesScopedList resources.
   */
  items?: {
    [key: string]: SslCertificatesScopedList
  };
  /**
   * [Output Only] Type of resource. Always
   * compute#sslCertificateAggregatedList for lists of SSL Certificates.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeSslCertificateAggregatedList(data: any): SslCertificateAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeSslCertificatesScopedList(v)]))) : undefined,
  };
}

function deserializeSslCertificateAggregatedList(data: any): SslCertificateAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeSslCertificatesScopedList(v)]))) : undefined,
  };
}

/**
 * Contains a list of SslCertificate resources.
 */
export interface SslCertificateList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of SslCertificate resources.
   */
  items?: SslCertificate[];
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeSslCertificateList(data: any): SslCertificateList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeSslCertificate(item))) : undefined,
  };
}

function deserializeSslCertificateList(data: any): SslCertificateList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeSslCertificate(item))) : undefined,
  };
}

/**
 * Configuration and status of a managed SSL certificate.
 */
export interface SslCertificateManagedSslCertificate {
  /**
   * The domains for which a managed SSL certificate will be generated. Each
   * Google-managed SSL certificate supports up to the [maximum number of
   * domains per Google-managed SSL
   * certificate](/load-balancing/docs/quotas#ssl_certificates).
   */
  domains?: string[];
  /**
   * [Output only] Detailed statuses of the domains specified for managed
   * certificate resource.
   */
  domainStatus?: {
    [key: string]:  | "ACTIVE" | "DOMAIN_STATUS_UNSPECIFIED" | "FAILED_CAA_CHECKING" | "FAILED_CAA_FORBIDDEN" | "FAILED_NOT_VISIBLE" | "FAILED_RATE_LIMITED" | "PROVISIONING"
  };
  /**
   * [Output only] Status of the managed certificate resource.
   */
  status?:  | "ACTIVE" | "MANAGED_CERTIFICATE_STATUS_UNSPECIFIED" | "PROVISIONING" | "PROVISIONING_FAILED" | "PROVISIONING_FAILED_PERMANENTLY" | "RENEWAL_FAILED";
}

/**
 * Additional options for Compute#sslCertificatesAggregatedList.
 */
export interface SslCertificatesAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#sslCertificatesDelete.
 */
export interface SslCertificatesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Configuration and status of a self-managed SSL certificate.
 */
export interface SslCertificateSelfManagedSslCertificate {
  /**
   * A local certificate file. The certificate must be in PEM format. The
   * certificate chain must be no greater than 5 certs long. The chain must
   * include at least one intermediate cert.
   */
  certificate?: string;
  /**
   * A write-only private key in PEM format. Only insert requests will include
   * this field.
   */
  privateKey?: string;
}

/**
 * Additional options for Compute#sslCertificatesInsert.
 */
export interface SslCertificatesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#sslCertificatesList.
 */
export interface SslCertificatesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface SslCertificatesScopedList {
  /**
   * List of SslCertificates contained in this scope.
   */
  sslCertificates?: SslCertificate[];
  /**
   * Informational warning which replaces the list of backend services when the
   * list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeSslCertificatesScopedList(data: any): SslCertificatesScopedList {
  return {
    ...data,
    sslCertificates: data["sslCertificates"] !== undefined ? data["sslCertificates"].map((item: any) => (serializeSslCertificate(item))) : undefined,
  };
}

function deserializeSslCertificatesScopedList(data: any): SslCertificatesScopedList {
  return {
    ...data,
    sslCertificates: data["sslCertificates"] !== undefined ? data["sslCertificates"].map((item: any) => (deserializeSslCertificate(item))) : undefined,
  };
}

export interface SSLHealthCheck {
  /**
   * The TCP port number to which the health check prober sends packets. The
   * default value is 443. Valid values are 1 through 65535.
   */
  port?: number;
  /**
   * Not supported.
   */
  portName?: string;
  /**
   * Specifies how a port is selected for health checking. Can be one of the
   * following values: USE_FIXED_PORT: Specifies a port number explicitly using
   * the port field in the health check. Supported by backend services for
   * pass-through load balancers and backend services for proxy load balancers.
   * Not supported by target pools. The health check supports all backends
   * supported by the backend service provided the backend can be health
   * checked. For example, GCE_VM_IP network endpoint groups, GCE_VM_IP_PORT
   * network endpoint groups, and instance group backends. USE_NAMED_PORT: Not
   * supported. USE_SERVING_PORT: Provides an indirect method of specifying the
   * health check port by referring to the backend service. Only supported by
   * backend services for proxy load balancers. Not supported by target pools.
   * Not supported by backend services for pass-through load balancers. Supports
   * all backends that can be health checked; for example, GCE_VM_IP_PORT
   * network endpoint groups and instance group backends. For GCE_VM_IP_PORT
   * network endpoint group backends, the health check uses the port number
   * specified for each endpoint in the network endpoint group. For instance
   * group backends, the health check uses the port number determined by looking
   * up the backend service's named port in the instance group's list of named
   * ports.
   */
  portSpecification?:  | "USE_FIXED_PORT" | "USE_NAMED_PORT" | "USE_SERVING_PORT";
  /**
   * Specifies the type of proxy header to append before sending data to the
   * backend, either NONE or PROXY_V1. The default is NONE.
   */
  proxyHeader?:  | "NONE" | "PROXY_V1";
  /**
   * Instructs the health check prober to send this exact ASCII string, up to
   * 1024 bytes in length, after establishing the TCP connection and SSL
   * handshake.
   */
  request?: string;
  /**
   * Creates a content-based SSL health check. In addition to establishing a
   * TCP connection and the TLS handshake, you can configure the health check to
   * pass only when the backend sends this exact response ASCII string, up to
   * 1024 bytes in length. For details, see:
   * https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-ssl-tcp
   */
  response?: string;
}

export interface SslPoliciesAggregatedList {
  etag?: string;
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of SslPoliciesScopedList resources.
   */
  items?: {
    [key: string]: SslPoliciesScopedList
  };
  /**
   * [Output Only] Type of resource. Always compute#sslPolicyAggregatedList for
   * lists of SSL Policies.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeSslPoliciesAggregatedList(data: any): SslPoliciesAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeSslPoliciesScopedList(v)]))) : undefined,
  };
}

function deserializeSslPoliciesAggregatedList(data: any): SslPoliciesAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeSslPoliciesScopedList(v)]))) : undefined,
  };
}

/**
 * Additional options for Compute#sslPoliciesAggregatedList.
 */
export interface SslPoliciesAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#sslPoliciesDelete.
 */
export interface SslPoliciesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#sslPoliciesInsert.
 */
export interface SslPoliciesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface SslPoliciesList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of SslPolicy resources.
   */
  items?: SslPolicy[];
  /**
   * [Output Only] Type of the resource. Always compute#sslPoliciesList for
   * lists of sslPolicies.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeSslPoliciesList(data: any): SslPoliciesList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeSslPolicy(item))) : undefined,
  };
}

function deserializeSslPoliciesList(data: any): SslPoliciesList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeSslPolicy(item))) : undefined,
  };
}

/**
 * Additional options for Compute#sslPoliciesListAvailableFeatures.
 */
export interface SslPoliciesListAvailableFeaturesOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface SslPoliciesListAvailableFeaturesResponse {
  features?: string[];
}

/**
 * Additional options for Compute#sslPoliciesList.
 */
export interface SslPoliciesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#sslPoliciesPatch.
 */
export interface SslPoliciesPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface SslPoliciesScopedList {
  /**
   * A list of SslPolicies contained in this scope.
   */
  sslPolicies?: SslPolicy[];
  /**
   * Informational warning which replaces the list of SSL policies when the
   * list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeSslPoliciesScopedList(data: any): SslPoliciesScopedList {
  return {
    ...data,
    sslPolicies: data["sslPolicies"] !== undefined ? data["sslPolicies"].map((item: any) => (serializeSslPolicy(item))) : undefined,
  };
}

function deserializeSslPoliciesScopedList(data: any): SslPoliciesScopedList {
  return {
    ...data,
    sslPolicies: data["sslPolicies"] !== undefined ? data["sslPolicies"].map((item: any) => (deserializeSslPolicy(item))) : undefined,
  };
}

/**
 * Represents an SSL Policy resource. Use SSL policies to control the SSL
 * features, such as versions and cipher suites, offered by an HTTPS or SSL
 * Proxy load balancer. For more information, read SSL Policy Concepts.
 */
export interface SslPolicy {
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * A list of features enabled when the selected profile is CUSTOM. The method
   * returns the set of features that can be specified in this list. This field
   * must be empty if the profile is not CUSTOM.
   */
  customFeatures?: string[];
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * [Output Only] The list of features enabled in the SSL policy.
   */
  enabledFeatures?: string[];
  /**
   * Fingerprint of this resource. A hash of the contents stored in this
   * object. This field is used in optimistic locking. This field will be
   * ignored when inserting a SslPolicy. An up-to-date fingerprint must be
   * provided in order to update the SslPolicy, otherwise the request will fail
   * with error 412 conditionNotMet. To see the latest fingerprint, make a get()
   * request to retrieve an SslPolicy.
   */
  fingerprint?: Uint8Array;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output only] Type of the resource. Always compute#sslPolicyfor SSL
   * policies.
   */
  kind?: string;
  /**
   * The minimum version of SSL protocol that can be used by the clients to
   * establish a connection with the load balancer. This can be one of TLS_1_0,
   * TLS_1_1, TLS_1_2.
   */
  minTlsVersion?:  | "TLS_1_0" | "TLS_1_1" | "TLS_1_2";
  /**
   * Name of the resource. The name must be 1-63 characters long, and comply
   * with RFC1035. Specifically, the name must be 1-63 characters long and match
   * the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first
   * character must be a lowercase letter, and all following characters must be
   * a dash, lowercase letter, or digit, except the last character, which cannot
   * be a dash.
   */
  name?: string;
  /**
   * Profile specifies the set of SSL features that can be used by the load
   * balancer when negotiating SSL with clients. This can be one of COMPATIBLE,
   * MODERN, RESTRICTED, or CUSTOM. If using CUSTOM, the set of SSL features to
   * enable must be specified in the customFeatures field.
   */
  profile?:  | "COMPATIBLE" | "CUSTOM" | "MODERN" | "RESTRICTED";
  /**
   * [Output Only] URL of the region where the regional SSL policy resides.
   * This field is not applicable to global SSL policies.
   */
  region?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * [Output Only] If potential misconfigurations are detected for this SSL
   * policy, this field will be populated with warning messages.
   */
  warnings?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  }[];
}

function serializeSslPolicy(data: any): SslPolicy {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeSslPolicy(data: any): SslPolicy {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface SslPolicyReference {
  /**
   * URL of the SSL policy resource. Set this to empty string to clear any
   * existing SSL policy associated with the target proxy resource.
   */
  sslPolicy?: string;
}

export interface StatefulPolicy {
  preservedState?: StatefulPolicyPreservedState;
}

/**
 * Configuration of preserved resources.
 */
export interface StatefulPolicyPreservedState {
  /**
   * Disks created on the instances that will be preserved on instance delete,
   * update, etc. This map is keyed with the device names of the disks.
   */
  disks?: {
    [key: string]: StatefulPolicyPreservedStateDiskDevice
  };
}

export interface StatefulPolicyPreservedStateDiskDevice {
  /**
   * These stateful disks will never be deleted during autohealing, update or
   * VM instance recreate operations. This flag is used to configure if the disk
   * should be deleted after it is no longer used by the group, e.g. when the
   * given instance or the whole group is deleted. Note: disks attached in
   * READ_ONLY mode cannot be auto-deleted.
   */
  autoDelete?:  | "NEVER" | "ON_PERMANENT_INSTANCE_DELETION";
}

/**
 * Represents a Subnetwork resource. A subnetwork (also known as a subnet) is a
 * logical partition of a Virtual Private Cloud network with one primary IP
 * range and zero or more secondary IP ranges. For more information, read
 * Virtual Private Cloud (VPC) Network.
 */
export interface Subnetwork {
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource. This field can be set only at resource creation time.
   */
  description?: string;
  /**
   * Whether to enable flow logging for this subnetwork. If this field is not
   * explicitly set, it will not appear in get listings. If not set the default
   * behavior is determined by the org policy, if there is no org policy
   * specified, then it will default to disabled. This field isn't supported
   * with the purpose field set to INTERNAL_HTTPS_LOAD_BALANCER.
   */
  enableFlowLogs?: boolean;
  /**
   * The external IPv6 address range that is owned by this subnetwork.
   */
  externalIpv6Prefix?: string;
  /**
   * Fingerprint of this resource. A hash of the contents stored in this
   * object. This field is used in optimistic locking. This field will be
   * ignored when inserting a Subnetwork. An up-to-date fingerprint must be
   * provided in order to update the Subnetwork, otherwise the request will fail
   * with error 412 conditionNotMet. To see the latest fingerprint, make a get()
   * request to retrieve a Subnetwork.
   */
  fingerprint?: Uint8Array;
  /**
   * [Output Only] The gateway address for default routes to reach destination
   * addresses outside this subnetwork.
   */
  gatewayAddress?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] The internal IPv6 address range that is assigned to this
   * subnetwork.
   */
  internalIpv6Prefix?: string;
  /**
   * The range of internal addresses that are owned by this subnetwork. Provide
   * this property when you create the subnetwork. For example, 10.0.0.0/8 or
   * 100.64.0.0/10. Ranges must be unique and non-overlapping within a network.
   * Only IPv4 is supported. This field is set at resource creation time. The
   * range can be any range listed in the Valid ranges list. The range can be
   * expanded after creation using expandIpCidrRange.
   */
  ipCidrRange?: string;
  /**
   * The access type of IPv6 address this subnet holds. It's immutable and can
   * only be specified during creation or the first time the subnet is updated
   * into IPV4_IPV6 dual stack.
   */
  ipv6AccessType?:  | "EXTERNAL" | "INTERNAL";
  /**
   * [Output Only] This field is for internal use.
   */
  ipv6CidrRange?: string;
  /**
   * [Output Only] Type of the resource. Always compute#subnetwork for
   * Subnetwork resources.
   */
  kind?: string;
  /**
   * This field denotes the VPC flow logging options for this subnetwork. If
   * logging is enabled, logs are exported to Cloud Logging.
   */
  logConfig?: SubnetworkLogConfig;
  /**
   * The name of the resource, provided by the client when initially creating
   * the resource. The name must be 1-63 characters long, and comply with
   * RFC1035. Specifically, the name must be 1-63 characters long and match the
   * regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first
   * character must be a lowercase letter, and all following characters must be
   * a dash, lowercase letter, or digit, except the last character, which cannot
   * be a dash.
   */
  name?: string;
  /**
   * The URL of the network to which this subnetwork belongs, provided by the
   * client when initially creating the subnetwork. This field can be set only
   * at resource creation time.
   */
  network?: string;
  /**
   * Whether the VMs in this subnet can access Google services without assigned
   * external IP addresses. This field can be both set at resource creation time
   * and updated using setPrivateIpGoogleAccess.
   */
  privateIpGoogleAccess?: boolean;
  /**
   * This field is for internal use. This field can be both set at resource
   * creation time and updated using patch.
   */
  privateIpv6GoogleAccess?:  | "DISABLE_GOOGLE_ACCESS" | "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE" | "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE";
  /**
   * The purpose of the resource. This field can be either PRIVATE_RFC_1918 or
   * INTERNAL_HTTPS_LOAD_BALANCER. A subnetwork with purpose set to
   * INTERNAL_HTTPS_LOAD_BALANCER is a user-created subnetwork that is reserved
   * for Internal HTTP(S) Load Balancing. If unspecified, the purpose defaults
   * to PRIVATE_RFC_1918. The enableFlowLogs field isn't supported with the
   * purpose field set to INTERNAL_HTTPS_LOAD_BALANCER.
   */
  purpose?:  | "INTERNAL_HTTPS_LOAD_BALANCER" | "PRIVATE" | "PRIVATE_RFC_1918" | "PRIVATE_SERVICE_CONNECT" | "REGIONAL_MANAGED_PROXY";
  /**
   * URL of the region where the Subnetwork resides. This field can be set only
   * at resource creation time.
   */
  region?: string;
  /**
   * The role of subnetwork. Currently, this field is only used when purpose =
   * INTERNAL_HTTPS_LOAD_BALANCER. The value can be set to ACTIVE or BACKUP. An
   * ACTIVE subnetwork is one that is currently being used for Internal HTTP(S)
   * Load Balancing. A BACKUP subnetwork is one that is ready to be promoted to
   * ACTIVE or is currently draining. This field can be updated with a patch
   * request.
   */
  role?:  | "ACTIVE" | "BACKUP";
  /**
   * An array of configurations for secondary IP ranges for VM instances
   * contained in this subnetwork. The primary IP of such VM must belong to the
   * primary ipCidrRange of the subnetwork. The alias IPs may belong to either
   * primary or secondary ranges. This field can be updated with a patch
   * request.
   */
  secondaryIpRanges?: SubnetworkSecondaryRange[];
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * The stack type for the subnet. If set to IPV4_ONLY, new VMs in the subnet
   * are assigned IPv4 addresses only. If set to IPV4_IPV6, new VMs in the
   * subnet can be assigned both IPv4 and IPv6 addresses. If not specified,
   * IPV4_ONLY is used. This field can be both set at resource creation time and
   * updated using patch.
   */
  stackType?:  | "IPV4_IPV6" | "IPV4_ONLY";
  /**
   * [Output Only] The state of the subnetwork, which can be one of the
   * following values: READY: Subnetwork is created and ready to use DRAINING:
   * only applicable to subnetworks that have the purpose set to
   * INTERNAL_HTTPS_LOAD_BALANCER and indicates that connections to the load
   * balancer are being drained. A subnetwork that is draining cannot be used or
   * modified until it reaches a status of READY
   */
  state?:  | "DRAINING" | "READY";
}

function serializeSubnetwork(data: any): Subnetwork {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeSubnetwork(data: any): Subnetwork {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface SubnetworkAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of SubnetworksScopedList resources.
   */
  items?: {
    [key: string]: SubnetworksScopedList
  };
  /**
   * [Output Only] Type of resource. Always compute#subnetworkAggregatedList
   * for aggregated lists of subnetworks.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeSubnetworkAggregatedList(data: any): SubnetworkAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeSubnetworksScopedList(v)]))) : undefined,
  };
}

function deserializeSubnetworkAggregatedList(data: any): SubnetworkAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeSubnetworksScopedList(v)]))) : undefined,
  };
}

/**
 * Contains a list of Subnetwork resources.
 */
export interface SubnetworkList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of Subnetwork resources.
   */
  items?: Subnetwork[];
  /**
   * [Output Only] Type of resource. Always compute#subnetworkList for lists of
   * subnetworks.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeSubnetworkList(data: any): SubnetworkList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeSubnetwork(item))) : undefined,
  };
}

function deserializeSubnetworkList(data: any): SubnetworkList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeSubnetwork(item))) : undefined,
  };
}

/**
 * The available logging options for this subnetwork.
 */
export interface SubnetworkLogConfig {
  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * Toggles the aggregation interval for collecting flow logs. Increasing the
   * interval time will reduce the amount of generated flow logs for long
   * lasting connections. Default is an interval of 5 seconds per connection.
   */
  aggregationInterval?:  | "INTERVAL_10_MIN" | "INTERVAL_15_MIN" | "INTERVAL_1_MIN" | "INTERVAL_30_SEC" | "INTERVAL_5_MIN" | "INTERVAL_5_SEC";
  /**
   * Whether to enable flow logging for this subnetwork. If this field is not
   * explicitly set, it will not appear in get listings. If not set the default
   * behavior is determined by the org policy, if there is no org policy
   * specified, then it will default to disabled.
   */
  enable?: boolean;
  /**
   * Can only be specified if VPC flow logs for this subnetwork is enabled. The
   * filter expression is used to define which VPC flow logs should be exported
   * to Cloud Logging.
   */
  filterExpr?: string;
  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * The value of the field must be in [0, 1]. Set the sampling rate of VPC flow
   * logs within the subnetwork where 1.0 means all collected logs are reported
   * and 0.0 means no logs are reported. Default is 0.5 unless otherwise
   * specified by the org policy, which means half of all collected logs are
   * reported.
   */
  flowSampling?: number;
  /**
   * Can only be specified if VPC flow logs for this subnetwork is enabled.
   * Configures whether all, none or a subset of metadata fields should be added
   * to the reported VPC flow logs. Default is EXCLUDE_ALL_METADATA.
   */
  metadata?:  | "CUSTOM_METADATA" | "EXCLUDE_ALL_METADATA" | "INCLUDE_ALL_METADATA";
  /**
   * Can only be specified if VPC flow logs for this subnetwork is enabled and
   * "metadata" was set to CUSTOM_METADATA.
   */
  metadataFields?: string[];
}

/**
 * Additional options for Compute#subnetworksAggregatedList.
 */
export interface SubnetworksAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#subnetworksDelete.
 */
export interface SubnetworksDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Represents a secondary IP range of a subnetwork.
 */
export interface SubnetworkSecondaryRange {
  /**
   * The range of IP addresses belonging to this subnetwork secondary range.
   * Provide this property when you create the subnetwork. Ranges must be unique
   * and non-overlapping with all primary and secondary IP ranges within a
   * network. Only IPv4 is supported. The range can be any range listed in the
   * Valid ranges list.
   */
  ipCidrRange?: string;
  /**
   * The name associated with this subnetwork secondary range, used when adding
   * an alias IP range to a VM instance. The name must be 1-63 characters long,
   * and comply with RFC1035. The name must be unique within the subnetwork.
   */
  rangeName?: string;
}

/**
 * Additional options for Compute#subnetworksExpandIpCidrRange.
 */
export interface SubnetworksExpandIpCidrRangeOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface SubnetworksExpandIpCidrRangeRequest {
  /**
   * The IP (in CIDR format or netmask) of internal addresses that are legal on
   * this Subnetwork. This range should be disjoint from other subnetworks
   * within this network. This range can only be larger than (i.e. a superset
   * of) the range previously defined before the update.
   */
  ipCidrRange?: string;
}

/**
 * Additional options for Compute#subnetworksGetIamPolicy.
 */
export interface SubnetworksGetIamPolicyOptions {
  /**
   * Requested IAM Policy version.
   */
  optionsRequestedPolicyVersion?: number;
}

/**
 * Additional options for Compute#subnetworksInsert.
 */
export interface SubnetworksInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#subnetworksList.
 */
export interface SubnetworksListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#subnetworksListUsable.
 */
export interface SubnetworksListUsableOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#subnetworksPatch.
 */
export interface SubnetworksPatchOptions {
  /**
   * The drain timeout specifies the upper bound in seconds on the amount of
   * time allowed to drain connections from the current ACTIVE subnetwork to the
   * current BACKUP subnetwork. The drain timeout is only applicable when the
   * following conditions are true: - the subnetwork being patched has purpose =
   * INTERNAL_HTTPS_LOAD_BALANCER - the subnetwork being patched has role =
   * BACKUP - the patch request is setting the role to ACTIVE. Note that after
   * this patch operation the roles of the ACTIVE and BACKUP subnetworks will be
   * swapped.
   */
  drainTimeoutSeconds?: number;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface SubnetworksScopedList {
  /**
   * A list of subnetworks contained in this scope.
   */
  subnetworks?: Subnetwork[];
  /**
   * An informational warning that appears when the list of addresses is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeSubnetworksScopedList(data: any): SubnetworksScopedList {
  return {
    ...data,
    subnetworks: data["subnetworks"] !== undefined ? data["subnetworks"].map((item: any) => (serializeSubnetwork(item))) : undefined,
  };
}

function deserializeSubnetworksScopedList(data: any): SubnetworksScopedList {
  return {
    ...data,
    subnetworks: data["subnetworks"] !== undefined ? data["subnetworks"].map((item: any) => (deserializeSubnetwork(item))) : undefined,
  };
}

/**
 * Additional options for Compute#subnetworksSetPrivateIpGoogleAccess.
 */
export interface SubnetworksSetPrivateIpGoogleAccessOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface SubnetworksSetPrivateIpGoogleAccessRequest {
  privateIpGoogleAccess?: boolean;
}

/**
 * Subsetting configuration for this BackendService. Currently this is
 * applicable only for Internal TCP/UDP load balancing, Internal HTTP(S) load
 * balancing and Traffic Director.
 */
export interface Subsetting {
  policy?:  | "CONSISTENT_HASH_SUBSETTING" | "NONE";
}

/**
 * A set of instance tags.
 */
export interface Tags {
  /**
   * Specifies a fingerprint for this request, which is essentially a hash of
   * the tags' contents and used for optimistic locking. The fingerprint is
   * initially generated by Compute Engine and changes after every request to
   * modify or update tags. You must always provide an up-to-date fingerprint
   * hash in order to update or change tags. To see the latest fingerprint, make
   * get() request to the instance.
   */
  fingerprint?: Uint8Array;
  /**
   * An array of tags. Each tag must be 1-63 characters long, and comply with
   * RFC1035.
   */
  items?: string[];
}

function serializeTags(data: any): Tags {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
  };
}

function deserializeTags(data: any): Tags {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
  };
}

/**
 * Additional options for Compute#targetGrpcProxiesDelete.
 */
export interface TargetGrpcProxiesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#targetGrpcProxiesInsert.
 */
export interface TargetGrpcProxiesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#targetGrpcProxiesList.
 */
export interface TargetGrpcProxiesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#targetGrpcProxiesPatch.
 */
export interface TargetGrpcProxiesPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Represents a Target gRPC Proxy resource. A target gRPC proxy is a component
 * of load balancers intended for load balancing gRPC traffic. Only global
 * forwarding rules with load balancing scheme INTERNAL_SELF_MANAGED can
 * reference a target gRPC proxy. The target gRPC Proxy references a URL map
 * that specifies how traffic is routed to gRPC backend services.
 */
export interface TargetGrpcProxy {
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * Fingerprint of this resource. A hash of the contents stored in this
   * object. This field is used in optimistic locking. This field will be
   * ignored when inserting a TargetGrpcProxy. An up-to-date fingerprint must be
   * provided in order to patch/update the TargetGrpcProxy; otherwise, the
   * request will fail with error 412 conditionNotMet. To see the latest
   * fingerprint, make a get() request to retrieve the TargetGrpcProxy.
   */
  fingerprint?: Uint8Array;
  /**
   * [Output Only] The unique identifier for the resource type. The server
   * generates this identifier.
   */
  id?: bigint;
  /**
   * [Output Only] Type of the resource. Always compute#targetGrpcProxy for
   * target grpc proxies.
   */
  kind?: string;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Server-defined URL with id for the resource.
   */
  selfLinkWithId?: string;
  /**
   * URL to the UrlMap resource that defines the mapping from URL to the
   * BackendService. The protocol field in the BackendService must be set to
   * GRPC.
   */
  urlMap?: string;
  /**
   * If true, indicates that the BackendServices referenced by the urlMap may
   * be accessed by gRPC applications without using a sidecar proxy. This will
   * enable configuration checks on urlMap and its referenced BackendServices to
   * not allow unsupported features. A gRPC application must use "xds:///"
   * scheme in the target URI of the service it is connecting to. If false,
   * indicates that the BackendServices referenced by the urlMap will be
   * accessed by gRPC applications via a sidecar proxy. In this case, a gRPC
   * application must not use "xds:///" scheme in the target URI of the service
   * it is connecting to
   */
  validateForProxyless?: boolean;
}

function serializeTargetGrpcProxy(data: any): TargetGrpcProxy {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeTargetGrpcProxy(data: any): TargetGrpcProxy {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface TargetGrpcProxyList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of TargetGrpcProxy resources.
   */
  items?: TargetGrpcProxy[];
  /**
   * [Output Only] Type of the resource. Always compute#targetGrpcProxy for
   * target grpc proxies.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeTargetGrpcProxyList(data: any): TargetGrpcProxyList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeTargetGrpcProxy(item))) : undefined,
  };
}

function deserializeTargetGrpcProxyList(data: any): TargetGrpcProxyList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeTargetGrpcProxy(item))) : undefined,
  };
}

/**
 * Additional options for Compute#targetHttpProxiesAggregatedList.
 */
export interface TargetHttpProxiesAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#targetHttpProxiesDelete.
 */
export interface TargetHttpProxiesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#targetHttpProxiesInsert.
 */
export interface TargetHttpProxiesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#targetHttpProxiesList.
 */
export interface TargetHttpProxiesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#targetHttpProxiesPatch.
 */
export interface TargetHttpProxiesPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface TargetHttpProxiesScopedList {
  /**
   * A list of TargetHttpProxies contained in this scope.
   */
  targetHttpProxies?: TargetHttpProxy[];
  /**
   * Informational warning which replaces the list of backend services when the
   * list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeTargetHttpProxiesScopedList(data: any): TargetHttpProxiesScopedList {
  return {
    ...data,
    targetHttpProxies: data["targetHttpProxies"] !== undefined ? data["targetHttpProxies"].map((item: any) => (serializeTargetHttpProxy(item))) : undefined,
  };
}

function deserializeTargetHttpProxiesScopedList(data: any): TargetHttpProxiesScopedList {
  return {
    ...data,
    targetHttpProxies: data["targetHttpProxies"] !== undefined ? data["targetHttpProxies"].map((item: any) => (deserializeTargetHttpProxy(item))) : undefined,
  };
}

/**
 * Additional options for Compute#targetHttpProxiesSetUrlMap.
 */
export interface TargetHttpProxiesSetUrlMapOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Represents a Target HTTP Proxy resource. Google Compute Engine has two
 * Target HTTP Proxy resources: *
 * [Global](/compute/docs/reference/rest/v1/targetHttpProxies) *
 * [Regional](/compute/docs/reference/rest/v1/regionTargetHttpProxies) A target
 * HTTP proxy is a component of GCP HTTP load balancers. * targetHttpProxies are
 * used by external HTTP load balancers and Traffic Director. *
 * regionTargetHttpProxies are used by internal HTTP load balancers. Forwarding
 * rules reference a target HTTP proxy, and the target proxy then references a
 * URL map. For more information, read Using Target Proxies and Forwarding rule
 * concepts.
 */
export interface TargetHttpProxy {
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * Fingerprint of this resource. A hash of the contents stored in this
   * object. This field is used in optimistic locking. This field will be
   * ignored when inserting a TargetHttpProxy. An up-to-date fingerprint must be
   * provided in order to patch/update the TargetHttpProxy; otherwise, the
   * request will fail with error 412 conditionNotMet. To see the latest
   * fingerprint, make a get() request to retrieve the TargetHttpProxy.
   */
  fingerprint?: Uint8Array;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of resource. Always compute#targetHttpProxy for target
   * HTTP proxies.
   */
  kind?: string;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * This field only applies when the forwarding rule that references this
   * target proxy has a loadBalancingScheme set to INTERNAL_SELF_MANAGED. When
   * this field is set to true, Envoy proxies set up inbound traffic
   * interception and bind to the IP address and port specified in the
   * forwarding rule. This is generally useful when using Traffic Director to
   * configure Envoy as a gateway or middle proxy (in other words, not a sidecar
   * proxy). The Envoy proxy listens for inbound requests and handles requests
   * when it receives them. The default is false.
   */
  proxyBind?: boolean;
  /**
   * [Output Only] URL of the region where the regional Target HTTP Proxy
   * resides. This field is not applicable to global Target HTTP Proxies.
   */
  region?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * URL to the UrlMap resource that defines the mapping from URL to the
   * BackendService.
   */
  urlMap?: string;
}

function serializeTargetHttpProxy(data: any): TargetHttpProxy {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeTargetHttpProxy(data: any): TargetHttpProxy {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface TargetHttpProxyAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of TargetHttpProxiesScopedList resources.
   */
  items?: {
    [key: string]: TargetHttpProxiesScopedList
  };
  /**
   * [Output Only] Type of resource. Always
   * compute#targetHttpProxyAggregatedList for lists of Target HTTP Proxies.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
}

function serializeTargetHttpProxyAggregatedList(data: any): TargetHttpProxyAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeTargetHttpProxiesScopedList(v)]))) : undefined,
  };
}

function deserializeTargetHttpProxyAggregatedList(data: any): TargetHttpProxyAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeTargetHttpProxiesScopedList(v)]))) : undefined,
  };
}

/**
 * A list of TargetHttpProxy resources.
 */
export interface TargetHttpProxyList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of TargetHttpProxy resources.
   */
  items?: TargetHttpProxy[];
  /**
   * Type of resource. Always compute#targetHttpProxyList for lists of target
   * HTTP proxies.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeTargetHttpProxyList(data: any): TargetHttpProxyList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeTargetHttpProxy(item))) : undefined,
  };
}

function deserializeTargetHttpProxyList(data: any): TargetHttpProxyList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeTargetHttpProxy(item))) : undefined,
  };
}

/**
 * Additional options for Compute#targetHttpsProxiesAggregatedList.
 */
export interface TargetHttpsProxiesAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#targetHttpsProxiesDelete.
 */
export interface TargetHttpsProxiesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#targetHttpsProxiesInsert.
 */
export interface TargetHttpsProxiesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#targetHttpsProxiesList.
 */
export interface TargetHttpsProxiesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#targetHttpsProxiesPatch.
 */
export interface TargetHttpsProxiesPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface TargetHttpsProxiesScopedList {
  /**
   * A list of TargetHttpsProxies contained in this scope.
   */
  targetHttpsProxies?: TargetHttpsProxy[];
  /**
   * Informational warning which replaces the list of backend services when the
   * list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeTargetHttpsProxiesScopedList(data: any): TargetHttpsProxiesScopedList {
  return {
    ...data,
    targetHttpsProxies: data["targetHttpsProxies"] !== undefined ? data["targetHttpsProxies"].map((item: any) => (serializeTargetHttpsProxy(item))) : undefined,
  };
}

function deserializeTargetHttpsProxiesScopedList(data: any): TargetHttpsProxiesScopedList {
  return {
    ...data,
    targetHttpsProxies: data["targetHttpsProxies"] !== undefined ? data["targetHttpsProxies"].map((item: any) => (deserializeTargetHttpsProxy(item))) : undefined,
  };
}

/**
 * Additional options for Compute#targetHttpsProxiesSetCertificateMap.
 */
export interface TargetHttpsProxiesSetCertificateMapOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface TargetHttpsProxiesSetCertificateMapRequest {
  /**
   * URL of the Certificate Map to associate with this TargetHttpsProxy.
   */
  certificateMap?: string;
}

/**
 * Additional options for Compute#targetHttpsProxiesSetQuicOverride.
 */
export interface TargetHttpsProxiesSetQuicOverrideOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface TargetHttpsProxiesSetQuicOverrideRequest {
  /**
   * QUIC policy for the TargetHttpsProxy resource.
   */
  quicOverride?:  | "DISABLE" | "ENABLE" | "NONE";
}

/**
 * Additional options for Compute#targetHttpsProxiesSetSslCertificates.
 */
export interface TargetHttpsProxiesSetSslCertificatesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface TargetHttpsProxiesSetSslCertificatesRequest {
  /**
   * New set of SslCertificate resources to associate with this
   * TargetHttpsProxy resource. At least one SSL certificate must be specified.
   * Currently, you may specify up to 15 SSL certificates.
   */
  sslCertificates?: string[];
}

/**
 * Additional options for Compute#targetHttpsProxiesSetSslPolicy.
 */
export interface TargetHttpsProxiesSetSslPolicyOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#targetHttpsProxiesSetUrlMap.
 */
export interface TargetHttpsProxiesSetUrlMapOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Represents a Target HTTPS Proxy resource. Google Compute Engine has two
 * Target HTTPS Proxy resources: *
 * [Global](/compute/docs/reference/rest/v1/targetHttpsProxies) *
 * [Regional](/compute/docs/reference/rest/v1/regionTargetHttpsProxies) A target
 * HTTPS proxy is a component of GCP HTTPS load balancers. * targetHttpsProxies
 * are used by external HTTPS load balancers. * regionTargetHttpsProxies are
 * used by internal HTTPS load balancers. Forwarding rules reference a target
 * HTTPS proxy, and the target proxy then references a URL map. For more
 * information, read Using Target Proxies and Forwarding rule concepts.
 */
export interface TargetHttpsProxy {
  /**
   * Optional. A URL referring to a networksecurity.AuthorizationPolicy
   * resource that describes how the proxy should authorize inbound traffic. If
   * left blank, access will not be restricted by an authorization policy. Refer
   * to the AuthorizationPolicy resource for additional details.
   * authorizationPolicy only applies to a global TargetHttpsProxy attached to
   * globalForwardingRules with the loadBalancingScheme set to
   * INTERNAL_SELF_MANAGED. Note: This field currently has no impact.
   */
  authorizationPolicy?: string;
  /**
   * URL of a certificate map that identifies a certificate map associated with
   * the given target proxy. This field can only be set for global target
   * proxies. If set, sslCertificates will be ignored.
   */
  certificateMap?: string;
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * Fingerprint of this resource. A hash of the contents stored in this
   * object. This field is used in optimistic locking. This field will be
   * ignored when inserting a TargetHttpsProxy. An up-to-date fingerprint must
   * be provided in order to patch the TargetHttpsProxy; otherwise, the request
   * will fail with error 412 conditionNotMet. To see the latest fingerprint,
   * make a get() request to retrieve the TargetHttpsProxy.
   */
  fingerprint?: Uint8Array;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of resource. Always compute#targetHttpsProxy for target
   * HTTPS proxies.
   */
  kind?: string;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * This field only applies when the forwarding rule that references this
   * target proxy has a loadBalancingScheme set to INTERNAL_SELF_MANAGED. When
   * this field is set to true, Envoy proxies set up inbound traffic
   * interception and bind to the IP address and port specified in the
   * forwarding rule. This is generally useful when using Traffic Director to
   * configure Envoy as a gateway or middle proxy (in other words, not a sidecar
   * proxy). The Envoy proxy listens for inbound requests and handles requests
   * when it receives them. The default is false.
   */
  proxyBind?: boolean;
  /**
   * Specifies the QUIC override policy for this TargetHttpsProxy resource.
   * This setting determines whether the load balancer attempts to negotiate
   * QUIC with clients. You can specify NONE, ENABLE, or DISABLE. - When
   * quic-override is set to NONE, Google manages whether QUIC is used. - When
   * quic-override is set to ENABLE, the load balancer uses QUIC when possible.
   * - When quic-override is set to DISABLE, the load balancer doesn't use QUIC.
   * - If the quic-override flag is not specified, NONE is implied.
   */
  quicOverride?:  | "DISABLE" | "ENABLE" | "NONE";
  /**
   * [Output Only] URL of the region where the regional TargetHttpsProxy
   * resides. This field is not applicable to global TargetHttpsProxies.
   */
  region?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * Optional. A URL referring to a networksecurity.ServerTlsPolicy resource
   * that describes how the proxy should authenticate inbound traffic.
   * serverTlsPolicy only applies to a global TargetHttpsProxy attached to
   * globalForwardingRules with the loadBalancingScheme set to
   * INTERNAL_SELF_MANAGED. If left blank, communications are not encrypted.
   * Note: This field currently has no impact.
   */
  serverTlsPolicy?: string;
  /**
   * URLs to SslCertificate resources that are used to authenticate connections
   * between users and the load balancer. At least one SSL certificate must be
   * specified. Currently, you may specify up to 15 SSL certificates.
   * sslCertificates do not apply when the load balancing scheme is set to
   * INTERNAL_SELF_MANAGED.
   */
  sslCertificates?: string[];
  /**
   * URL of SslPolicy resource that will be associated with the
   * TargetHttpsProxy resource. If not set, the TargetHttpsProxy resource has no
   * SSL policy configured.
   */
  sslPolicy?: string;
  /**
   * A fully-qualified or valid partial URL to the UrlMap resource that defines
   * the mapping from URL to the BackendService. For example, the following are
   * all valid URLs for specifying a URL map: -
   * https://www.googleapis.compute/v1/projects/project/global/urlMaps/ url-map
   * - projects/project/global/urlMaps/url-map - global/urlMaps/url-map
   */
  urlMap?: string;
}

function serializeTargetHttpsProxy(data: any): TargetHttpsProxy {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeTargetHttpsProxy(data: any): TargetHttpsProxy {
  return {
    ...data,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface TargetHttpsProxyAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of TargetHttpsProxiesScopedList resources.
   */
  items?: {
    [key: string]: TargetHttpsProxiesScopedList
  };
  /**
   * [Output Only] Type of resource. Always
   * compute#targetHttpsProxyAggregatedList for lists of Target HTTP Proxies.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeTargetHttpsProxyAggregatedList(data: any): TargetHttpsProxyAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeTargetHttpsProxiesScopedList(v)]))) : undefined,
  };
}

function deserializeTargetHttpsProxyAggregatedList(data: any): TargetHttpsProxyAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeTargetHttpsProxiesScopedList(v)]))) : undefined,
  };
}

/**
 * Contains a list of TargetHttpsProxy resources.
 */
export interface TargetHttpsProxyList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of TargetHttpsProxy resources.
   */
  items?: TargetHttpsProxy[];
  /**
   * Type of resource. Always compute#targetHttpsProxyList for lists of target
   * HTTPS proxies.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeTargetHttpsProxyList(data: any): TargetHttpsProxyList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeTargetHttpsProxy(item))) : undefined,
  };
}

function deserializeTargetHttpsProxyList(data: any): TargetHttpsProxyList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeTargetHttpsProxy(item))) : undefined,
  };
}

/**
 * Represents a Target Instance resource. You can use a target instance to
 * handle traffic for one or more forwarding rules, which is ideal for
 * forwarding protocol traffic that is managed by a single source. For example,
 * ESP, AH, TCP, or UDP. For more information, read Target instances.
 */
export interface TargetInstance {
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * A URL to the virtual machine instance that handles traffic for this target
   * instance. When creating a target instance, you can provide the
   * fully-qualified URL or a valid partial URL to the desired virtual machine.
   * For example, the following are all valid URLs: -
   * https://www.googleapis.com/compute/v1/projects/project/zones/zone
   * /instances/instance - projects/project/zones/zone/instances/instance -
   * zones/zone/instances/instance
   */
  instance?: string;
  /**
   * [Output Only] The type of the resource. Always compute#targetInstance for
   * target instances.
   */
  kind?: string;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * Must have a value of NO_NAT. Protocol forwarding delivers packets while
   * preserving the destination IP address of the forwarding rule referencing
   * the target instance.
   */
  natPolicy?:  | "NO_NAT";
  /**
   * The URL of the network this target instance uses to forward traffic. If
   * not specified, the traffic will be forwarded to the network that the
   * default network interface belongs to.
   */
  network?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * [Output Only] URL of the zone where the target instance resides. You must
   * specify this field as part of the HTTP request URL. It is not settable as a
   * field in the request body.
   */
  zone?: string;
}

function serializeTargetInstance(data: any): TargetInstance {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeTargetInstance(data: any): TargetInstance {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface TargetInstanceAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of TargetInstance resources.
   */
  items?: {
    [key: string]: TargetInstancesScopedList
  };
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeTargetInstanceAggregatedList(data: any): TargetInstanceAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeTargetInstancesScopedList(v)]))) : undefined,
  };
}

function deserializeTargetInstanceAggregatedList(data: any): TargetInstanceAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeTargetInstancesScopedList(v)]))) : undefined,
  };
}

/**
 * Contains a list of TargetInstance resources.
 */
export interface TargetInstanceList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of TargetInstance resources.
   */
  items?: TargetInstance[];
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeTargetInstanceList(data: any): TargetInstanceList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeTargetInstance(item))) : undefined,
  };
}

function deserializeTargetInstanceList(data: any): TargetInstanceList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeTargetInstance(item))) : undefined,
  };
}

/**
 * Additional options for Compute#targetInstancesAggregatedList.
 */
export interface TargetInstancesAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#targetInstancesDelete.
 */
export interface TargetInstancesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#targetInstancesInsert.
 */
export interface TargetInstancesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#targetInstancesList.
 */
export interface TargetInstancesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface TargetInstancesScopedList {
  /**
   * A list of target instances contained in this scope.
   */
  targetInstances?: TargetInstance[];
  /**
   * Informational warning which replaces the list of addresses when the list
   * is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeTargetInstancesScopedList(data: any): TargetInstancesScopedList {
  return {
    ...data,
    targetInstances: data["targetInstances"] !== undefined ? data["targetInstances"].map((item: any) => (serializeTargetInstance(item))) : undefined,
  };
}

function deserializeTargetInstancesScopedList(data: any): TargetInstancesScopedList {
  return {
    ...data,
    targetInstances: data["targetInstances"] !== undefined ? data["targetInstances"].map((item: any) => (deserializeTargetInstance(item))) : undefined,
  };
}

/**
 * Represents a Target Pool resource. Target pools are used for network TCP/UDP
 * load balancing. A target pool references member instances, an associated
 * legacy HttpHealthCheck resource, and, optionally, a backup target pool. For
 * more information, read Using target pools.
 */
export interface TargetPool {
  /**
   * The server-defined URL for the resource. This field is applicable only
   * when the containing target pool is serving a forwarding rule as the primary
   * pool, and its failoverRatio field is properly set to a value between [0,
   * 1]. backupPool and failoverRatio together define the fallback behavior of
   * the primary target pool: if the ratio of the healthy instances in the
   * primary pool is at or below failoverRatio, traffic arriving at the
   * load-balanced IP will be directed to the backup pool. In case where
   * failoverRatio and backupPool are not set, or all the instances in the
   * backup pool are unhealthy, the traffic will be directed back to the primary
   * pool in the "force" mode, where traffic will be spread to the healthy
   * instances with the best effort, or to all instances when no instance is
   * healthy.
   */
  backupPool?: string;
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * This field is applicable only when the containing target pool is serving a
   * forwarding rule as the primary pool (i.e., not as a backup pool to some
   * other target pool). The value of the field must be in [0, 1]. If set,
   * backupPool must also be set. They together define the fallback behavior of
   * the primary target pool: if the ratio of the healthy instances in the
   * primary pool is at or below this number, traffic arriving at the
   * load-balanced IP will be directed to the backup pool. In case where
   * failoverRatio is not set or all the instances in the backup pool are
   * unhealthy, the traffic will be directed back to the primary pool in the
   * "force" mode, where traffic will be spread to the healthy instances with
   * the best effort, or to all instances when no instance is healthy.
   */
  failoverRatio?: number;
  /**
   * The URL of the HttpHealthCheck resource. A member instance in this pool is
   * considered healthy if and only if the health checks pass. Only legacy
   * HttpHealthChecks are supported. Only one health check may be specified.
   */
  healthChecks?: string[];
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * A list of resource URLs to the virtual machine instances serving this
   * pool. They must live in zones contained in the same region as this pool.
   */
  instances?: string[];
  /**
   * [Output Only] Type of the resource. Always compute#targetPool for target
   * pools.
   */
  kind?: string;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * [Output Only] URL of the region where the target pool resides.
   */
  region?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * Session affinity option, must be one of the following values: NONE:
   * Connections from the same client IP may go to any instance in the pool.
   * CLIENT_IP: Connections from the same client IP will go to the same instance
   * in the pool while that instance remains healthy. CLIENT_IP_PROTO:
   * Connections from the same client IP with the same IP protocol will go to
   * the same instance in the pool while that instance remains healthy.
   */
  sessionAffinity?:  | "CLIENT_IP" | "CLIENT_IP_NO_DESTINATION" | "CLIENT_IP_PORT_PROTO" | "CLIENT_IP_PROTO" | "GENERATED_COOKIE" | "HEADER_FIELD" | "HTTP_COOKIE" | "NONE";
}

function serializeTargetPool(data: any): TargetPool {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeTargetPool(data: any): TargetPool {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface TargetPoolAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of TargetPool resources.
   */
  items?: {
    [key: string]: TargetPoolsScopedList
  };
  /**
   * [Output Only] Type of resource. Always compute#targetPoolAggregatedList
   * for aggregated lists of target pools.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeTargetPoolAggregatedList(data: any): TargetPoolAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeTargetPoolsScopedList(v)]))) : undefined,
  };
}

function deserializeTargetPoolAggregatedList(data: any): TargetPoolAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeTargetPoolsScopedList(v)]))) : undefined,
  };
}

export interface TargetPoolInstanceHealth {
  healthStatus?: HealthStatus[];
  /**
   * [Output Only] Type of resource. Always compute#targetPoolInstanceHealth
   * when checking the health of an instance.
   */
  kind?: string;
}

/**
 * Contains a list of TargetPool resources.
 */
export interface TargetPoolList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of TargetPool resources.
   */
  items?: TargetPool[];
  /**
   * [Output Only] Type of resource. Always compute#targetPoolList for lists of
   * target pools.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeTargetPoolList(data: any): TargetPoolList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeTargetPool(item))) : undefined,
  };
}

function deserializeTargetPoolList(data: any): TargetPoolList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeTargetPool(item))) : undefined,
  };
}

/**
 * Additional options for Compute#targetPoolsAddHealthCheck.
 */
export interface TargetPoolsAddHealthCheckOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface TargetPoolsAddHealthCheckRequest {
  /**
   * The HttpHealthCheck to add to the target pool.
   */
  healthChecks?: HealthCheckReference[];
}

/**
 * Additional options for Compute#targetPoolsAddInstance.
 */
export interface TargetPoolsAddInstanceOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface TargetPoolsAddInstanceRequest {
  /**
   * A full or partial URL to an instance to add to this target pool. This can
   * be a full or partial URL. For example, the following are valid URLs: -
   * https://www.googleapis.com/compute/v1/projects/project-id/zones/zone
   * /instances/instance-name -
   * projects/project-id/zones/zone/instances/instance-name -
   * zones/zone/instances/instance-name
   */
  instances?: InstanceReference[];
}

/**
 * Additional options for Compute#targetPoolsAggregatedList.
 */
export interface TargetPoolsAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#targetPoolsDelete.
 */
export interface TargetPoolsDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#targetPoolsInsert.
 */
export interface TargetPoolsInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#targetPoolsList.
 */
export interface TargetPoolsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#targetPoolsRemoveHealthCheck.
 */
export interface TargetPoolsRemoveHealthCheckOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface TargetPoolsRemoveHealthCheckRequest {
  /**
   * Health check URL to be removed. This can be a full or valid partial URL.
   * For example, the following are valid URLs: -
   * https://www.googleapis.com/compute/beta/projects/project
   * /global/httpHealthChecks/health-check -
   * projects/project/global/httpHealthChecks/health-check -
   * global/httpHealthChecks/health-check
   */
  healthChecks?: HealthCheckReference[];
}

/**
 * Additional options for Compute#targetPoolsRemoveInstance.
 */
export interface TargetPoolsRemoveInstanceOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface TargetPoolsRemoveInstanceRequest {
  /**
   * URLs of the instances to be removed from target pool.
   */
  instances?: InstanceReference[];
}

export interface TargetPoolsScopedList {
  /**
   * A list of target pools contained in this scope.
   */
  targetPools?: TargetPool[];
  /**
   * Informational warning which replaces the list of addresses when the list
   * is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeTargetPoolsScopedList(data: any): TargetPoolsScopedList {
  return {
    ...data,
    targetPools: data["targetPools"] !== undefined ? data["targetPools"].map((item: any) => (serializeTargetPool(item))) : undefined,
  };
}

function deserializeTargetPoolsScopedList(data: any): TargetPoolsScopedList {
  return {
    ...data,
    targetPools: data["targetPools"] !== undefined ? data["targetPools"].map((item: any) => (deserializeTargetPool(item))) : undefined,
  };
}

/**
 * Additional options for Compute#targetPoolsSetBackup.
 */
export interface TargetPoolsSetBackupOptions {
  /**
   * New failoverRatio value for the target pool.
   */
  failoverRatio?: number;
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface TargetReference {
  target?: string;
}

/**
 * Additional options for Compute#targetSslProxiesDelete.
 */
export interface TargetSslProxiesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#targetSslProxiesInsert.
 */
export interface TargetSslProxiesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#targetSslProxiesList.
 */
export interface TargetSslProxiesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#targetSslProxiesSetBackendService.
 */
export interface TargetSslProxiesSetBackendServiceOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface TargetSslProxiesSetBackendServiceRequest {
  /**
   * The URL of the new BackendService resource for the targetSslProxy.
   */
  service?: string;
}

/**
 * Additional options for Compute#targetSslProxiesSetCertificateMap.
 */
export interface TargetSslProxiesSetCertificateMapOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface TargetSslProxiesSetCertificateMapRequest {
  /**
   * URL of the Certificate Map to associate with this TargetSslProxy.
   */
  certificateMap?: string;
}

/**
 * Additional options for Compute#targetSslProxiesSetProxyHeader.
 */
export interface TargetSslProxiesSetProxyHeaderOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface TargetSslProxiesSetProxyHeaderRequest {
  /**
   * The new type of proxy header to append before sending data to the backend.
   * NONE or PROXY_V1 are allowed.
   */
  proxyHeader?:  | "NONE" | "PROXY_V1";
}

/**
 * Additional options for Compute#targetSslProxiesSetSslCertificates.
 */
export interface TargetSslProxiesSetSslCertificatesOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface TargetSslProxiesSetSslCertificatesRequest {
  /**
   * New set of URLs to SslCertificate resources to associate with this
   * TargetSslProxy. At least one SSL certificate must be specified. Currently,
   * you may specify up to 15 SSL certificates.
   */
  sslCertificates?: string[];
}

/**
 * Additional options for Compute#targetSslProxiesSetSslPolicy.
 */
export interface TargetSslProxiesSetSslPolicyOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Represents a Target SSL Proxy resource. A target SSL proxy is a component of
 * a SSL Proxy load balancer. Global forwarding rules reference a target SSL
 * proxy, and the target proxy then references an external backend service. For
 * more information, read Using Target Proxies.
 */
export interface TargetSslProxy {
  /**
   * URL of a certificate map that identifies a certificate map associated with
   * the given target proxy. This field can only be set for global target
   * proxies. If set, sslCertificates will be ignored.
   */
  certificateMap?: string;
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of the resource. Always compute#targetSslProxy for
   * target SSL proxies.
   */
  kind?: string;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * Specifies the type of proxy header to append before sending data to the
   * backend, either NONE or PROXY_V1. The default is NONE.
   */
  proxyHeader?:  | "NONE" | "PROXY_V1";
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * URL to the BackendService resource.
   */
  service?: string;
  /**
   * URLs to SslCertificate resources that are used to authenticate connections
   * to Backends. At least one SSL certificate must be specified. Currently, you
   * may specify up to 15 SSL certificates. sslCertificates do not apply when
   * the load balancing scheme is set to INTERNAL_SELF_MANAGED.
   */
  sslCertificates?: string[];
  /**
   * URL of SslPolicy resource that will be associated with the TargetSslProxy
   * resource. If not set, the TargetSslProxy resource will not have any SSL
   * policy configured.
   */
  sslPolicy?: string;
}

function serializeTargetSslProxy(data: any): TargetSslProxy {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeTargetSslProxy(data: any): TargetSslProxy {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

/**
 * Contains a list of TargetSslProxy resources.
 */
export interface TargetSslProxyList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of TargetSslProxy resources.
   */
  items?: TargetSslProxy[];
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeTargetSslProxyList(data: any): TargetSslProxyList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeTargetSslProxy(item))) : undefined,
  };
}

function deserializeTargetSslProxyList(data: any): TargetSslProxyList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeTargetSslProxy(item))) : undefined,
  };
}

/**
 * Additional options for Compute#targetTcpProxiesAggregatedList.
 */
export interface TargetTcpProxiesAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#targetTcpProxiesDelete.
 */
export interface TargetTcpProxiesDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#targetTcpProxiesInsert.
 */
export interface TargetTcpProxiesInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#targetTcpProxiesList.
 */
export interface TargetTcpProxiesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface TargetTcpProxiesScopedList {
  /**
   * A list of TargetTcpProxies contained in this scope.
   */
  targetTcpProxies?: TargetTcpProxy[];
  /**
   * Informational warning which replaces the list of backend services when the
   * list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeTargetTcpProxiesScopedList(data: any): TargetTcpProxiesScopedList {
  return {
    ...data,
    targetTcpProxies: data["targetTcpProxies"] !== undefined ? data["targetTcpProxies"].map((item: any) => (serializeTargetTcpProxy(item))) : undefined,
  };
}

function deserializeTargetTcpProxiesScopedList(data: any): TargetTcpProxiesScopedList {
  return {
    ...data,
    targetTcpProxies: data["targetTcpProxies"] !== undefined ? data["targetTcpProxies"].map((item: any) => (deserializeTargetTcpProxy(item))) : undefined,
  };
}

/**
 * Additional options for Compute#targetTcpProxiesSetBackendService.
 */
export interface TargetTcpProxiesSetBackendServiceOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface TargetTcpProxiesSetBackendServiceRequest {
  /**
   * The URL of the new BackendService resource for the targetTcpProxy.
   */
  service?: string;
}

/**
 * Additional options for Compute#targetTcpProxiesSetProxyHeader.
 */
export interface TargetTcpProxiesSetProxyHeaderOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface TargetTcpProxiesSetProxyHeaderRequest {
  /**
   * The new type of proxy header to append before sending data to the backend.
   * NONE or PROXY_V1 are allowed.
   */
  proxyHeader?:  | "NONE" | "PROXY_V1";
}

/**
 * Represents a Target TCP Proxy resource. A target TCP proxy is a component of
 * a TCP Proxy load balancer. Global forwarding rules reference target TCP
 * proxy, and the target proxy then references an external backend service. For
 * more information, read TCP Proxy Load Balancing overview.
 */
export interface TargetTcpProxy {
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of the resource. Always compute#targetTcpProxy for
   * target TCP proxies.
   */
  kind?: string;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * This field only applies when the forwarding rule that references this
   * target proxy has a loadBalancingScheme set to INTERNAL_SELF_MANAGED. When
   * this field is set to true, Envoy proxies set up inbound traffic
   * interception and bind to the IP address and port specified in the
   * forwarding rule. This is generally useful when using Traffic Director to
   * configure Envoy as a gateway or middle proxy (in other words, not a sidecar
   * proxy). The Envoy proxy listens for inbound requests and handles requests
   * when it receives them. The default is false.
   */
  proxyBind?: boolean;
  /**
   * Specifies the type of proxy header to append before sending data to the
   * backend, either NONE or PROXY_V1. The default is NONE.
   */
  proxyHeader?:  | "NONE" | "PROXY_V1";
  /**
   * [Output Only] URL of the region where the regional TCP proxy resides. This
   * field is not applicable to global TCP proxy.
   */
  region?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * URL to the BackendService resource.
   */
  service?: string;
}

function serializeTargetTcpProxy(data: any): TargetTcpProxy {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeTargetTcpProxy(data: any): TargetTcpProxy {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface TargetTcpProxyAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of TargetTcpProxiesScopedList resources.
   */
  items?: {
    [key: string]: TargetTcpProxiesScopedList
  };
  /**
   * [Output Only] Type of resource. Always
   * compute#targetTcpProxyAggregatedList for lists of Target TCP Proxies.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeTargetTcpProxyAggregatedList(data: any): TargetTcpProxyAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeTargetTcpProxiesScopedList(v)]))) : undefined,
  };
}

function deserializeTargetTcpProxyAggregatedList(data: any): TargetTcpProxyAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeTargetTcpProxiesScopedList(v)]))) : undefined,
  };
}

/**
 * Contains a list of TargetTcpProxy resources.
 */
export interface TargetTcpProxyList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of TargetTcpProxy resources.
   */
  items?: TargetTcpProxy[];
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeTargetTcpProxyList(data: any): TargetTcpProxyList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeTargetTcpProxy(item))) : undefined,
  };
}

function deserializeTargetTcpProxyList(data: any): TargetTcpProxyList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeTargetTcpProxy(item))) : undefined,
  };
}

/**
 * Represents a Target VPN Gateway resource. The target VPN gateway resource
 * represents a Classic Cloud VPN gateway. For more information, read the the
 * Cloud VPN Overview.
 */
export interface TargetVpnGateway {
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * [Output Only] A list of URLs to the ForwardingRule resources.
   * ForwardingRules are created using compute.forwardingRules.insert and
   * associated with a VPN gateway.
   */
  forwardingRules?: string[];
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of resource. Always compute#targetVpnGateway for target
   * VPN gateways.
   */
  kind?: string;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * URL of the network to which this VPN gateway is attached. Provided by the
   * client when the VPN gateway is created.
   */
  network?: string;
  /**
   * [Output Only] URL of the region where the target VPN gateway resides. You
   * must specify this field as part of the HTTP request URL. It is not settable
   * as a field in the request body.
   */
  region?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * [Output Only] The status of the VPN gateway, which can be one of the
   * following: CREATING, READY, FAILED, or DELETING.
   */
  status?:  | "CREATING" | "DELETING" | "FAILED" | "READY";
  /**
   * [Output Only] A list of URLs to VpnTunnel resources. VpnTunnels are
   * created using the compute.vpntunnels.insert method and associated with a
   * VPN gateway.
   */
  tunnels?: string[];
}

function serializeTargetVpnGateway(data: any): TargetVpnGateway {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeTargetVpnGateway(data: any): TargetVpnGateway {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface TargetVpnGatewayAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of TargetVpnGateway resources.
   */
  items?: {
    [key: string]: TargetVpnGatewaysScopedList
  };
  /**
   * [Output Only] Type of resource. Always compute#targetVpnGateway for target
   * VPN gateways.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeTargetVpnGatewayAggregatedList(data: any): TargetVpnGatewayAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeTargetVpnGatewaysScopedList(v)]))) : undefined,
  };
}

function deserializeTargetVpnGatewayAggregatedList(data: any): TargetVpnGatewayAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeTargetVpnGatewaysScopedList(v)]))) : undefined,
  };
}

/**
 * Contains a list of TargetVpnGateway resources.
 */
export interface TargetVpnGatewayList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of TargetVpnGateway resources.
   */
  items?: TargetVpnGateway[];
  /**
   * [Output Only] Type of resource. Always compute#targetVpnGateway for target
   * VPN gateways.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeTargetVpnGatewayList(data: any): TargetVpnGatewayList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeTargetVpnGateway(item))) : undefined,
  };
}

function deserializeTargetVpnGatewayList(data: any): TargetVpnGatewayList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeTargetVpnGateway(item))) : undefined,
  };
}

/**
 * Additional options for Compute#targetVpnGatewaysAggregatedList.
 */
export interface TargetVpnGatewaysAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#targetVpnGatewaysDelete.
 */
export interface TargetVpnGatewaysDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#targetVpnGatewaysInsert.
 */
export interface TargetVpnGatewaysInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#targetVpnGatewaysList.
 */
export interface TargetVpnGatewaysListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface TargetVpnGatewaysScopedList {
  /**
   * [Output Only] A list of target VPN gateways contained in this scope.
   */
  targetVpnGateways?: TargetVpnGateway[];
  /**
   * [Output Only] Informational warning which replaces the list of addresses
   * when the list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeTargetVpnGatewaysScopedList(data: any): TargetVpnGatewaysScopedList {
  return {
    ...data,
    targetVpnGateways: data["targetVpnGateways"] !== undefined ? data["targetVpnGateways"].map((item: any) => (serializeTargetVpnGateway(item))) : undefined,
  };
}

function deserializeTargetVpnGatewaysScopedList(data: any): TargetVpnGatewaysScopedList {
  return {
    ...data,
    targetVpnGateways: data["targetVpnGateways"] !== undefined ? data["targetVpnGateways"].map((item: any) => (deserializeTargetVpnGateway(item))) : undefined,
  };
}

/**
 * Additional options for Compute#targetVpnGatewaysSetLabels.
 */
export interface TargetVpnGatewaysSetLabelsOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface TCPHealthCheck {
  /**
   * The TCP port number to which the health check prober sends packets. The
   * default value is 80. Valid values are 1 through 65535.
   */
  port?: number;
  /**
   * Not supported.
   */
  portName?: string;
  /**
   * Specifies how a port is selected for health checking. Can be one of the
   * following values: USE_FIXED_PORT: Specifies a port number explicitly using
   * the port field in the health check. Supported by backend services for
   * pass-through load balancers and backend services for proxy load balancers.
   * Not supported by target pools. The health check supports all backends
   * supported by the backend service provided the backend can be health
   * checked. For example, GCE_VM_IP network endpoint groups, GCE_VM_IP_PORT
   * network endpoint groups, and instance group backends. USE_NAMED_PORT: Not
   * supported. USE_SERVING_PORT: Provides an indirect method of specifying the
   * health check port by referring to the backend service. Only supported by
   * backend services for proxy load balancers. Not supported by target pools.
   * Not supported by backend services for pass-through load balancers. Supports
   * all backends that can be health checked; for example, GCE_VM_IP_PORT
   * network endpoint groups and instance group backends. For GCE_VM_IP_PORT
   * network endpoint group backends, the health check uses the port number
   * specified for each endpoint in the network endpoint group. For instance
   * group backends, the health check uses the port number determined by looking
   * up the backend service's named port in the instance group's list of named
   * ports.
   */
  portSpecification?:  | "USE_FIXED_PORT" | "USE_NAMED_PORT" | "USE_SERVING_PORT";
  /**
   * Specifies the type of proxy header to append before sending data to the
   * backend, either NONE or PROXY_V1. The default is NONE.
   */
  proxyHeader?:  | "NONE" | "PROXY_V1";
  /**
   * Instructs the health check prober to send this exact ASCII string, up to
   * 1024 bytes in length, after establishing the TCP connection.
   */
  request?: string;
  /**
   * Creates a content-based TCP health check. In addition to establishing a
   * TCP connection, you can configure the health check to pass only when the
   * backend sends this exact response ASCII string, up to 1024 bytes in length.
   * For details, see:
   * https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-ssl-tcp
   */
  response?: string;
}

export interface TestFailure {
  /**
   * The actual output URL evaluated by a load balancer containing the scheme,
   * host, path and query parameters.
   */
  actualOutputUrl?: string;
  /**
   * Actual HTTP status code for rule with `urlRedirect` calculated by load
   * balancer
   */
  actualRedirectResponseCode?: number;
  /**
   * BackendService or BackendBucket returned by load balancer.
   */
  actualService?: string;
  /**
   * The expected output URL evaluated by a load balancer containing the
   * scheme, host, path and query parameters.
   */
  expectedOutputUrl?: string;
  /**
   * Expected HTTP status code for rule with `urlRedirect` calculated by load
   * balancer
   */
  expectedRedirectResponseCode?: number;
  /**
   * Expected BackendService or BackendBucket resource the given URL should be
   * mapped to.
   */
  expectedService?: string;
  /**
   * HTTP headers of the request.
   */
  headers?: UrlMapTestHeader[];
  /**
   * Host portion of the URL.
   */
  host?: string;
  /**
   * Path portion including query parameters in the URL.
   */
  path?: string;
}

export interface TestPermissionsRequest {
  /**
   * The set of permissions to check for the 'resource'. Permissions with
   * wildcards (such as '*' or 'storage.*') are not allowed.
   */
  permissions?: string[];
}

export interface TestPermissionsResponse {
  /**
   * A subset of `TestPermissionsRequest.permissions` that the caller is
   * allowed.
   */
  permissions?: string[];
}

export interface Uint128 {
  high?: bigint;
  low?: bigint;
}

function serializeUint128(data: any): Uint128 {
  return {
    ...data,
    high: data["high"] !== undefined ? String(data["high"]) : undefined,
    low: data["low"] !== undefined ? String(data["low"]) : undefined,
  };
}

function deserializeUint128(data: any): Uint128 {
  return {
    ...data,
    high: data["high"] !== undefined ? BigInt(data["high"]) : undefined,
    low: data["low"] !== undefined ? BigInt(data["low"]) : undefined,
  };
}

/**
 * Represents a URL Map resource. Compute Engine has two URL Map resources: *
 * [Global](/compute/docs/reference/rest/v1/urlMaps) *
 * [Regional](/compute/docs/reference/rest/v1/regionUrlMaps) A URL map resource
 * is a component of certain types of cloud load balancers and Traffic Director:
 * * urlMaps are used by external HTTP(S) load balancers and Traffic Director. *
 * regionUrlMaps are used by internal HTTP(S) load balancers. For a list of
 * supported URL map features by the load balancer type, see the Load balancing
 * features: Routing and traffic management table. For a list of supported URL
 * map features for Traffic Director, see the Traffic Director features: Routing
 * and traffic management table. This resource defines mappings from hostnames
 * and URL paths to either a backend service or a backend bucket. To use the
 * global urlMaps resource, the backend service must have a loadBalancingScheme
 * of either EXTERNAL or INTERNAL_SELF_MANAGED. To use the regionUrlMaps
 * resource, the backend service must have a loadBalancingScheme of
 * INTERNAL_MANAGED. For more information, read URL Map Concepts.
 */
export interface UrlMap {
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * defaultRouteAction takes effect when none of the hostRules match. The load
   * balancer performs advanced routing actions, such as URL rewrites and header
   * transformations, before forwarding the request to the selected backend. If
   * defaultRouteAction specifies any weightedBackendServices, defaultService
   * must not be set. Conversely if defaultService is set, defaultRouteAction
   * cannot contain any weightedBackendServices. Only one of defaultRouteAction
   * or defaultUrlRedirect must be set. URL maps for Classic external HTTP(S)
   * load balancers only support the urlRewrite action within
   * defaultRouteAction. defaultRouteAction has no effect when the URL map is
   * bound to a target gRPC proxy that has the validateForProxyless field set to
   * true.
   */
  defaultRouteAction?: HttpRouteAction;
  /**
   * The full or partial URL of the defaultService resource to which traffic is
   * directed if none of the hostRules match. If defaultRouteAction is also
   * specified, advanced routing actions, such as URL rewrites, take effect
   * before sending the request to the backend. However, if defaultService is
   * specified, defaultRouteAction cannot contain any weightedBackendServices.
   * Conversely, if routeAction specifies any weightedBackendServices, service
   * must not be specified. Only one of defaultService, defaultUrlRedirect , or
   * defaultRouteAction.weightedBackendService must be set. defaultService has
   * no effect when the URL map is bound to a target gRPC proxy that has the
   * validateForProxyless field set to true.
   */
  defaultService?: string;
  /**
   * When none of the specified hostRules match, the request is redirected to a
   * URL specified by defaultUrlRedirect. If defaultUrlRedirect is specified,
   * defaultService or defaultRouteAction must not be set. Not supported when
   * the URL map is bound to a target gRPC proxy.
   */
  defaultUrlRedirect?: HttpRedirectAction;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * Fingerprint of this resource. A hash of the contents stored in this
   * object. This field is used in optimistic locking. This field is ignored
   * when inserting a UrlMap. An up-to-date fingerprint must be provided in
   * order to update the UrlMap, otherwise the request will fail with error 412
   * conditionNotMet. To see the latest fingerprint, make a get() request to
   * retrieve a UrlMap.
   */
  fingerprint?: Uint8Array;
  /**
   * Specifies changes to request and response headers that need to take effect
   * for the selected backendService. The headerAction specified here take
   * effect after headerAction specified under pathMatcher. headerAction is not
   * supported for load balancers that have their loadBalancingScheme set to
   * EXTERNAL. Not supported when the URL map is bound to a target gRPC proxy
   * that has validateForProxyless field set to true.
   */
  headerAction?: HttpHeaderAction;
  /**
   * The list of host rules to use against the URL.
   */
  hostRules?: HostRule[];
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of the resource. Always compute#urlMaps for url maps.
   */
  kind?: string;
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * The list of named PathMatchers to use against the URL.
   */
  pathMatchers?: PathMatcher[];
  /**
   * [Output Only] URL of the region where the regional URL map resides. This
   * field is not applicable to global URL maps. You must specify this field as
   * part of the HTTP request URL. It is not settable as a field in the request
   * body.
   */
  region?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * The list of expected URL mapping tests. Request to update the UrlMap
   * succeeds only if all test cases pass. You can specify a maximum of 100
   * tests per UrlMap. Not supported when the URL map is bound to a target gRPC
   * proxy that has validateForProxyless field set to true.
   */
  tests?: UrlMapTest[];
}

function serializeUrlMap(data: any): UrlMap {
  return {
    ...data,
    defaultRouteAction: data["defaultRouteAction"] !== undefined ? serializeHttpRouteAction(data["defaultRouteAction"]) : undefined,
    fingerprint: data["fingerprint"] !== undefined ? encodeBase64(data["fingerprint"]) : undefined,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
    pathMatchers: data["pathMatchers"] !== undefined ? data["pathMatchers"].map((item: any) => (serializePathMatcher(item))) : undefined,
  };
}

function deserializeUrlMap(data: any): UrlMap {
  return {
    ...data,
    defaultRouteAction: data["defaultRouteAction"] !== undefined ? deserializeHttpRouteAction(data["defaultRouteAction"]) : undefined,
    fingerprint: data["fingerprint"] !== undefined ? decodeBase64(data["fingerprint"] as string) : undefined,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
    pathMatchers: data["pathMatchers"] !== undefined ? data["pathMatchers"].map((item: any) => (deserializePathMatcher(item))) : undefined,
  };
}

/**
 * Contains a list of UrlMap resources.
 */
export interface UrlMapList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of UrlMap resources.
   */
  items?: UrlMap[];
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeUrlMapList(data: any): UrlMapList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeUrlMap(item))) : undefined,
  };
}

function deserializeUrlMapList(data: any): UrlMapList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeUrlMap(item))) : undefined,
  };
}

export interface UrlMapReference {
  urlMap?: string;
}

export interface UrlMapsAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of UrlMapsScopedList resources.
   */
  items?: {
    [key: string]: UrlMapsScopedList
  };
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeUrlMapsAggregatedList(data: any): UrlMapsAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeUrlMapsScopedList(v)]))) : undefined,
  };
}

function deserializeUrlMapsAggregatedList(data: any): UrlMapsAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeUrlMapsScopedList(v)]))) : undefined,
  };
}

/**
 * Additional options for Compute#urlMapsAggregatedList.
 */
export interface UrlMapsAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#urlMapsDelete.
 */
export interface UrlMapsDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#urlMapsInsert.
 */
export interface UrlMapsInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#urlMapsInvalidateCache.
 */
export interface UrlMapsInvalidateCacheOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#urlMapsList.
 */
export interface UrlMapsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#urlMapsPatch.
 */
export interface UrlMapsPatchOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface UrlMapsScopedList {
  /**
   * A list of UrlMaps contained in this scope.
   */
  urlMaps?: UrlMap[];
  /**
   * Informational warning which replaces the list of backend services when the
   * list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeUrlMapsScopedList(data: any): UrlMapsScopedList {
  return {
    ...data,
    urlMaps: data["urlMaps"] !== undefined ? data["urlMaps"].map((item: any) => (serializeUrlMap(item))) : undefined,
  };
}

function deserializeUrlMapsScopedList(data: any): UrlMapsScopedList {
  return {
    ...data,
    urlMaps: data["urlMaps"] !== undefined ? data["urlMaps"].map((item: any) => (deserializeUrlMap(item))) : undefined,
  };
}

/**
 * Additional options for Compute#urlMapsUpdate.
 */
export interface UrlMapsUpdateOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface UrlMapsValidateRequest {
  /**
   * Specifies the load balancer type(s) this validation request is for. Use
   * EXTERNAL_MANAGED for HTTP/HTTPS External Global Load Balancer with Advanced
   * Traffic Management. Use EXTERNAL for Classic HTTP/HTTPS External Global
   * Load Balancer. Other load balancer types are not supported. For more
   * information, refer to Choosing a load balancer. If unspecified, the load
   * balancing scheme will be inferred from the backend service resources this
   * URL map references. If that can not be inferred (for example, this URL map
   * only references backend buckets, or this Url map is for rewrites and
   * redirects only and doesn't reference any backends), EXTERNAL will be used
   * as the default type. If specified, the scheme(s) must not conflict with the
   * load balancing scheme of the backend service resources this Url map
   * references.
   */
  loadBalancingSchemes?:  | "EXTERNAL" | "EXTERNAL_MANAGED" | "LOAD_BALANCING_SCHEME_UNSPECIFIED"[];
  /**
   * Content of the UrlMap to be validated.
   */
  resource?: UrlMap;
}

function serializeUrlMapsValidateRequest(data: any): UrlMapsValidateRequest {
  return {
    ...data,
    resource: data["resource"] !== undefined ? serializeUrlMap(data["resource"]) : undefined,
  };
}

function deserializeUrlMapsValidateRequest(data: any): UrlMapsValidateRequest {
  return {
    ...data,
    resource: data["resource"] !== undefined ? deserializeUrlMap(data["resource"]) : undefined,
  };
}

export interface UrlMapsValidateResponse {
  result?: UrlMapValidationResult;
}

/**
 * Message for the expected URL mappings.
 */
export interface UrlMapTest {
  /**
   * Description of this test case.
   */
  description?: string;
  /**
   * The expected output URL evaluated by the load balancer containing the
   * scheme, host, path and query parameters. For rules that forward requests to
   * backends, the test passes only when expectedOutputUrl matches the request
   * forwarded by the load balancer to backends. For rules with urlRewrite, the
   * test verifies that the forwarded request matches hostRewrite and
   * pathPrefixRewrite in the urlRewrite action. When service is specified,
   * expectedOutputUrl`s scheme is ignored. For rules with urlRedirect, the test
   * passes only if expectedOutputUrl matches the URL in the load balancer's
   * redirect response. If urlRedirect specifies https_redirect, the test passes
   * only if the scheme in expectedOutputUrl is also set to HTTPS. If
   * urlRedirect specifies strip_query, the test passes only if
   * expectedOutputUrl does not contain any query parameters. expectedOutputUrl
   * is optional when service is specified.
   */
  expectedOutputUrl?: string;
  /**
   * For rules with urlRedirect, the test passes only if
   * expectedRedirectResponseCode matches the HTTP status code in load
   * balancer's redirect response. expectedRedirectResponseCode cannot be set
   * when service is set.
   */
  expectedRedirectResponseCode?: number;
  /**
   * HTTP headers for this request. If headers contains a host header, then
   * host must also match the header value.
   */
  headers?: UrlMapTestHeader[];
  /**
   * Host portion of the URL. If headers contains a host header, then host must
   * also match the header value.
   */
  host?: string;
  /**
   * Path portion of the URL.
   */
  path?: string;
  /**
   * Expected BackendService or BackendBucket resource the given URL should be
   * mapped to. The service field cannot be set if expectedRedirectResponseCode
   * is set.
   */
  service?: string;
}

/**
 * HTTP headers used in UrlMapTests.
 */
export interface UrlMapTestHeader {
  /**
   * Header name.
   */
  name?: string;
  /**
   * Header value.
   */
  value?: string;
}

/**
 * Message representing the validation result for a UrlMap.
 */
export interface UrlMapValidationResult {
  loadErrors?: string[];
  /**
   * Whether the given UrlMap can be successfully loaded. If false,
   * 'loadErrors' indicates the reasons.
   */
  loadSucceeded?: boolean;
  testFailures?: TestFailure[];
  /**
   * If successfully loaded, this field indicates whether the test passed. If
   * false, 'testFailures's indicate the reason of failure.
   */
  testPassed?: boolean;
}

/**
 * The spec for modifying the path before sending the request to the matched
 * backend service.
 */
export interface UrlRewrite {
  /**
   * Before forwarding the request to the selected service, the request's host
   * header is replaced with contents of hostRewrite. The value must be from 1
   * to 255 characters.
   */
  hostRewrite?: string;
  /**
   * Before forwarding the request to the selected backend service, the
   * matching portion of the request's path is replaced by pathPrefixRewrite.
   * The value must be from 1 to 1024 characters.
   */
  pathPrefixRewrite?: string;
}

/**
 * Subnetwork which the current user has compute.subnetworks.use permission on.
 */
export interface UsableSubnetwork {
  /**
   * [Output Only] The external IPv6 address range that is assigned to this
   * subnetwork.
   */
  externalIpv6Prefix?: string;
  /**
   * [Output Only] The internal IPv6 address range that is assigned to this
   * subnetwork.
   */
  internalIpv6Prefix?: string;
  /**
   * The range of internal addresses that are owned by this subnetwork.
   */
  ipCidrRange?: string;
  /**
   * The access type of IPv6 address this subnet holds. It's immutable and can
   * only be specified during creation or the first time the subnet is updated
   * into IPV4_IPV6 dual stack.
   */
  ipv6AccessType?:  | "EXTERNAL" | "INTERNAL";
  /**
   * Network URL.
   */
  network?: string;
  /**
   * The purpose of the resource. This field can be either PRIVATE_RFC_1918 or
   * INTERNAL_HTTPS_LOAD_BALANCER. A subnetwork with purpose set to
   * INTERNAL_HTTPS_LOAD_BALANCER is a user-created subnetwork that is reserved
   * for Internal HTTP(S) Load Balancing. If unspecified, the purpose defaults
   * to PRIVATE_RFC_1918. The enableFlowLogs field isn't supported with the
   * purpose field set to INTERNAL_HTTPS_LOAD_BALANCER.
   */
  purpose?:  | "INTERNAL_HTTPS_LOAD_BALANCER" | "PRIVATE" | "PRIVATE_RFC_1918" | "PRIVATE_SERVICE_CONNECT" | "REGIONAL_MANAGED_PROXY";
  /**
   * The role of subnetwork. Currently, this field is only used when purpose =
   * INTERNAL_HTTPS_LOAD_BALANCER. The value can be set to ACTIVE or BACKUP. An
   * ACTIVE subnetwork is one that is currently being used for Internal HTTP(S)
   * Load Balancing. A BACKUP subnetwork is one that is ready to be promoted to
   * ACTIVE or is currently draining. This field can be updated with a patch
   * request.
   */
  role?:  | "ACTIVE" | "BACKUP";
  /**
   * Secondary IP ranges.
   */
  secondaryIpRanges?: UsableSubnetworkSecondaryRange[];
  /**
   * The stack type for the subnet. If set to IPV4_ONLY, new VMs in the subnet
   * are assigned IPv4 addresses only. If set to IPV4_IPV6, new VMs in the
   * subnet can be assigned both IPv4 and IPv6 addresses. If not specified,
   * IPV4_ONLY is used. This field can be both set at resource creation time and
   * updated using patch.
   */
  stackType?:  | "IPV4_IPV6" | "IPV4_ONLY";
  /**
   * Subnetwork URL.
   */
  subnetwork?: string;
}

export interface UsableSubnetworksAggregatedList {
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: string;
  /**
   * [Output] A list of usable subnetwork URLs.
   */
  items?: UsableSubnetwork[];
  /**
   * [Output Only] Type of resource. Always
   * compute#usableSubnetworksAggregatedList for aggregated lists of usable
   * subnetworks.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results. In special cases listUsable may return
   * 0 subnetworks and nextPageToken which still should be used to get the next
   * page of results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

/**
 * Secondary IP range of a usable subnetwork.
 */
export interface UsableSubnetworkSecondaryRange {
  /**
   * The range of IP addresses belonging to this subnetwork secondary range.
   */
  ipCidrRange?: string;
  /**
   * The name associated with this subnetwork secondary range, used when adding
   * an alias IP range to a VM instance. The name must be 1-63 characters long,
   * and comply with RFC1035. The name must be unique within the subnetwork.
   */
  rangeName?: string;
}

/**
 * The location in Cloud Storage and naming method of the daily usage report.
 * Contains bucket_name and report_name prefix.
 */
export interface UsageExportLocation {
  /**
   * The name of an existing bucket in Cloud Storage where the usage report
   * object is stored. The Google Service Account is granted write access to
   * this bucket. This can either be the bucket name by itself, such as
   * example-bucket, or the bucket name with gs:// or
   * https://storage.googleapis.com/ in front of it, such as
   * gs://example-bucket.
   */
  bucketName?: string;
  /**
   * An optional prefix for the name of the usage report object stored in
   * bucketName. If not supplied, defaults to usage_gce. The report is stored as
   * a CSV file named report_name_prefix_gce_YYYYMMDD.csv where YYYYMMDD is the
   * day of the usage according to Pacific Time. If you supply a prefix, it
   * should conform to Cloud Storage object naming conventions.
   */
  reportNamePrefix?: string;
}

/**
 * Contain information of Nat mapping for a VM endpoint (i.e., NIC).
 */
export interface VmEndpointNatMappings {
  /**
   * Name of the VM instance which the endpoint belongs to
   */
  instanceName?: string;
  interfaceNatMappings?: VmEndpointNatMappingsInterfaceNatMappings[];
}

/**
 * Contain information of Nat mapping for an interface of this endpoint.
 */
export interface VmEndpointNatMappingsInterfaceNatMappings {
  /**
   * List of all drain IP:port-range mappings assigned to this interface. These
   * ranges are inclusive, that is, both the first and the last ports can be
   * used for NAT. Example: ["2.2.2.2:12345-12355", "1.1.1.1:2234-2234"].
   */
  drainNatIpPortRanges?: string[];
  /**
   * A list of all IP:port-range mappings assigned to this interface. These
   * ranges are inclusive, that is, both the first and the last ports can be
   * used for NAT. Example: ["2.2.2.2:12345-12355", "1.1.1.1:2234-2234"].
   */
  natIpPortRanges?: string[];
  /**
   * Total number of drain ports across all NAT IPs allocated to this
   * interface. It equals to the aggregated port number in the field
   * drain_nat_ip_port_ranges.
   */
  numTotalDrainNatPorts?: number;
  /**
   * Total number of ports across all NAT IPs allocated to this interface. It
   * equals to the aggregated port number in the field nat_ip_port_ranges.
   */
  numTotalNatPorts?: number;
  /**
   * Information about mappings provided by rules in this NAT.
   */
  ruleMappings?: VmEndpointNatMappingsInterfaceNatMappingsNatRuleMappings[];
  /**
   * Alias IP range for this interface endpoint. It will be a private (RFC
   * 1918) IP range. Examples: "10.33.4.55/32", or "192.168.5.0/24".
   */
  sourceAliasIpRange?: string;
  /**
   * Primary IP of the VM for this NIC.
   */
  sourceVirtualIp?: string;
}

/**
 * Contains information of NAT Mappings provided by a NAT Rule.
 */
export interface VmEndpointNatMappingsInterfaceNatMappingsNatRuleMappings {
  /**
   * List of all drain IP:port-range mappings assigned to this interface by
   * this rule. These ranges are inclusive, that is, both the first and the last
   * ports can be used for NAT. Example: ["2.2.2.2:12345-12355",
   * "1.1.1.1:2234-2234"].
   */
  drainNatIpPortRanges?: string[];
  /**
   * A list of all IP:port-range mappings assigned to this interface by this
   * rule. These ranges are inclusive, that is, both the first and the last
   * ports can be used for NAT. Example: ["2.2.2.2:12345-12355",
   * "1.1.1.1:2234-2234"].
   */
  natIpPortRanges?: string[];
  /**
   * Total number of drain ports across all NAT IPs allocated to this interface
   * by this rule. It equals the aggregated port number in the field
   * drain_nat_ip_port_ranges.
   */
  numTotalDrainNatPorts?: number;
  /**
   * Total number of ports across all NAT IPs allocated to this interface by
   * this rule. It equals the aggregated port number in the field
   * nat_ip_port_ranges.
   */
  numTotalNatPorts?: number;
  /**
   * Rule number of the NAT Rule.
   */
  ruleNumber?: number;
}

/**
 * Contains a list of VmEndpointNatMappings.
 */
export interface VmEndpointNatMappingsList {
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: string;
  /**
   * [Output Only] Type of resource. Always compute#vmEndpointNatMappingsList
   * for lists of Nat mappings of VM endpoints.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] A list of Nat mapping information of VM endpoints.
   */
  result?: VmEndpointNatMappings[];
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

/**
 * Represents a HA VPN gateway. HA VPN is a high-availability (HA) Cloud VPN
 * solution that lets you securely connect your on-premises network to your
 * Google Cloud Virtual Private Cloud network through an IPsec VPN connection in
 * a single region. For more information about Cloud HA VPN solutions, see Cloud
 * VPN topologies .
 */
export interface VpnGateway {
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of resource. Always compute#vpnGateway for VPN
   * gateways.
   */
  kind?: string;
  /**
   * A fingerprint for the labels being applied to this VpnGateway, which is
   * essentially a hash of the labels set used for optimistic locking. The
   * fingerprint is initially generated by Compute Engine and changes after
   * every request to modify or update labels. You must always provide an
   * up-to-date fingerprint hash in order to update or change labels, otherwise
   * the request will fail with error 412 conditionNotMet. To see the latest
   * fingerprint, make a get() request to retrieve a VpnGateway.
   */
  labelFingerprint?: Uint8Array;
  /**
   * Labels for this resource. These can only be added or modified by the
   * setLabels method. Each label key/value pair must comply with RFC1035. Label
   * values may be empty.
   */
  labels?: {
    [key: string]: string
  };
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * URL of the network to which this VPN gateway is attached. Provided by the
   * client when the VPN gateway is created.
   */
  network?: string;
  /**
   * [Output Only] URL of the region where the VPN gateway resides.
   */
  region?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * The stack type for this VPN gateway to identify the IP protocols that are
   * enabled. Possible values are: IPV4_ONLY, IPV4_IPV6. If not specified,
   * IPV4_ONLY will be used.
   */
  stackType?:  | "IPV4_IPV6" | "IPV4_ONLY";
  /**
   * The list of VPN interfaces associated with this VPN gateway.
   */
  vpnInterfaces?: VpnGatewayVpnGatewayInterface[];
}

function serializeVpnGateway(data: any): VpnGateway {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
    labelFingerprint: data["labelFingerprint"] !== undefined ? encodeBase64(data["labelFingerprint"]) : undefined,
  };
}

function deserializeVpnGateway(data: any): VpnGateway {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
    labelFingerprint: data["labelFingerprint"] !== undefined ? decodeBase64(data["labelFingerprint"] as string) : undefined,
  };
}

export interface VpnGatewayAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of VpnGateway resources.
   */
  items?: {
    [key: string]: VpnGatewaysScopedList
  };
  /**
   * [Output Only] Type of resource. Always compute#vpnGateway for VPN
   * gateways.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeVpnGatewayAggregatedList(data: any): VpnGatewayAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeVpnGatewaysScopedList(v)]))) : undefined,
  };
}

function deserializeVpnGatewayAggregatedList(data: any): VpnGatewayAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeVpnGatewaysScopedList(v)]))) : undefined,
  };
}

/**
 * Contains a list of VpnGateway resources.
 */
export interface VpnGatewayList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of VpnGateway resources.
   */
  items?: VpnGateway[];
  /**
   * [Output Only] Type of resource. Always compute#vpnGateway for VPN
   * gateways.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeVpnGatewayList(data: any): VpnGatewayList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeVpnGateway(item))) : undefined,
  };
}

function deserializeVpnGatewayList(data: any): VpnGatewayList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeVpnGateway(item))) : undefined,
  };
}

/**
 * Additional options for Compute#vpnGatewaysAggregatedList.
 */
export interface VpnGatewaysAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#vpnGatewaysDelete.
 */
export interface VpnGatewaysDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface VpnGatewaysGetStatusResponse {
  result?: VpnGatewayStatus;
}

/**
 * Additional options for Compute#vpnGatewaysInsert.
 */
export interface VpnGatewaysInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#vpnGatewaysList.
 */
export interface VpnGatewaysListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface VpnGatewaysScopedList {
  /**
   * [Output Only] A list of VPN gateways contained in this scope.
   */
  vpnGateways?: VpnGateway[];
  /**
   * [Output Only] Informational warning which replaces the list of addresses
   * when the list is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeVpnGatewaysScopedList(data: any): VpnGatewaysScopedList {
  return {
    ...data,
    vpnGateways: data["vpnGateways"] !== undefined ? data["vpnGateways"].map((item: any) => (serializeVpnGateway(item))) : undefined,
  };
}

function deserializeVpnGatewaysScopedList(data: any): VpnGatewaysScopedList {
  return {
    ...data,
    vpnGateways: data["vpnGateways"] !== undefined ? data["vpnGateways"].map((item: any) => (deserializeVpnGateway(item))) : undefined,
  };
}

/**
 * Additional options for Compute#vpnGatewaysSetLabels.
 */
export interface VpnGatewaysSetLabelsOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface VpnGatewayStatus {
  /**
   * List of VPN connection for this VpnGateway.
   */
  vpnConnections?: VpnGatewayStatusVpnConnection[];
}

/**
 * Describes the high availability requirement state for the VPN connection
 * between this Cloud VPN gateway and a peer gateway.
 */
export interface VpnGatewayStatusHighAvailabilityRequirementState {
  /**
   * Indicates the high availability requirement state for the VPN connection.
   * Valid values are CONNECTION_REDUNDANCY_MET, CONNECTION_REDUNDANCY_NOT_MET.
   */
  state?:  | "CONNECTION_REDUNDANCY_MET" | "CONNECTION_REDUNDANCY_NOT_MET";
  /**
   * Indicates the reason why the VPN connection does not meet the high
   * availability redundancy criteria/requirement. Valid values is
   * INCOMPLETE_TUNNELS_COVERAGE.
   */
  unsatisfiedReason?:  | "INCOMPLETE_TUNNELS_COVERAGE";
}

/**
 * Contains some information about a VPN tunnel.
 */
export interface VpnGatewayStatusTunnel {
  /**
   * The VPN gateway interface this VPN tunnel is associated with.
   */
  localGatewayInterface?: number;
  /**
   * The peer gateway interface this VPN tunnel is connected to, the peer
   * gateway could either be an external VPN gateway or GCP VPN gateway.
   */
  peerGatewayInterface?: number;
  /**
   * URL reference to the VPN tunnel.
   */
  tunnelUrl?: string;
}

/**
 * A VPN connection contains all VPN tunnels connected from this VpnGateway to
 * the same peer gateway. The peer gateway could either be a external VPN
 * gateway or GCP VPN gateway.
 */
export interface VpnGatewayStatusVpnConnection {
  /**
   * URL reference to the peer external VPN gateways to which the VPN tunnels
   * in this VPN connection are connected. This field is mutually exclusive with
   * peer_gcp_gateway.
   */
  peerExternalGateway?: string;
  /**
   * URL reference to the peer side VPN gateways to which the VPN tunnels in
   * this VPN connection are connected. This field is mutually exclusive with
   * peer_gcp_gateway.
   */
  peerGcpGateway?: string;
  /**
   * HighAvailabilityRequirementState for the VPN connection.
   */
  state?: VpnGatewayStatusHighAvailabilityRequirementState;
  /**
   * List of VPN tunnels that are in this VPN connection.
   */
  tunnels?: VpnGatewayStatusTunnel[];
}

/**
 * A VPN gateway interface.
 */
export interface VpnGatewayVpnGatewayInterface {
  /**
   * [Output Only] Numeric identifier for this VPN interface associated with
   * the VPN gateway.
   */
  id?: number;
  /**
   * URL of the VLAN attachment (interconnectAttachment) resource for this VPN
   * gateway interface. When the value of this field is present, the VPN gateway
   * is used for HA VPN over Cloud Interconnect; all egress or ingress traffic
   * for this VPN gateway interface goes through the specified VLAN attachment
   * resource.
   */
  interconnectAttachment?: string;
  /**
   * [Output Only] IP address for this VPN interface associated with the VPN
   * gateway. The IP address could be either a regional external IP address or a
   * regional internal IP address. The two IP addresses for a VPN gateway must
   * be all regional external or regional internal IP addresses. There cannot be
   * a mix of regional external IP addresses and regional internal IP addresses.
   * For HA VPN over Cloud Interconnect, the IP addresses for both interfaces
   * could either be regional internal IP addresses or regional external IP
   * addresses. For regular (non HA VPN over Cloud Interconnect) HA VPN tunnels,
   * the IP address must be a regional external IP address.
   */
  ipAddress?: string;
}

/**
 * Represents a Cloud VPN Tunnel resource. For more information about VPN, read
 * the the Cloud VPN Overview.
 */
export interface VpnTunnel {
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * An optional description of this resource. Provide this property when you
   * create the resource.
   */
  description?: string;
  /**
   * [Output Only] Detailed status message for the VPN tunnel.
   */
  detailedStatus?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * IKE protocol version to use when establishing the VPN tunnel with the peer
   * VPN gateway. Acceptable IKE versions are 1 or 2. The default version is 2.
   */
  ikeVersion?: number;
  /**
   * [Output Only] Type of resource. Always compute#vpnTunnel for VPN tunnels.
   */
  kind?: string;
  /**
   * Local traffic selector to use when establishing the VPN tunnel with the
   * peer VPN gateway. The value should be a CIDR formatted string, for example:
   * 192.168.0.0/16. The ranges must be disjoint. Only IPv4 is supported.
   */
  localTrafficSelector?: string[];
  /**
   * Name of the resource. Provided by the client when the resource is created.
   * The name must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the name must be 1-63 characters long and match the regular
   * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
   * must be a lowercase letter, and all following characters must be a dash,
   * lowercase letter, or digit, except the last character, which cannot be a
   * dash.
   */
  name?: string;
  /**
   * URL of the peer side external VPN gateway to which this VPN tunnel is
   * connected. Provided by the client when the VPN tunnel is created. This
   * field is exclusive with the field peerGcpGateway.
   */
  peerExternalGateway?: string;
  /**
   * The interface ID of the external VPN gateway to which this VPN tunnel is
   * connected. Provided by the client when the VPN tunnel is created. Possible
   * values are: `0`, `1`, `2`, `3`. The number of IDs in use depends on the
   * external VPN gateway redundancy type.
   */
  peerExternalGatewayInterface?: number;
  /**
   * URL of the peer side HA GCP VPN gateway to which this VPN tunnel is
   * connected. Provided by the client when the VPN tunnel is created. This
   * field can be used when creating highly available VPN from VPC network to
   * VPC network, the field is exclusive with the field peerExternalGateway. If
   * provided, the VPN tunnel will automatically use the same
   * vpnGatewayInterface ID in the peer GCP VPN gateway.
   */
  peerGcpGateway?: string;
  /**
   * IP address of the peer VPN gateway. Only IPv4 is supported.
   */
  peerIp?: string;
  /**
   * [Output Only] URL of the region where the VPN tunnel resides. You must
   * specify this field as part of the HTTP request URL. It is not settable as a
   * field in the request body.
   */
  region?: string;
  /**
   * Remote traffic selectors to use when establishing the VPN tunnel with the
   * peer VPN gateway. The value should be a CIDR formatted string, for example:
   * 192.168.0.0/16. The ranges should be disjoint. Only IPv4 is supported.
   */
  remoteTrafficSelector?: string[];
  /**
   * URL of the router resource to be used for dynamic routing.
   */
  router?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * Shared secret used to set the secure session between the Cloud VPN gateway
   * and the peer VPN gateway.
   */
  sharedSecret?: string;
  /**
   * Hash of the shared secret.
   */
  sharedSecretHash?: string;
  /**
   * [Output Only] The status of the VPN tunnel, which can be one of the
   * following: - PROVISIONING: Resource is being allocated for the VPN tunnel.
   * - WAITING_FOR_FULL_CONFIG: Waiting to receive all VPN-related configs from
   * the user. Network, TargetVpnGateway, VpnTunnel, ForwardingRule, and Route
   * resources are needed to setup the VPN tunnel. - FIRST_HANDSHAKE: Successful
   * first handshake with the peer VPN. - ESTABLISHED: Secure session is
   * successfully established with the peer VPN. - NETWORK_ERROR: Deprecated,
   * replaced by NO_INCOMING_PACKETS - AUTHORIZATION_ERROR: Auth error (for
   * example, bad shared secret). - NEGOTIATION_FAILURE: Handshake failed. -
   * DEPROVISIONING: Resources are being deallocated for the VPN tunnel. -
   * FAILED: Tunnel creation has failed and the tunnel is not ready to be used.
   * - NO_INCOMING_PACKETS: No incoming packets from peer. - REJECTED: Tunnel
   * configuration was rejected, can be result of being denied access. -
   * ALLOCATING_RESOURCES: Cloud VPN is in the process of allocating all
   * required resources. - STOPPED: Tunnel is stopped due to its Forwarding
   * Rules being deleted for Classic VPN tunnels or the project is in frozen
   * state. - PEER_IDENTITY_MISMATCH: Peer identity does not match peer IP,
   * probably behind NAT. - TS_NARROWING_NOT_ALLOWED: Traffic selector narrowing
   * not allowed for an HA-VPN tunnel.
   */
  status?:  | "ALLOCATING_RESOURCES" | "AUTHORIZATION_ERROR" | "DEPROVISIONING" | "ESTABLISHED" | "FAILED" | "FIRST_HANDSHAKE" | "NEGOTIATION_FAILURE" | "NETWORK_ERROR" | "NO_INCOMING_PACKETS" | "PROVISIONING" | "REJECTED" | "STOPPED" | "WAITING_FOR_FULL_CONFIG";
  /**
   * URL of the Target VPN gateway with which this VPN tunnel is associated.
   * Provided by the client when the VPN tunnel is created.
   */
  targetVpnGateway?: string;
  /**
   * URL of the VPN gateway with which this VPN tunnel is associated. Provided
   * by the client when the VPN tunnel is created. This must be used (instead of
   * target_vpn_gateway) if a High Availability VPN gateway resource is created.
   */
  vpnGateway?: string;
  /**
   * The interface ID of the VPN gateway with which this VPN tunnel is
   * associated. Possible values are: `0`, `1`.
   */
  vpnGatewayInterface?: number;
}

function serializeVpnTunnel(data: any): VpnTunnel {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeVpnTunnel(data: any): VpnTunnel {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

export interface VpnTunnelAggregatedList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of VpnTunnelsScopedList resources.
   */
  items?: {
    [key: string]: VpnTunnelsScopedList
  };
  /**
   * [Output Only] Type of resource. Always compute#vpnTunnel for VPN tunnels.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Unreachable resources.
   */
  unreachables?: string[];
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeVpnTunnelAggregatedList(data: any): VpnTunnelAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, serializeVpnTunnelsScopedList(v)]))) : undefined,
  };
}

function deserializeVpnTunnelAggregatedList(data: any): VpnTunnelAggregatedList {
  return {
    ...data,
    items: data["items"] !== undefined ? Object.fromEntries(Object.entries(data["items"]).map(([k, v]: [string, any]) => ([k, deserializeVpnTunnelsScopedList(v)]))) : undefined,
  };
}

/**
 * Contains a list of VpnTunnel resources.
 */
export interface VpnTunnelList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of VpnTunnel resources.
   */
  items?: VpnTunnel[];
  /**
   * [Output Only] Type of resource. Always compute#vpnTunnel for VPN tunnels.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeVpnTunnelList(data: any): VpnTunnelList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeVpnTunnel(item))) : undefined,
  };
}

function deserializeVpnTunnelList(data: any): VpnTunnelList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeVpnTunnel(item))) : undefined,
  };
}

/**
 * Additional options for Compute#vpnTunnelsAggregatedList.
 */
export interface VpnTunnelsAggregatedListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * Indicates whether every visible scope for each scope type (zone, region,
   * global) should be included in the response. For new resource types added
   * after this field, the flag has no effect as new resource types will always
   * include every visible scope for each scope type in response. For resource
   * types which predate this field, if this flag is omitted or false, only
   * scopes of the scope types where the resource type is expected to be found
   * will be included.
   */
  includeAllScopes?: boolean;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

/**
 * Additional options for Compute#vpnTunnelsDelete.
 */
export interface VpnTunnelsDeleteOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#vpnTunnelsInsert.
 */
export interface VpnTunnelsInsertOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

/**
 * Additional options for Compute#vpnTunnelsList.
 */
export interface VpnTunnelsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface VpnTunnelsScopedList {
  /**
   * A list of VPN tunnels contained in this scope.
   */
  vpnTunnels?: VpnTunnel[];
  /**
   * Informational warning which replaces the list of addresses when the list
   * is empty.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeVpnTunnelsScopedList(data: any): VpnTunnelsScopedList {
  return {
    ...data,
    vpnTunnels: data["vpnTunnels"] !== undefined ? data["vpnTunnels"].map((item: any) => (serializeVpnTunnel(item))) : undefined,
  };
}

function deserializeVpnTunnelsScopedList(data: any): VpnTunnelsScopedList {
  return {
    ...data,
    vpnTunnels: data["vpnTunnels"] !== undefined ? data["vpnTunnels"].map((item: any) => (deserializeVpnTunnel(item))) : undefined,
  };
}

/**
 * Additional options for Compute#vpnTunnelsSetLabels.
 */
export interface VpnTunnelsSetLabelsOptions {
  /**
   * An optional request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore the
   * request if it has already been completed. For example, consider a situation
   * where you make an initial request and the request times out. If you make
   * the request again with the same request ID, the server can check if
   * original operation with the same request ID was received, and if so, will
   * ignore the second request. This prevents clients from accidentally creating
   * duplicate commitments. The request ID must be a valid UUID with the
   * exception that zero UUID is not supported (
   * 00000000-0000-0000-0000-000000000000).
   */
  requestId?: string;
}

export interface WafExpressionSet {
  /**
   * A list of alternate IDs. The format should be: - E.g. XSS-stable Generic
   * suffix like "stable" is particularly useful if a policy likes to avail
   * newer set of expressions without having to change the policy. A given alias
   * name can't be used for more than one entity set.
   */
  aliases?: string[];
  /**
   * List of available expressions.
   */
  expressions?: WafExpressionSetExpression[];
  /**
   * Google specified expression set ID. The format should be: - E.g.
   * XSS-20170329 required
   */
  id?: string;
}

export interface WafExpressionSetExpression {
  /**
   * Expression ID should uniquely identify the origin of the expression. E.g.
   * owasp-crs-v020901-id973337 identifies Owasp core rule set version 2.9.1
   * rule id 973337. The ID could be used to determine the individual attack
   * definition that has been detected. It could also be used to exclude it from
   * the policy in case of false positive. required
   */
  id?: string;
  /**
   * The sensitivity value associated with the WAF rule ID. This corresponds to
   * the ModSecurity paranoia level, ranging from 1 to 4. 0 is reserved for
   * opt-in only rules.
   */
  sensitivity?: number;
}

/**
 * In contrast to a single BackendService in HttpRouteAction to which all
 * matching traffic is directed to, WeightedBackendService allows traffic to be
 * split across multiple backend services. The volume of traffic for each
 * backend service is proportional to the weight specified in each
 * WeightedBackendService
 */
export interface WeightedBackendService {
  /**
   * The full or partial URL to the default BackendService resource. Before
   * forwarding the request to backendService, the load balancer applies any
   * relevant headerActions specified as part of this backendServiceWeight.
   */
  backendService?: string;
  /**
   * Specifies changes to request and response headers that need to take effect
   * for the selected backendService. headerAction specified here take effect
   * before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
   * headerAction is not supported for load balancers that have their
   * loadBalancingScheme set to EXTERNAL. Not supported when the URL map is
   * bound to a target gRPC proxy that has validateForProxyless field set to
   * true.
   */
  headerAction?: HttpHeaderAction;
  /**
   * Specifies the fraction of traffic sent to a backend service, computed as
   * weight / (sum of all weightedBackendService weights in routeAction) . The
   * selection of a backend service is determined only for new traffic. Once a
   * user's request has been directed to a backend service, subsequent requests
   * are sent to the same backend service as determined by the backend service's
   * session affinity policy. The value must be from 0 to 1000.
   */
  weight?: number;
}

export interface XpnHostList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * [Output Only] A list of shared VPC host project URLs.
   */
  items?: Project[];
  /**
   * [Output Only] Type of resource. Always compute#xpnHostList for lists of
   * shared VPC hosts.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeXpnHostList(data: any): XpnHostList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeProject(item))) : undefined,
  };
}

function deserializeXpnHostList(data: any): XpnHostList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeProject(item))) : undefined,
  };
}

/**
 * Service resource (a.k.a service project) ID.
 */
export interface XpnResourceId {
  /**
   * The ID of the service resource. In the case of projects, this field
   * supports project id (e.g., my-project-123) and project number (e.g.
   * 12345678).
   */
  id?: string;
  /**
   * The type of the service resource.
   */
  type?:  | "PROJECT" | "XPN_RESOURCE_TYPE_UNSPECIFIED";
}

/**
 * Represents a Zone resource. A zone is a deployment area. These deployment
 * areas are subsets of a region. For example the zone us-east1-a is located in
 * the us-east1 region. For more information, read Regions and Zones.
 */
export interface Zone {
  /**
   * [Output Only] Available cpu/platform selections for the zone.
   */
  availableCpuPlatforms?: string[];
  /**
   * [Output Only] Creation timestamp in RFC3339 text format.
   */
  creationTimestamp?: string;
  /**
   * [Output Only] The deprecation status associated with this zone.
   */
  deprecated?: DeprecationStatus;
  /**
   * [Output Only] Textual description of the resource.
   */
  description?: string;
  /**
   * [Output Only] The unique identifier for the resource. This identifier is
   * defined by the server.
   */
  id?: bigint;
  /**
   * [Output Only] Type of the resource. Always compute#zone for zones.
   */
  kind?: string;
  /**
   * [Output Only] Name of the resource.
   */
  name?: string;
  /**
   * [Output Only] Full URL reference to the region which hosts the zone.
   */
  region?: string;
  /**
   * [Output Only] Server-defined URL for the resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Status of the zone, either UP or DOWN.
   */
  status?:  | "DOWN" | "UP";
  /**
   * [Output Only] Reserved for future use.
   */
  supportsPzs?: boolean;
}

function serializeZone(data: any): Zone {
  return {
    ...data,
    id: data["id"] !== undefined ? String(data["id"]) : undefined,
  };
}

function deserializeZone(data: any): Zone {
  return {
    ...data,
    id: data["id"] !== undefined ? BigInt(data["id"]) : undefined,
  };
}

/**
 * Contains a list of zone resources.
 */
export interface ZoneList {
  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
   */
  id?: string;
  /**
   * A list of Zone resources.
   */
  items?: Zone[];
  /**
   * Type of resource.
   */
  kind?: string;
  /**
   * [Output Only] This token allows you to get the next page of results for
   * list requests. If the number of results is larger than maxResults, use the
   * nextPageToken as a value for the query parameter pageToken in the next list
   * request. Subsequent list requests will have their own nextPageToken to
   * continue paging through the results.
   */
  nextPageToken?: string;
  /**
   * [Output Only] Server-defined URL for this resource.
   */
  selfLink?: string;
  /**
   * [Output Only] Informational warning message.
   */
  warning?: {
    code?:  | "CLEANUP_FAILED" | "DEPRECATED_RESOURCE_USED" | "DEPRECATED_TYPE_USED" | "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" | "EXPERIMENTAL_TYPE_USED" | "EXTERNAL_API_WARNING" | "FIELD_VALUE_OVERRIDEN" | "INJECTED_KERNELS_DEPRECATED" | "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" | "LARGE_DEPLOYMENT_WARNING" | "MISSING_TYPE_DEPENDENCY" | "NEXT_HOP_ADDRESS_NOT_ASSIGNED" | "NEXT_HOP_CANNOT_IP_FORWARD" | "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" | "NEXT_HOP_INSTANCE_NOT_FOUND" | "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" | "NEXT_HOP_NOT_RUNNING" | "NOT_CRITICAL_ERROR" | "NO_RESULTS_ON_PAGE" | "PARTIAL_SUCCESS" | "REQUIRED_TOS_AGREEMENT" | "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" | "RESOURCE_NOT_DELETED" | "SCHEMA_VALIDATION_IGNORED" | "SINGLE_INSTANCE_PROPERTY_TEMPLATE" | "UNDECLARED_PROPERTIES" | "UNREACHABLE";
    data?: {
      key?: string;
      value?: string;
    }[];
    message?: string;
  };
}

function serializeZoneList(data: any): ZoneList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (serializeZone(item))) : undefined,
  };
}

function deserializeZoneList(data: any): ZoneList {
  return {
    ...data,
    items: data["items"] !== undefined ? data["items"].map((item: any) => (deserializeZone(item))) : undefined,
  };
}

/**
 * Additional options for Compute#zoneOperationsList.
 */
export interface ZoneOperationsListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

export interface ZoneSetLabelsRequest {
  /**
   * The fingerprint of the previous set of labels for this resource, used to
   * detect conflicts. The fingerprint is initially generated by Compute Engine
   * and changes after every request to modify or update labels. You must always
   * provide an up-to-date fingerprint hash in order to update or change labels.
   * Make a get() request to the resource to get the latest fingerprint.
   */
  labelFingerprint?: Uint8Array;
  /**
   * The labels to set for this resource.
   */
  labels?: {
    [key: string]: string
  };
}

function serializeZoneSetLabelsRequest(data: any): ZoneSetLabelsRequest {
  return {
    ...data,
    labelFingerprint: data["labelFingerprint"] !== undefined ? encodeBase64(data["labelFingerprint"]) : undefined,
  };
}

function deserializeZoneSetLabelsRequest(data: any): ZoneSetLabelsRequest {
  return {
    ...data,
    labelFingerprint: data["labelFingerprint"] !== undefined ? decodeBase64(data["labelFingerprint"] as string) : undefined,
  };
}

export interface ZoneSetPolicyRequest {
  /**
   * Flatten Policy to create a backwacd compatible wire-format. Deprecated.
   * Use 'policy' to specify bindings.
   */
  bindings?: Binding[];
  /**
   * Flatten Policy to create a backward compatible wire-format. Deprecated.
   * Use 'policy' to specify the etag.
   */
  etag?: Uint8Array;
  /**
   * REQUIRED: The complete policy to be applied to the 'resource'. The size of
   * the policy is limited to a few 10s of KB. An empty policy is in general a
   * valid policy but certain services (like Projects) might reject them.
   */
  policy?: Policy;
}

function serializeZoneSetPolicyRequest(data: any): ZoneSetPolicyRequest {
  return {
    ...data,
    etag: data["etag"] !== undefined ? encodeBase64(data["etag"]) : undefined,
    policy: data["policy"] !== undefined ? serializePolicy(data["policy"]) : undefined,
  };
}

function deserializeZoneSetPolicyRequest(data: any): ZoneSetPolicyRequest {
  return {
    ...data,
    etag: data["etag"] !== undefined ? decodeBase64(data["etag"] as string) : undefined,
    policy: data["policy"] !== undefined ? deserializePolicy(data["policy"]) : undefined,
  };
}

/**
 * Additional options for Compute#zonesList.
 */
export interface ZonesListOptions {
  /**
   * A filter expression that filters resources listed in the response. Most
   * Compute resources support two types of filter expressions: expressions that
   * support regular expressions and expressions that follow API improvement
   * proposal AIP-160. If you want to use AIP-160, your expression must specify
   * the field name, an operator, and the value that you want to use for
   * filtering. The value must be a string, a number, or a boolean. The operator
   * must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you
   * are filtering Compute Engine instances, you can exclude instances named
   * `example-instance` by specifying `name != example-instance`. The `:`
   * operator can be used with string fields to match substrings. For non-string
   * fields it is equivalent to the `=` operator. The `:*` comparison can be
   * used to test whether a key has been defined. For example, to find all
   * objects with `owner` label use: ``` labels.owner:* ``` You can also filter
   * nested fields. For example, you could specify `scheduling.automaticRestart
   * = false` to include instances only if they are not scheduled for automatic
   * restarts. You can use filtering on nested fields to filter based on
   * resource labels. To filter on multiple expressions, provide each separate
   * expression within parentheses. For example: ```
   * (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
   * default, each expression is an `AND` expression. However, you can include
   * `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
   * "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
   * (scheduling.automaticRestart = true) ``` If you want to use a regular
   * expression, use the `eq` (equal) or `ne` (not equal) operator against a
   * single un-parenthesized expression with or without quotes or against
   * multiple parenthesized expressions. Examples: `fieldname eq unquoted
   * literal` `fieldname eq 'single quoted literal'` `fieldname eq "double
   * quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The
   * literal value is interpreted as a regular expression using Google RE2
   * library syntax. The literal value must match the entire field. For example,
   * to filter for instances that do not end with name "instance", you would use
   * `name ne .*instance`.
   */
  filter?: string;
  /**
   * The maximum number of results per page that should be returned. If the
   * number of available results is larger than `maxResults`, Compute Engine
   * returns a `nextPageToken` that can be used to get the next page of results
   * in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
   * (Default: `500`)
   */
  maxResults?: number;
  /**
   * Sorts list results by a certain order. By default, results are returned in
   * alphanumerical order based on the resource name. You can also sort results
   * in descending order based on the creation timestamp using
   * `orderBy="creationTimestamp desc"`. This sorts results based on the
   * `creationTimestamp` field in reverse chronological order (newest result
   * first). Use this to sort resources like operations so that the newest
   * operation is returned first. Currently, only sorting by `name` or
   * `creationTimestamp desc` is supported.
   */
  orderBy?: string;
  /**
   * Specifies a page token to use. Set `pageToken` to the `nextPageToken`
   * returned by a previous list request to get the next page of results.
   */
  pageToken?: string;
  /**
   * Opt-in for partial success behavior which provides partial results in case
   * of failure. The default value is false.
   */
  returnPartialSuccess?: boolean;
}

function decodeBase64(b64: string): Uint8Array {
  const binString = atob(b64);
  const size = binString.length;
  const bytes = new Uint8Array(size);
  for (let i = 0; i < size; i++) {
    bytes[i] = binString.charCodeAt(i);
  }
  return bytes;
}

const base64abc = ["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","0","1","2","3","4","5","6","7","8","9","+","/"];
/**
 * CREDIT: https://gist.github.com/enepomnyaschih/72c423f727d395eeaa09697058238727
 * Encodes a given Uint8Array, ArrayBuffer or string into RFC4648 base64 representation
 * @param data
 */
function encodeBase64(uint8: Uint8Array): string {
  let result = "", i;
  const l = uint8.length;
  for (i = 2; i < l; i += 3) {
    result += base64abc[uint8[i - 2] >> 2];
    result += base64abc[((uint8[i - 2] & 0x03) << 4) | (uint8[i - 1] >> 4)];
    result += base64abc[((uint8[i - 1] & 0x0f) << 2) | (uint8[i] >> 6)];
    result += base64abc[uint8[i] & 0x3f];
  }
  if (i === l + 1) {
    // 1 octet yet to write
    result += base64abc[uint8[i - 2] >> 2];
    result += base64abc[(uint8[i - 2] & 0x03) << 4];
    result += "==";
  }
  if (i === l) {
    // 2 octets yet to write
    result += base64abc[uint8[i - 2] >> 2];
    result += base64abc[((uint8[i - 2] & 0x03) << 4) | (uint8[i - 1] >> 4)];
    result += base64abc[(uint8[i - 1] & 0x0f) << 2];
    result += "=";
  }
  return result;
}
